local game31s = {}

local cards = require("libs/cards/cards")

-- each player holds 3 cards in their hand at a time
local cards_per_hand = 3

-- e.g. having three cards of same val (e.g. all 8s, or all 2s) results in a score of 30
-- I think some variations claim it is 30.5?
local score_of_all_same_val = 30

local get_hand_score = nil

game31s.SRC_DECK    = 1
game31s.SRC_DISCARD = 2

game31s.SUCCESS                 =  0
game31s.NOT_YOUR_TURN           = -1 
game31s.STAGING_AREA_FULL       = -2
game31s.STAGING_AREA_EMPTY      = -3
game31s.SOMEONE_ALREADY_KNOCKED = -4
game31s.GAME_OVER               = -5

game31s.MSG_PLAYER  = "player"
game31s.MSG_DRAW    = "draw"
game31s.MSG_DISCARD = "discard"
game31s.MSG_KNOCK   = "knock"

function game31s.err_code_to_str(rc)
	local map = {
		[game31s.SUCCESS]            = "Sucess",
		[game31s.NOT_YOUR_TURN]      = "Not your turn",
		[game31s.STAGING_AREA_FULL]  = "Staging area full",
		[game31s.STAGING_AREA_EMPTY] = "Staging area empty",
		[game31s.SOMEONE_ALREADY_KNOCKED] = "Someone has already knocked",
		[game31s.GAME_OVER]          = "Game over",
	}
	return map[rc]
end

-- Shouldn't need to call this externally, unless you manually edit the cards
-- outside of these APIs
function game31s.check_for_31_in_hand(state)
	for player=1,state.player_count do
		local score = get_hand_score(state.player_hands[player])
		if score >= 31 then
			state.winners[#state.winners+1] = player
		end
	end
end

function game31s.new_game(player_count)
	local deck = cards.new_deck()
	cards.shuffle(deck)

	local player_hands = {}

	for i=1, player_count do
		player_hands[i] = {}
		for _=1, cards_per_hand do
			player_hands[i][#player_hands[i]+1] = table.remove(deck)
		end

	end


	local discard_pile = {}

	table.insert(discard_pile, table.remove(deck))

	local state = {
		player_count = player_count,
		deck = deck,
		discard_pile = discard_pile,
		player_hands = player_hands,
		player_turn = 1,

		-- this is where a card drawn from the deck is stored until the player
		-- chooses to either discard it, or swap it with one of the cards in their hand
		staging_area = nil,

		-- if the player picks up the discarded card and puts it back,
		-- that shouldn't count as a turn.
		drew_from_discard = false,

		-- when a player "knocks", this is set to player_count
		-- then it is decremented on each turn and the game is over once it reaches zero
		turns_to_gameover = nil,

		winners = {},
	}
	game31s.check_for_31_in_hand(state)
	return state
end

function game31s.print_state(state)
	if state == nil then
		io.write("state = nil\n")
		return
	end

	io.write("state {\n")
	io.write(string.format("    player_count = %d\n", state.player_count))
	if state.deck ~= nil then
		io.write(string.format("    deck.size    = %d\n", #state.deck))
	else
		io.write(string.format("    deck is nil\n"))
	end
	io.write(string.format("    player_hands = {\n"))
	for player,_ in pairs(state.player_hands) do
		io.write(string.format("     [%d] = {", player))
		for card_idx=1, #state.player_hands[player] do
			io.write(cards.card_to_string(state.player_hands[player][card_idx]))
			io.write(", ")
		end
		io.write("    }\n")
	end
	io.write("    }\n")
	io.write(string.format("    player_turn = %d\n", state.player_turn))
	io.write(string.format("    staging_area = %s\n", cards.card_to_string(state.staging_area)))

	io.write(string.format("    winners = {"))
	for _,winner in ipairs(state.winners) do
		io.write(string.format("%d, ", winner))
	end
	io.write(string.format("}\n"))

	io.write("}\n")
end

function table_slice(array, start_idx, end_idx)
	local dst_array = {}
	for i=start_idx,end_idx do
		if not(1 <= i and i <= #array) then
			goto next
		end
		table.insert(dst_array, array[i])
		::next::
	end
	return dst_array
end


function bool_to_byte(b)
	if b then return 1
	else return 0 end
end

function byte_to_bool(val)
	return (val ~= 0)
end

local function bytestr_to_nice_str(s)
	if s == nil then return "nil" end
	local nice_strs = {}
	for i=1,#s do
		table.insert(nice_strs, string.format("%02x", string.byte(s:sub(i,i))))
	end
	return table.concat(nice_strs, " ")
end

local function bytearray_to_nice_str(array)
	local nice_strs = {}
	for i=1, #array do
		table.insert(nice_strs, string.format("%02x", string.byte(array[i])))
	end
	return table.concat(nice_strs, " ")
end

local function serialize_byte_array(array)
	local output = {}
	output[#output+1] = string.char(#array)
	for i=1,#array do
		output[#output+1] = string.char(array[i])
	end
	return table.concat(output, "")
end

local function deserialize_byte_array(bytes)
	local array = {}
	local len = string.byte(table.remove(bytes, 1))
	for i=1,len do
		array[i] = string.byte(table.remove(bytes, 1))
	end
	return array
end
	
--
-- To prevent cheating, only the host will know all the cards.
-- The clients will only be sent what they need to know:
--    * their hand
--    * if another player draws a card into their staging area
--    * if another player discards from their hand or the staging area card
--    * a change in the discard pile
--    * if someone knocks?
--    * turns to game over?

function game31s.serialize_state_for_client(state, player_idx)
	local output = ""
	if state == nil then return output end
	output = output .. string.char(state.player_count)
	output = output .. string.char(state.player_turn)
	output = output .. bool_to_byte(state.drew_from_discard)
	output = output .. cards.serialize_card_array(state.player_hands[player_idx])
	output = output .. cards.serialize_card_array(table_slice(state.discard_pile, #state.discard_pile-1, #state.discard_pile))
	local staging_area_array = {}
	if state.staging_area ~= nil then
		if state.player_turn ~= player_idx and not state.drew_from_discard then
			table.insert(staging_area_array, cards.UNREVEALED_CARD)
		else
			table.insert(staging_area_array, state.staging_area)
		end
	end
	local staging_area_bytes = cards.serialize_card_array(staging_area_array)
	output = output .. staging_area_bytes

	output = output .. serialize_byte_array(state.winners)

	-- If the game is over, reveal all the hands
	if #state.winners > 0 then
		for player_hand_idx=1, state.player_count do
			if player_hand_idx == player_idx then
				goto next_player
			end
			output = output .. string.char(player_hand_idx)
			output = output .. cards.serialize_card_array(state.player_hands[player_hand_idx])
			::next_player::
		end
	end
	return output
end


function game31s.deserialize_client_state(player, bytes_str)
	local bytes = {}
	for i=1,#bytes_str do
		bytes[i] = bytes_str:sub(i,i)
	end
	local state = {}
	state.player_count = string.byte(table.remove(bytes, 1))
	state.player_turn = string.byte(table.remove(bytes, 1))
	state.drew_from_discard = byte_to_bool(table.remove(bytes,1))
	state.player_hands = {}
	state.player_hands[player]  = cards.deserialize_card_array(bytes)
	state.discard_pile = cards.deserialize_card_array(bytes)
	local staging_area_array = cards.deserialize_card_array(bytes)
	if #staging_area_array == 0 then
		state.staging_area = nil
	elseif #staging_area_array == 1 then
		state.staging_area = staging_area_array[1]
	else
		error(string.format("Unexpected staging_area len received %d", #staging_area_array))
	end

	state.winners = deserialize_byte_array(bytes)

	-- if #state.winners > 0 then
	while #bytes > 0 do
		local player_hand_idx = string.byte(table.remove(bytes,1))
		state.player_hands[player_hand_idx] = cards.deserialize_card_array(bytes)
	end

	return state
end

function game31s.draw_from_deck(state, player)
	if state.player_turn ~= player then
		return game31s.NOT_YOUR_TURN
	end

	if state.staging_area ~= nil then
		return game31s.STAGING_AREA_FULL
	end

	if #state.winners > 0 then
		return game31s.GAME_OVER
	end

	-- shouldn't happen, discard pile should be shuffled when the last card is drawn
	if #state.deck == 0 then
		error("Deck is empty")
	end

	state.staging_area = table.remove(state.deck)

	if #state.deck == 0 then
		print("Shuffling discard pile to refill deck")
		--local discard_pile_top = table.remove(state.discard_pile)
		state.deck = state.discard_pile
		state.discard_pile = {}
		cards.shuffle(state.deck)
	end

	return game31s.SUCCESS
end

function game31s.draw_from_discard(state, player)
	if state.player_turn ~= player then
		return game31s.NOT_YOUR_TURN
	end

	if state.staging_area ~= nil then
		return game31s.STAGING_AREA_FULL
	end

	if #state.winners > 0 then
		return game31s.GAME_OVER
	end

	-- shouldn't happen
	if #state.discard_pile == 0 then
		error("Discard pile is empty")
	end

	state.drew_from_discard = true
	state.staging_area = table.remove(state.discard_pile)

	return game31s.SUCCESS
end

local function get_card_val(card_val)
	local map = {
		[cards.ACE]   = 11,
		[2]           =  2,
		[3]           =  3,
		[4]           =  4,
		[5]           =  5,
		[6]           =  6,
		[7]           =  7,
		[8]           =  8,
		[9]           =  9,
		[10]          = 10,
		[cards.JACK]  = 10,
		[cards.QUEEN] = 10,
		[cards.KING]  = 10,
	}
	return map[card_val]
end

local function check_all_same_val(hand)
	local val = hand[1].val
	for _, card in ipairs(hand) do
		if val ~= card.val then
			return false
		end
	end
	return true
end

function get_hand_score(hand)
	local sums_per_suit = {}
	for _,suit in ipairs(cards.suits) do
		sums_per_suit[suit] = 0
	end
	for i=1,#hand do
		local card = hand[i]
		sums_per_suit[card.suit] = sums_per_suit[card.suit] + get_card_val(card.val)
	end

	local score = 0
	for _,val in pairs(sums_per_suit) do
		if val > score then
			score = val
		end
	end

	if check_all_same_val(hand) and score < score_of_all_same_val then
		score = score_of_all_same_val
	end

	return score
end

local function get_scores(state)
	local scores = {}
	for player=1, state.player_count do
		scores[player] = get_hand_score(state.player_hands[player])
	end
	return scores
end

local function get_max_score(scores)
	local max_score = nil
	for _, score in ipairs(scores) do
		if max_score == nil or score > max_score then
			max_score = score
		end
	end
	return max_score
end

local function ary_to_str(ary, fmt)
	local str = "{"
	for _, val in ipairs(ary) do
		str = str .. string.format(fmt, val) .. ", "
	end
	return str .. "}"
end

local function get_winner(state)
	local scores = get_scores(state)
	print("Scores are: " .. ary_to_str(scores, "%d"))
	local max_score = get_max_score(scores)

	state.winners = {}
	for player=1,state.player_count do
		if scores[player] == max_score then
			state.winners[#state.winners+1] = player
		end
	end
end

local function next_player(state)
	state.player_turn = ((state.player_turn-1 + 1) % state.player_count) + 1
	if state.turns_to_gameover == 0 then
		print("Turns to game over is zero, getting winners...")
		get_winner(state)
		print("Winners are: " .. ary_to_str(state.winners, "%d"))
	elseif state.turns_to_gameover ~= nil then
		state.turns_to_gameover = state.turns_to_gameover - 1
	end

end

function game31s.player_swap_card(state, player, hand_idx)
	if state.player_turn ~= player then
		return game31s.NOT_YOUR_TURN
	end

	if state.staging_area == nil then
		return game31s.STAGING_AREA_EMPTY
	end

	if #state.winners > 0 then
		return game31s.GAME_OVER
	end


	local discard_card = state.player_hands[player][hand_idx] 
	state.player_hands[player][hand_idx]  = state.staging_area
	state.staging_area = nil
	state.drew_from_discard = false
	table.insert(state.discard_pile, discard_card)

	-- TODO
	if get_hand_score(state.player_hands[player]) == 31 then
		state.winners = {player}
	end

	next_player(state)

	return game31s.SUCCESS
end

function game31s.player_discard_staged(state, player)
	if state.player_turn ~= player then
		return game31s.NOT_YOUR_TURN
	end

	if state.staging_area == nil then
		return game31s.STAGING_AREA_EMPTY
	end

	if #state.winners > 0 then
		return game31s.GAME_OVER
	end

	table.insert(state.discard_pile, state.staging_area)
	state.staging_area = nil
	if not state.drew_from_discard then
		next_player(state)
	end
	state.drew_from_discard = false

	return game31s.SUCCESS
end

function game31s.player_knock(state, player)
	if state.player_turn ~= player then
		return game31s.NOT_YOUR_TURN
	end

	if state.turns_to_gameover ~= nil then
		return game31s.SOMEONE_ALREADY_KNOCKED
	end

	if #state.winners > 0 then
		return game31s.GAME_OVER
	end

	state.turns_to_gameover = state.player_count - 1
	next_player(state)

	return game31s.SUCCESS
end

return game31s
game31s_draw = {}

local game31s_core = require("games/31s/31s_core")
local cards_draw = require("libs/cards/cards_draw")
local cards = require("libs/cards/cards")
local alex_c_api = require("alex_c_api")

local cards_per_hand = 3

game31s_draw.HAND_1       = 1
game31s_draw.HAND_2       = 2
game31s_draw.HAND_3       = 3
game31s_draw.DECK         = 4
game31s_draw.DISCARD      = 5
game31s_draw.STAGING_AREA = 6

local canvas_width = nil
local canvas_height = nil

--local card_width     =  70
--local card_height    = 125
local card_width     =  70
local card_height    = 110

local card_font_size =  32
local card_padding   =  20
local card_edge_padding = 3

local hand_width   = nil
local hand_y_start = nil
local hand_y_end   = nil
local hand_x_start = nil
local hand_x_end   = nil

-- For the current player-- this one can be clicked
local staging_area_y_start = nil
local staging_area_x_start = nil

local deck_discard_y = nil
local deck_discard_x_start = nil

function get_staging_area_pos(pos)
	if pos == 1 then
		return { y = staging_area_y_start,
		         x = staging_area_x_start,
		         angle = 0 }
	elseif pos == 2 then
		return { y = math.floor(canvas_height/2 - card_width/2),
		         x = math.floor(canvas_width/4 + card_height/2),
		         angle = 90 }
	elseif pos == 3 then
		return { y = math.floor(canvas_height/2 + card_height/2 - card_padding),
		         x = deck_discard_x_start - card_padding,
		         angle = 180 }
	elseif pos == 4 then
		return { y = math.floor(canvas_height/2 + card_width/2),
		         x = math.floor(canvas_width/2 + card_padding),
		         angle = 270 }
	end
end

function game31s_draw.init_ui(canvas_width_arg, canvas_height_arg)
	canvas_width  = canvas_width_arg
	canvas_height = canvas_height_arg

	hand_y_start = canvas_height - card_height - card_edge_padding
	hand_y_end   = hand_y_start + card_height
	hand_width = cards_per_hand*card_width + (cards_per_hand-1)*card_padding
	hand_x_start = math.floor((canvas_width - hand_width)/2)
	hand_x_end   = hand_x_start + hand_width
	deck_discard_y = math.floor((canvas_height - card_height)/2)
	deck_discard_x_start = math.floor((canvas_width  - 2*card_width + card_padding)/2)

	staging_area_y_start = math.floor(canvas_height/2 - card_height/2 + card_padding)
	staging_area_x_start = deck_discard_x_start - card_padding - card_width
end



local function draw_revealed_hand(state, player, position, highlight)
	print(string.format("Drawing player %s hand", player))
	local y_start
	local x_start
	local dy
	local dx
	local width
	local height
	local angle

	width = card_width
	height = card_height
	angle = 0
	dy = 0
	dx = (card_width + card_padding)
	if position == 1 then
		y_start = hand_y_start
		x_start = hand_x_start
	elseif position == 2 then
		y_start = math.floor((canvas_height - hand_width)/2)
		x_start = card_edge_padding + card_height
		dy      = card_width + card_padding
		dx      = 0
		width = card_width
		height = card_height
		angle = 90
	elseif position == 3 then
		y_start = card_edge_padding
		x_start = hand_x_start
	elseif position == 4 then
		y_start = canvas_height - math.floor((canvas_height - hand_width)/2)
		x_start = canvas_height - card_edge_padding - card_height
		dy      = -(card_width + card_padding)
		dx      = 0
		width   = card_width
		height  = card_height
		angle   = 270

	else
		error(string.format("Unhandled position %q", position))
		return
	end

	local hand = state.player_hands[player]
	if hand == nil then
		error("hand is nil")
		return
	end

	if #hand ~= cards_per_hand then
		error(string.format("unexpected hand len: %d", #hand))
		return
	end


	for i=1, cards_per_hand do
		cards_draw.draw_card(state.player_hands[player][i],
		                     y_start + (i-1)*dy, x_start + (i-1)*dx,
		                     width, height,
		                     card_font_size, highlight, angle)
	end
end

local function draw_hand_facedown(pos)
	local y_start, x_start
	local angle
	local dy, dx
	local width  = card_width
	local height = card_height
	if pos == 2 then
		y_start = math.floor((canvas_height - hand_width)/2)
		x_start = card_edge_padding + card_height
		dy = card_padding + card_width
		dx = 0
		angle = 90
	elseif pos == 3 then
		y_start = card_edge_padding + card_height
		x_start = hand_x_start + card_width
		dy = 0
		dx = card_padding + card_width
		angle = 180
	elseif pos == 4 then
		y_start = canvas_height - math.floor((canvas_height - hand_width)/2)
		x_start = canvas_height - card_edge_padding - card_height
		dy = -(card_width + card_padding)
		dx = 0
		angle = 270
	end

	for i=1, cards_per_hand do
		cards_draw.draw_facedown_card(y_start + (i-1)*dy, x_start + (i-1)*dx, width, height, false, angle)
	end
end

local function draw_deck_and_discard(state, highlight)

	cards_draw.draw_facedown_card(deck_discard_y, deck_discard_x_start, card_width, card_height, highlight)
	if state ~= nil and #state.discard_pile > 0 then
		cards_draw.draw_card(state.discard_pile[#state.discard_pile],
		                     deck_discard_y, deck_discard_x_start + card_width + card_padding,
		                     card_width, card_height, card_font_size, highlight)
	end
end

local function draw_staging_area(state, player, pos_idx, highlight)
	if state.staging_area ~= nil then
		local card = state.staging_area
		if state.player_turn ~= player and not state.drew_from_discard then
			card = cards.UNREVEALED_CARD
		end
		print("staging area pos " .. pos_idx)
		local pos = get_staging_area_pos(pos_idx)
		print(string.format("Drawing staging area idx=%d, pos{y=%d, x=%d}", pos_idx, pos.y, pos.x))
		cards_draw.draw_card(card,
		                     pos.y, pos.x,
		                     card_width, card_height, card_font_size, highlight, pos.angle)
	end
end

local function get_starting_pos_other_player(player_count)
	if player_count == 2 then
		return 3
	else
		return 2
	end
end

local function player_idx_to_board_pos(this_player, player_idx, player_count)
	if this_player == player_idx then
		return 1
	end

	if player_count == 2 then
		return 3
	end

	local pos_counter = 2
	local player_idx_to_pos_map = {}
	for i=1,player_count do
		if i == this_player then goto next_player end
		player_idx_to_pos_map[i] = pos_counter
		pos_counter = pos_counter + 1
		::next_player::
	end
	return player_idx_to_pos_map[player_idx]
end

function game31s_draw.draw(state, player)

	alex_c_api.draw_clear()

	local highlight_hand_and_staging = false
	local highlight_draw_and_discard = false

	if state ~= nil and #state.winners == 0 and player == state.player_turn then
		highlight_hand_and_staging = (state.staging_area ~= nil)
		highlight_draw_and_discard = (state.staging_area == nil)
	end

	draw_deck_and_discard(state, highlight_draw_and_discard)

	if state == nil then
		alex_c_api.draw_refresh()
		return
	end

	draw_revealed_hand(state, player,  1, highlight_hand_and_staging)

	if #state.winners > 0 then
		for other_player=1, state.player_count do
			if other_player == player then
				goto next_player
			end
			local pos = player_idx_to_board_pos(player, other_player, state.player_count)
			draw_revealed_hand(state, other_player,  pos, false)
			pos = pos + 1
			::next_player::
		end
	else
		local pos = get_starting_pos_other_player(state.player_count)
		for _=1,state.player_count-1 do
			draw_hand_facedown(pos)
			pos = pos + 1
		end
	end

	local staging_area_pos = player_idx_to_board_pos(player, state.player_turn, state.player_count)
	draw_staging_area(state, player, staging_area_pos, highlight_hand_and_staging)

	alex_c_api.draw_refresh()
end

function game31s_draw.coords_to_ui_elem(y, x)
	if hand_y_start <= y and y <= hand_y_end and
	   hand_x_start <= x and x <= hand_x_end then
		local card_idx = 1 + math.floor( (x - hand_x_start) * cards_per_hand / hand_width )
		local map = {
			[1] = game31s_draw.HAND_1,
			[2] = game31s_draw.HAND_2,
			[3] = game31s_draw.HAND_3,
		}
		return map[card_idx]
	elseif staging_area_y_start <= y and y <= staging_area_y_start + card_height and
	       staging_area_x_start <= x and x <= staging_area_x_start + card_width then
		return game31s_draw.STAGING_AREA
	elseif deck_discard_y       <= y and y <= deck_discard_y + card_height and
	       deck_discard_x_start <= x and x <= deck_discard_x_start + 2*card_width + card_padding then
		local fact = (x - deck_discard_x_start) / (2*card_width + card_padding)
		if fact < 0.5 then
			return game31s_draw.DECK
		else
			return game31s_draw.DISCARD
		end
	else
		return nil
	end
end

return game31s_draw

local wait_for_players = require("libs/multiplayer/wait_for_players")
local game31s_draw = require("games/31s/31s_draw")
local game31s      = require("games/31s/31s_core")

local alex_c_api   = require("alex_c_api")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local utils = require("libs/utils")

local width = 480
local height = 480

local is_client = false
local players_joined = 1
local g_session_id = nil
local state = nil

-- This is the initial config for the host.
-- Always start off as the host, for now?
-- But someone else says that they're the host, believe them..?
local player = 1

-- player number to src
local players = {
	[1] = "You",
}
local player_name_to_idx = {
}

local BTN_ID_KNOCK = "knock"

local POPUP_ID_GAME_OVER = "game_over"
local POPUP_GAME_OVER_BTNS = {
	"New Game",
}

-- TODO:
--      * draw text near a player who has knocked
--      * highlight player whose move it is
--  * Show your IP address somewhere, or at least let you enter a custom name
--
--  Bugs:
--  * right now if a player joins during a game, it shows the popup message for "waiting for players" and interrupts
--    the game in progress, and prevents it from going forward.
--    This also happens simply if someone refreshes their browser
--     * solution: if someone leaves, ideally we'd have the option to either kick them or wait?
--       and if someone re-joins, they could take their place?
--     * but don't show a popup until it's the missing person's turn?

function init_ui()
	game31s_draw.init_ui(width, height)
	alex_c_api.create_btn(BTN_ID_KNOCK, "Knock", 1)
end


function draw_board()
	game31s_draw.draw(state, player)
	--game31s.print_state(state)
end

function check_for_winners()
	if state == nil then
		return
	end

	local win_msg = nil

	if #state.winners == state.player_count then
		win_msg = string.format("Tie game. All players have the same score.")
	elseif #state.winners == 1 then
		win_msg = string.format("Player %d wins.", state.winners[1])
	else
		win_msg = string.format("Tie between these players: ")
		for _,winner in ipairs(state.winners) do
			win_msg = win_msg .. string.format("%d ", winner)
		end
	end

	if #state.winners > 0 then
		show_buttons_popup.show_popup(POPUP_ID_GAME_OVER,
		                              "Game over",
		                              "Game over!\n" .. win_msg,
		                              POPUP_GAME_OVER_BTNS
		                              );
	end
end

function handle_user_clicked(y,x)
	local ui_elem = game31s_draw.coords_to_ui_elem(y, x)
	if ui_elem == nil then
		return
	end
	local rc = game31s.SUCCESS
	print(string.format("handle_user_clicked, ui_elem = %d, y = %d, x = %d", ui_elem, y, x))
	if ui_elem == game31s_draw.DECK then
		if not is_client then
			rc = game31s.draw_from_deck(state, player)
		else
			alex_c_api.send_message("all", string.format("%s:%d,%d", game31s.MSG_DRAW, player, 1))
		end
	elseif ui_elem == game31s_draw.DISCARD then
		if not is_client then
			rc = game31s.draw_from_discard(state, player)
		else
			alex_c_api.send_message("all", string.format("%s:%d,%d", game31s.MSG_DRAW, player, 2))
		end
	elseif ui_elem == game31s_draw.STAGING_AREA then
		if not is_client then
			rc = game31s.player_discard_staged(state, player)
		else
			alex_c_api.send_message("all", string.format("%s:%d,%d", game31s.MSG_DISCARD, player, 0))
		end
	elseif ui_elem == game31s_draw.HAND_1 or
	       ui_elem == game31s_draw.HAND_2 or
	       ui_elem == game31s_draw.HAND_3 then
		local card_idx = ui_elem
		if not is_client then
			rc = game31s.player_swap_card(state, player, card_idx)
		else
			alex_c_api.send_message("all", string.format("%s:%d,%d", game31s.MSG_DISCARD, player, card_idx))
		end
	end
	
	if rc ~= game31s.SUCCESS then
		alex_c_api.set_status_err(game31s.err_code_to_str(rc))
	end

	draw_board()
	check_for_winners()
	send_state_updates_if_host()
	game31s.print_state(state)
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_KNOCK then
		if not is_client then
			local rc = game31s.player_knock(state, player)
			if rc == game31s.SUCCESS then
				send_state_updates_if_host()
				draw_board()
			else
				alex_c_api.set_status_err(game31s.err_code_to_str(rc))
			end
		else
			alex_c_api.send_message("all", string.format("%s:%d", game31s.MSG_KNOCK, player))
		end
	else
		error("Unexpected button id " .. btn_id)
	end
end

local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false
	new_game(#players)
	send_state_updates_if_host()
	draw_board()
	game31s.print_state(state)

end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
end

function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end
end


function send_state_updates_if_host()
	if is_client then
		return
	end

	if state == nil then
		return
	end

	for dst_player=1,state.player_count do
		if dst_player == player then
			goto next_player
		end
		local state_msg = "state:" .. game31s.serialize_state_for_client(state, dst_player)
		alex_c_api.send_message(players[dst_player], state_msg)
		print("Sending state msg: " .. state_msg)
		::next_player::
	end
end

function send_err(rc, other_player)
	if rc ~= game31s.SUCCESS then
		alex_c_api.send_message("all", string.format("err:%s", game31s.err_code_to_str(rc)))
	end
end

function handle_msg_received(src, msg)
	print("handle_msg_received (from src:" .. src .. "): " .. msg);

	local handled = wait_for_players.handle_msg_received(src, msg)
	if handled then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()


	if header == "state" then
		if is_client then
			state = game31s.deserialize_client_state(player, payload)
			print("Recvd state:")
			game31s.print_state(state)
		else
			print("Unexpected state update recvd: we are the host")
		end
	elseif header == game31s.MSG_DRAW then
		if state == nil then
			print("Can not process player move until game has started")
			return
		end
		if is_client then
			print("Unexpected game msg recvd by client")
			return
		end
		local m2 = payload:gmatch("(%d+),(%d+)")
		local other_player, draw_src
		other_player, draw_src = m2()
		other_player = tonumber(other_player)
		draw_src     = tonumber(draw_src)
		if other_player ~= player_name_to_idx[src] then
			local err_msg = (string.format("Received msg to move player %d from " ..
			                               "\"%s\" who is expected to be player %s",
			                               other_player, src, player_name_to_idx[src]))
			alex_c_api.set_status_err(err_msg)
			return
		end
		if draw_src == 1 then
			local rc = game31s.draw_from_deck(state, other_player)
			send_err(rc, other_player)
		elseif draw_src == 2 then
			local rc = game31s.draw_from_discard(state, other_player)
			send_err(rc, other_player)
		end
	elseif header == game31s.MSG_DISCARD then
		if state == nil then
			print("Can not process player move until game has started")
			return
		end
		if is_client then
			print("Unexpected game msg recvd by client")
			return
		end
		local m2 = payload:gmatch("(%d+),(%d+)")
		local other_player, discard_src
		other_player, discard_src = m2()
		other_player = tonumber(other_player)
		discard_src  = tonumber(discard_src)

		if other_player ~= player_name_to_idx[src] then
			local err_msg = (string.format("Received msg to move player %d from " ..
			                               "\"%s\" who is expected to be player %s",
			                               other_player, src, player_name_to_idx[src]))
			alex_c_api.set_status_err(err_msg)
			return
		end


		if discard_src == 0 then
			local rc = game31s.player_discard_staged(state, other_player)
			send_err(rc, other_player)
		else
			local rc = game31s.player_swap_card(state, other_player, discard_src)
			send_err(rc, other_player)
		end
	elseif header == "err" then
		alex_c_api.set_status_err(payload)
	elseif header == game31s.MSG_KNOCK then
		if state == nil then
			print("Can not process player move until game has started")
			return
		end

		local m2 = payload:gmatch("(%d+)")
		local other_player
		other_player = m2()
		other_player = tonumber(other_player)

		if other_player ~= player_name_to_idx[src] then
			local err_msg = (string.format("Received msg to move player %d from " ..
			                               "\"%s\" who is expected to be player %s",
			                               other_player, src, player_name_to_idx[src]))
			alex_c_api.set_status_err(err_msg)
			return
		end

		if is_client then
			print("Unexpected game msg recvd by client")
		else
			local rc = game31s.player_knock(state, other_player)
			send_err(rc, other_player)
		end
	else
		print(string.format("Unhandled message header \"%s\" from \"%s\"", header, msg))
	end
	send_state_updates_if_host()
	draw_board()
	check_for_winners()
	if not is_client then
		game31s.print_state(state)
		-- only printing this to generate a preview...
		print(string.format("serialized state: %s", utils.binstr_to_hr_str(game31s.serialize_state_for_client(state, player))))
	end
end

function new_game(player_count)
	print(string.format("Starting game with %d players", #players))
	for player_idx,_ in ipairs(players) do
		print(string.format("   %d: %s", player_idx, players[player_idx]))
	end
	state = game31s.new_game(player_count)
	game31s.print_state(state)
	check_for_winners()
end


function start_game(session_id, serialized_state)
	if serialized_state then
		g_session_id = session_id
		state = game31s.deserialize_client_state(player, serialized_state)
	end
	wait_for_players.init(players, player, start_host_game, start_client_game)
	print("... waiting ... ")

	init_ui()
end
-- This is the "main" file of the example game "api_demo".
-- It is intended to show some examples of how the APIs work, including:
--     * drawing graphics,
--     * drawing lines, rectangles,
--     * setting a timer to update the game state and redraw 60 (`FPS`) times per second
--     * receiving keyboard ("key") events,
--     * receiving mouse events (mouse button pressed ("down"), released ("up"), move),
--     * receiving touch events (finger(s) pressed), only available on mobile.

-- These are other Lua files defined in the rest of the game bundle.
-- If this line is failing then either you removed them or renamed them in the zip you uploaded,
-- or I forgot to include the right path in Lua `package.path`.
-- Note that in most of the other games I wrote, I instead referenced the global path (something like "games/whatever_game/game_core")
-- and didn't bother adding the game's local directory to `package.path`. 
-- For uploaded games, I made an exception and added it.
local core = require("game_core") -- game_core.lua
local draw = require("game_draw") -- game_draw.lua

-- This is the API that I defined, defined in `lua_api.c`.
local alex_c_api = require("alex_c_api")


print(
"Hello, world! You should see this message in the developer tools console " ..
"if you\'re using the web version.")

-- The dots are simply to concatentate strings (instead of "+" like in most
-- languages). They could be omitted here, I just wanted to break
-- this long string across multiple lines.
print(string.format("If you're new to Lua, this is a way to achieve printf " ..
                    "like behaviour: %d %s %q",
                    123, "test", nil))

-- TODO these should come from an API
local board_height = 480
local board_width  = 480


-- This is calling into the "game_core.lua" file to create
-- a new table with the game's initial state.
local state = core.new_state(board_height, board_width)

local FPS = 60
local MS_PER_FRAME = math.floor(1000/FPS)


-- This function is called initially, and then many times repeatedly if `alex_c_api.set_timer_update_ms(time_ms)`
-- is called, to update state.
-- TODO It really should be renamed from "draw_board" to "update" or something.
-- 
-- TODO I think it would also be cleaner to move away from global symbols like this, and instead register the important methods
-- in something like `alex_c_api.init({update=draw_board})`, and register the others (key, touch, mousemove) when I enable those events.
function draw_board()
	local dt_ms = MS_PER_FRAME


	if state.mouse_down or state.active_touch ~= nil then
		core.set_user_input_pos(state, {y=state.user_input_pos_y, x=state.user_input_pos_x})
	end

	-- Lua doesn't have an increment operator. This is not ideal, but whenever you encounter
	-- minor annoyances like this, try to remember that the entire interpreter compiles to ~400 kB of WASM and
	-- is wonderfully nice to integrate with C.
	-- And rather than apply a patch that does have an increment operator, I'd like be consistent with standard
	-- Lua (for now, at least).
	state.frame_idx = state.frame_idx + 1

	core.update_ball_pos(state, dt_ms)

	draw.draw(state)
end

-- Lua table (like a dictionary/hashmap) to track if a key is down
-- or not.
-- This way, when a user presses "up", we can check if they're also
-- pressing "left", and then move them diagonally.
local keys_pressed = {}

-- Lua table (like a dictionary/hashmap) to track if keys are handled or not.
-- This step is somewhat optional, I'm doing this so that we can tell the browser
-- which keys we don't handle, so it can choose to handle them
-- (e.g. not call evt.preventDefault() for Ctrl L (jump to address bar),
-- but it should call evt.preventDefault() for the arrow keys/WASD, so that
-- the arrow keys don't scroll on the page (as they normally would).
-- Instead, arrow keys move the player around.
local keys_handled = {
	['ArrowLeft']  = true,
	['ArrowRight'] = true,
	['ArrowUp']    = true,
	['ArrowDown']  = true,

	['KeyW']  = true,
	['KeyA']  = true,
	['KeyS']  = true,
	['KeyD']  = true,
}

function handle_key_evt(evt_id, key_code)
	print(string.format("handle_key_evt(evt=%s, code=%s)", evt_id, key_code))

	if not keys_handled[key_code] then
		local msg = string.format("key %s not handled", key_code)
		alex_c_api.set_status_msg(msg)
		print(msg)
		return false
	end

	if evt_id == 'keydown' then
		keys_pressed[key_code] = true
	elseif evt_id == 'keyup' then
		keys_pressed[key_code] = false
	else
		error(string.format("unhandled evt_id=%s", evt_id))
	end

	local x_vec = 0
	local y_vec = 0

	if keys_pressed['ArrowLeft']  or keys_pressed['KeyA'] then x_vec = x_vec - 1 end
	if keys_pressed['ArrowRight'] or keys_pressed['KeyD'] then x_vec = x_vec + 1 end
	if keys_pressed['ArrowUp']    or keys_pressed['KeyW'] then y_vec = y_vec - 1 end
	if keys_pressed['ArrowDown']  or keys_pressed['KeyS'] then y_vec = y_vec + 1 end

	local vec = nil
	if x_vec ~= 0 or y_vec ~= 0 then
		vec = { y = y_vec, x = x_vec }
	end

	core.set_user_input_vec(state, vec)
	return true
end


function handle_mouse_evt(evt_id, pos_y, pos_x)
	print(string.format("handle_mouse_evt(evt_id=%d, pos_y=%d, pos_x=%d)", evt_id, pos_y, pos_x))
	if evt_id == alex_c_api.MOUSE_EVT_DOWN then
		state.mouse_down = true
		state.user_input_pos_y = pos_y
		state.user_input_pos_x = pos_x
		--core.set_user_input_pos(state, {y=pos_y, x=pos_x})
	elseif evt_id == alex_c_api.MOUSE_EVT_UP then
		state.mouse_down = false
		core.set_user_input_pos(state, nil)
	elseif evt_id == alex_c_api.MOUSE_EVT_LEAVE then
		-- not handled, but including it here as an example 
	end
end

function handle_mousemove(pos_y, pos_x)
	if state.mouse_down then
		state.user_input_pos_y = pos_y
		state.user_input_pos_x = pos_x
		--core.set_user_input_pos(state, {y=pos_y, x=pos_x})
	end
end

function handle_touch_evt(evt_id, touches)
	print(string.format("handle_touch_evt(evt_id=%s, touches[%d])", evt_id, #touches))
	for _, touch in ipairs(touches) do
		if evt_id == 'touchstart' and state.active_touch == nil then
			state.active_touch = touch.id
			state.user_input_pos_y = touch.y
			state.user_input_pos_x = touch.x
		elseif evt_id == 'touchmove' and touch.id == state.active_touch then
			state.user_input_pos_y = touch.y
			state.user_input_pos_x = touch.x
		elseif evt_id == 'touchend' or evt_id == 'touchcancel' and touch.id == state.active_touch then
			state.active_touch = nil
			core.set_user_input_pos(state, nil)
		end
	end
		
end

-- This function is called when the game is started.
-- It is better to put game init stuff here than at the top level,
-- so that the game code could be loaded only once, but multiple game states
-- could be rendered (e.g. history browser).
--
-- The session_id_arg and state_serialized should be set if the game
-- is being loaded from the history browser (for the player to play, or
-- to render a preview), or the state is loaded from the URL parameter.
-- session_id_arg is only used when storing state with the
-- `alex_c_api.save_state` API, it indicates whether the state of a previous
-- game should be updated, or if a new saved state session should be created.
function start_game(session_id_arg, state_serialized)
	draw.init(board_height, board_width)
	
	-- This causes draw_board to be called every `MS_PER_FRAME` ms.
	alex_c_api.set_timer_update_ms(MS_PER_FRAME)
	
	-- This causes handle_key_evt to get key presses.
	alex_c_api.enable_evt("key")
	
	-- This causes handle_mouse_evt to get events on mouse up/down.
	alex_c_api.enable_evt("mouse_updown")
	
	-- This causes handle_mousemove to get events on mouse move.
	alex_c_api.enable_evt("mouse_move")
	
	-- This causes handle_touch_evt to get events on touchscreen inputs.
	alex_c_api.enable_evt("touch")
end
local core = {}

local BALL_RADIUS = 20

local MAX_DIM_VEL = 200

local USER_INPUT_SPEED = 300

function core.new_state(board_width, board_height)
	local state = {
		frame_idx = 0,

		board_height = board_height,
		board_width  = board_width,

		ball_radius = BALL_RADIUS,
		ball_pos_y = BALL_RADIUS,
		ball_pos_x = BALL_RADIUS,
		ball_vel_y = 200,
		ball_vel_x = 80,

		user_input_vec = nil,

		mouse_down = false,
		active_touch = nil,
		user_input_pos_y = nil,
		user_input_pos_x = nil,
	}
	return state
end

local function clip(min_val, val, max_val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end

function core.update_ball_pos(state, dt_ms)
	if state.user_input_vec ~= nil then
		print(string.format("Adjusting ball pos from user input {y=%f, x=%f}", state.user_input_vec.y, state.user_input_vec.x))
		state.ball_vel_x = state.ball_vel_x + state.user_input_vec.x * USER_INPUT_SPEED / 1000 * dt_ms
		state.ball_vel_y = state.ball_vel_y + state.user_input_vec.y * USER_INPUT_SPEED / 1000 * dt_ms
	end

	state.ball_vel_x = clip(-MAX_DIM_VEL, state.ball_vel_x, MAX_DIM_VEL)
	state.ball_vel_y = clip(-MAX_DIM_VEL, state.ball_vel_y, MAX_DIM_VEL)

	state.ball_pos_y = state.ball_pos_y + state.ball_vel_y * dt_ms/1000
	state.ball_pos_x = state.ball_pos_x + state.ball_vel_x * dt_ms/1000

	if state.ball_pos_y < state.ball_radius or state.ball_pos_y + state.ball_radius >= state.board_height then
		state.ball_vel_y = -state.ball_vel_y
	end

	if state.ball_pos_x < state.ball_radius or state.ball_pos_x + state.ball_radius >= state.board_width then
		state.ball_vel_x = -state.ball_vel_x
	end
end

local function get_vec_towards_pt(state, pt)
	if pt == nil then return nil end
	local dy = pt.y - state.ball_pos_y
	local dx = pt.x - state.ball_pos_x

	if dy == 0 and dx == 0 then return nil end

	local mag = math.sqrt(dy*dy + dx*dx)

	dy = dy / mag
	dx = dx / mag

	return { y = dy, x = dx }
end

function core.set_user_input_vec(state, vec)
	state.user_input_vec = vec
end

function core.set_user_input_pos(state, pos)
	local vec = get_vec_towards_pt(state, pos)
	core.set_user_input_vec(state, vec)
end

return core
local draw = {}

local alex_c_api = require("alex_c_api")

-- Helper library to draw shapes from the base APIs defined in alex_c_api
local draw_more = require("libs/draw/draw_shapes")

local g_board_width
local g_board_height

local BORDER_COLOUR = '#8888ff88'
local BORDER_THICKNESS = 3

function draw.init(board_width, board_height)
	g_board_width  = board_width
	g_board_height = board_height
end

local function in_range(min_val, val, max_val)
	return min_val <= val and val <= max_val
end


function draw.draw(state)
	-- This clears anything on the screen from previous `draw_board` calls.
	alex_c_api.draw_clear()


	-- Draw a border around the screen to show where the ball will bounce
	local padding = 3
	local outline_pt1 = { y = padding, x = padding }
	local outline_pt2 = { y = g_board_height - padding, x = g_board_width - padding }
	draw_more.draw_rect_outline(BORDER_COLOUR, BORDER_THICKNESS,
	                            outline_pt1.y, outline_pt1.x,
	                            outline_pt2.y, outline_pt2.x)
	-- draw_more.draw_rect_outline(...) is a helper function to do this (draw 4 lines in a rectangle):
	--[[
	alex_c_api.draw_line(BORDER_COLOUR, BORDER_THICKNESS,
	                     0, 0,
	                     0, g_board_width)
	alex_c_api.draw_line(BORDER_COLOUR, BORDER_THICKNESS,
	                     0,              g_board_width,
	                     g_board_height, g_board_width)
	alex_c_api.draw_line(BORDER_COLOUR, BORDER_THICKNESS,
	                     g_board_height, g_board_width,
	                     g_board_height, 0)
	alex_c_api.draw_line(BORDER_COLOUR, BORDER_THICKNESS,
	                     g_board_height, 0,
	                     0             , 0)
	--]]

	local msg = string.format("time: %s, frame: %5d", alex_c_api.get_time_of_day(), state.frame_idx)
	local text_color = '#000000'
	local text_size = 18

	local padding = 5

	local y_pos = text_size + padding
	local x_pos = padding

	-- Draw text on the screen
	alex_c_api.draw_text(msg, text_color,
	                     y_pos, x_pos,
	                     text_size,
	                     alex_c_api.TEXT_ALIGN_LEFT)

	alex_c_api.draw_text('Hello, world!', '#ff0000',
	                     y_pos + padding + text_size, x_pos,
	                     text_size,
	                     alex_c_api.TEXT_ALIGN_LEFT)

	local square_size  = 40
	local squares_per_row = math.ceil(g_board_width  / square_size)
	local squares_per_col = math.ceil(g_board_height / square_size)
	--[[
	local square_y_pos = math.floor(state.ball_pos_y/square_size)*square_size
	local square_x_pos = math.floor(state.ball_pos_x/square_size)*square_size

	local square_color
	if (square_y_pos + square_x_pos * squares_per_row) % squares_per_row == 0 then
		square_color = '#ffffff88'
	else
		square_color = '#00000088'
	end

	alex_c_api.draw_rect(square_color,
	                     square_y_pos, square_x_pos,
	                     square_y_pos + square_size, square_x_pos + square_size)
	--]]
	for square_y_idx=0,squares_per_col-1 do
		for square_x_idx=0,squares_per_row-1 do
			local square_y_pos1 = square_y_idx * square_size
			local square_x_pos1 = square_x_idx * square_size
			local square_y_pos2 = (square_y_idx+1) * square_size
			local square_x_pos2 = (square_x_idx+1) * square_size

			local ball_in_square = (in_range(0, (math.floor(state.ball_pos_y/square_size + 0.5) - square_y_idx), 1) and
			                        in_range(0, (math.floor(state.ball_pos_x/square_size + 0.5) - square_x_idx), 1))
			local square_is_white = ((square_y_idx + square_x_idx * (squares_per_row+1)) % 2 == 0)

			local square_color
			if square_is_white then
				if ball_in_square then square_color = '#ffffff'
				else square_color = '#ffffff33' end
			else
				if ball_in_square then square_color = '#000000'
				else square_color = '#00000033' end
			end
			
			alex_c_api.draw_rect(square_color,
			                     square_y_pos1, square_x_pos1,
			                     square_y_pos2, square_x_pos2)
		end
	end
	                     
	local circle_color  = '#aaaacc88'
	local circle_outline = '#0000ff'
	alex_c_api.draw_circle(circle_color, circle_outline,
	                       state.ball_pos_y, state.ball_pos_x, state.ball_radius)

	-- TODO I need to implement the ability to upload custom graphics
	-- For now this API uses an ID that is hardcoded in a hashmap mapping this to
	-- a graphic file.
	alex_c_api.draw_graphic('chess_rook_black',
	                        state.ball_pos_y, state.ball_pos_x,
	                        2*state.ball_radius, 2*state.ball_radius,
	                        { angle_degrees = state.frame_idx / 60 * 90, })

	-- Draw a red line in the direction of the desired user position
	-- if they are pressing keys, clicking, or touching the screen.
	if state.user_input_vec ~= nil then
		local angle = math.atan(state.user_input_vec.y, state.user_input_vec.x)
		alex_c_api.draw_line('#ff0000', 4,
		                     state.ball_pos_y, state.ball_pos_x,
		                     state.ball_pos_y + 2*state.ball_radius*math.sin(angle), state.ball_pos_x + 2*state.ball_radius*math.cos(angle))
	end

	-- Show text indicating user input to help debug, also
	-- explain to user how they can provide input to move the ball.
	if state.mouse_down then
		alex_c_api.draw_text(string.format('Mouse pos: {y=%3.0f, x=%3.0f}', state.user_input_pos_y, state.user_input_pos_x), text_color,
		                     g_board_height - padding, padding,
		                     text_size, alex_c_api.TEXT_ALIGN_LEFT)
	elseif state.active_touch ~= nil then
		alex_c_api.draw_text(string.format('Touch pos: {y=%3.0f, x=%3.0f}', state.user_input_pos_y, state.user_input_pos_x), text_color,
		                     g_board_height - padding, padding,
		                     text_size, alex_c_api.TEXT_ALIGN_LEFT)
	else
		-- Admittedly I don't have a multi line draw_text function yet
		alex_c_api.draw_text('Press arrow keys, WASD, or mouse/touch', text_color,
		                     g_board_height - 2*padding - text_size, padding,
		                     text_size, alex_c_api.TEXT_ALIGN_LEFT)
		alex_c_api.draw_text('to move ball', text_color,
		                     g_board_height - padding, padding,
		                     text_size, alex_c_api.TEXT_ALIGN_LEFT)
	end

	-- On the web version, this does nothing.
	-- On other implementations, this is needed to cause the previous draw APIs to take effect.
	alex_c_api.draw_refresh()
end

return draw
-- Game:   Backgammon
-- author: Alex Barry (github.com/alexbarry)
local core = {}

local utils = require("libs/utils")
local dice = require("libs/dice/dice")
local combinations = require("libs/combinations")


--[[
-- Board:
--
--    1 1 1
--    2 1 0 9 8 7    6 5 4 3 2 1
--    b - - - w - || b - - - - b
--    b - - - w - || b - - - - b  <-- (black start)
--    b - - - w - || b - - - - -
--    b - - - - - || b - - - - -
--    b - - - - - || b - - - - -
--                ||
--    w - - - - - || w - - - - -
--    w - - - - - || w - - - - -
--    w - - - b - || w - - - - -
--    w - - - b - || w - - - - w  <-- (white start)
--    w - - - b - || w - - - - w
--    1 1 1 1 1 1    1 2 2 2 2 2
--    3 4 5 6 7 8    9 0 1 2 3 4
--
--]]

core.BACKGAMMON_ROWS =  2
core.BACKGAMMON_COLS = 12


core.NUM_DICE = 2 -- 2 dice
core.DICE_MAX = 6 -- 6 sided dice

core.PLAYER_BLACK = 1
core.PLAYER_WHITE = 2
core.NUM_PLAYERS  = 2

-- top right of the board, where BLACK starts
core.BOARD_IDX_START = 1

-- bottom right of the board, where WHITE starts
core.BOARD_IDX_END   = core.BACKGAMMON_COLS*2

core.SUCCESS            = 0
core.NOT_YOUR_TURN      = 1
core.PIECE_CAN_NOT_MOVE = 2
core.INVALID_DST        = 3
core.NO_PIECE_IN_SRC    = 4
core.NOT_YOUR_PIECE     = 5
core.MUST_MOVE_MIDDLE   = 6
core.INVALID_MOVE       = 7

local ERR_MSGS = {
	[core.SUCCESS]            = "Success",
	[core.NOT_YOUR_TURN]      = "Not your turn",
	[core.PIECE_CAN_NOT_MOVE] = "This piece can not move",
	[core.INVALID_DST]        = "Invalid destination",
	[core.NO_PIECE_IN_SRC]    = "No piece to select",
	[core.NOT_YOUR_PIECE]     = "Not your piece",
	[core.MUST_MOVE_MIDDLE]   = "Must move piece in middle",
	[core.INVALID_MOVE]       = "Invalid move",
}

local STATE_WAITING_FOR_INIT_ROLLS    = 1
local STATE_WAITING_FOR_INIT_ACK      = 2
local STATE_WAITING_FOR_ROLL_NO_DBL   = 3
local STATE_WAITING_FOR_ROLL_AFTER_DBL= 4
local STATE_WAITING_FOR_MOVE_COMPLETE = 5

core.PLAYERS = {
	core.PLAYER_BLACK,
	core.PLAYER_WHITE,
}

function core.get_err_msg(rc)
	return ERR_MSGS[rc]
end

function core.get_player_name(player)
	if     player == core.PLAYER_BLACK then return "Black"
	elseif player == core.PLAYER_WHITE then return "White"
	else error(string.format("unexpected player id=%s", player)) end
end

function core.all_init_roll_complete(state)
	for player, init_roll in ipairs(state.player_init_rolls) do
		if init_roll == 0 then
			return false
		end
	end

	return true
end

local function get_next_init_roll_player(state)
	for player, init_roll in ipairs(state.player_init_rolls) do
		if init_roll == 0 then
			return player
		end
	end
end

local function dice_sum(dice)
	local sum_val = 0
	for _, die in ipairs(dice) do
		sum_val = sum_val + die
	end
	return sum_val
end

local function get_init_first_player(state)
	local max_dice = nil
	local max_dice_val = 0
	local max_player = nil
	for player, init_dice in ipairs(state.player_init_rolls) do
		if init_dice > max_dice_val then
			max_dice_val = init_dice
			max_dice = init_dice
			max_player = player
		end
	end

	return { player = max_player, dice = max_dice, dice_val = max_dice_val }
end

function get_init_prev_status_msg(state)
	local last_player = nil
	for player, init_dice in ipairs(state.player_init_rolls) do
		if init_dice == 0 then
			break
		end
		last_player = player
	end

	if last_player ~= nil then
		local last_player_name = core.get_player_name(last_player)
		local last_roll = state.player_init_rolls[last_player]
		return string.format("%s rolled %d. ", last_player_name, last_roll)
	end

	return ""
end

function core.get_status_msg(state)
	--print(string.format("get_status_msg(state=%s)", state.game_state))
	if state.game_state == STATE_WAITING_FOR_INIT_ROLLS then 
		local player = get_next_init_roll_player(state)
		local player_name = core.get_player_name(player)

		local prev_status_msg = get_init_prev_status_msg(state)
		return string.format("%s%s, please roll to see who goes first", prev_status_msg, player_name)
	end
	if state.game_state == STATE_WAITING_FOR_INIT_ACK then
		if state.player_init_rolls[1] == state.player_init_rolls[2] then
			return string.format("Both players rolled a %s, press 'Ack' to start over.", state.player_init_rolls[1])
		else
			local first_player = get_init_first_player(state).player
			local first_player_name = core.get_player_name(first_player)
			local prev_status_msg = get_init_prev_status_msg(state)
			return string.format("%s%s goes first, press 'Acknowledge' to continue", prev_status_msg, first_player_name)
		end
	end
	local action
	if state.player_selected == nil then
		action = "select a piece"
	else
		action = "select a destination"
	end
	return string.format("%s, please %s", core.get_player_name(state.player_turn), action)
end

function core.show_roll_button(state, player)
	if state.player_turn ~= player then
		return false
	end
	return (state.game_state == STATE_WAITING_FOR_INIT_ROLLS or
	        state.game_state == STATE_WAITING_FOR_ROLL_NO_DBL or
	        state.game_state == STATE_WAITING_FOR_ROLL_AFTER_DBL)
end

function core.show_ack_button(state)
	return state.game_state == STATE_WAITING_FOR_INIT_ACK
end

local function set_used_dice(state, dice_vals)
	state.used_dice = {}
	for i=1,#state.dice_vals do
		state.used_dice[i] = false
	end
end


function core.ack_init(state, player)
	if state.game_state == STATE_WAITING_FOR_INIT_ACK then
		if state.player_init_rolls[1] == state.player_init_rolls[2] then
			state.game_state = STATE_WAITING_FOR_INIT_ROLLS
			state.dice_vals = {}
			state.player_init_rolls = { 0, 0 }
		else
			local first_player_info = get_init_first_player(state)
			state.dice_vals = { state.player_init_rolls[1], state.player_init_rolls[2] }
			set_used_dice(state, state.dice_vals)
			state.game_state = STATE_WAITING_FOR_MOVE_COMPLETE
			state.move_timer = 0
		end
	else
		error(string.format("ack_init called from state %s", state.game_state))
	end

	return core.SUCCESS
end

local function make_pieces(val, piece_count)
	local ary = {}
	for i=1,piece_count do
		table.insert(ary, val)
	end
	return ary
end

function core.board_idx_to_coords(idx)
	if idx < 1 then return core.get_bearing_off_coords() end
	if idx > core.BACKGAMMON_COLS*2 then return core.get_bearing_off_coords() end

	idx = idx - 1
	local y = math.floor(idx/core.BACKGAMMON_COLS)+1
	local x = idx % core.BACKGAMMON_COLS + 1
	if y == 1 then
		x = core.BACKGAMMON_COLS - x + 1
	end
	return { y = y, x = x }
end

function core.is_last_piece(state, player, coords, piece_idx)
	local cell = core.get_cell(state, player, coords)
	if core.coords_are_middle(coords) then
		return piece_idx == #cell
	else
		return #cell == piece_idx
	end
end

function core.coords_to_board_idx(player, coords)
	if core.coords_are_middle(coords) then
		if player == core.PLAYER_BLACK then
			-- TODO maybe reverse these?
			return core.BOARD_IDX_START - 1
		elseif player == core.PLAYER_WHITE then
			return core.BOARD_IDX_END + 1
		else
			error(string.format("coords_to_board_idx: invalid player %s", player), 2)
		end
	elseif core.coords_are_bearing_off(coords) then
		if player == core.PLAYER_BLACK then
			return core.BOARD_IDX_START-1
		elseif player == core.PLAYER_WHITE then
			return core.BOARD_IDX_END+1
		else
			error(string.format("coords_to_board_idx: invalid player %s", player), 2)
		end
	end

	if coords == nil or
	   coords.x == nil or coords.y == nil or
	   not(1 <= coords.y and coords.y <= 2) or
	   not(1 <= coords.x and coords.x <= core.BACKGAMMON_COLS) then
		error(string.format("invalid coords {y=%s, x=%s}", coords.y, coords.x), 2)
	end
	local idx = (coords.y-1) * core.BACKGAMMON_COLS
	if coords.y == 1 then
		idx = idx + (core.BACKGAMMON_COLS - coords.x) + 1
	else
		idx = idx + coords.x
	end
	return idx
end


function pt_eq(coord1, coord2)
	return coord1.x == coord2.x and coord1.y == coord2.y
end

function core.piece_is_selected(state, coords)
	return state.player_selected ~= nil and pt_eq(state.player_selected, coords)
end

--[[
function test(idx, coord)
	local coords_result = core.board_idx_to_coords(idx)
	print(string.format("%d --> coords{y=%2d, x=%2d}", idx, coords_result.y, coords_result.x))
	local idx_result = core.coords_to_board_idx(player, coord)
	print(string.format("coords{y=%2d, x=%2d} --> %d", coord.y, coord.x, idx_result))
	assert(pt_eq(coord, coords_result))
	assert(idx == idx_result)
end
test(1, { y=1, x=12})
test(2, { y=1, x=11})
test(3, { y=1, x=10})
test(4, { y=1, x= 9})
test(5, { y=1, x= 8})
test(6, { y=1, x= 7})
test(7, { y=1, x= 6})
test(8, { y=1, x= 5})
test(9, { y=1, x= 4})
test(10, { y=1, x= 3})
test(11, { y=1, x= 2})
test(12, { y=1, x= 1})
test(13, { y=2, x= 1})
test(14, { y=2, x= 2})
test(15, { y=2, x= 3})
test(16, { y=2, x= 4})
test(17, { y=2, x= 5})
test(18, { y=2, x= 6})
test(19, { y=2, x= 7})
test(20, { y=2, x= 8})
test(21, { y=2, x= 9})
test(22, { y=2, x= 10})
test(23, { y=2, x= 11})
test(24, { y=2, x= 12})
--]]

--[
--  starting positions are:
--  1  2  3  4  5  6    7  8  9  10 11 12
--  B5 -- -- -- 3W -- | 5W -- -- -- -- 2B
--  W5 -- -- -- 3B -- | 5B -- -- -- -- 2W
--  white moves clockwise
--  black moves counter clockwise,
--]
function core.new_game()
	local state = {
		player_init_rolls = {},
		player_turn = core.PLAYER_BLACK,
		game_state = STATE_WAITING_FOR_INIT_ROLLS,

		-- there are typically two dice, unless when rolled they
		-- have the same value, in which case there are 4 dice.
		-- i.e. each value represents a move that can be made.
		-- the UI may choose to render this differently
		dice_vals = nil,
		-- array of booleans corresponding to if values in `dice_vals` have been used
		used_dice = nil,
		player_selected = nil,

		double_val = 1,

		move_timer = nil,

		-- set to true when the player must press a "can't move" button to acknowledge that
		-- they can't move. Only needed when there are dice moves remaining, but they can't be
		-- used to make a legitimate move.
		player_cant_move = false,
		pieces_in_middle = {},
		finished_pieces = {},
		board = {},
	}

	for _, player in ipairs(core.PLAYERS) do
		state.player_init_rolls[player] = 0
		state.pieces_in_middle[player] = {}
		state.finished_pieces[player] = {}
	end

	for y=1,core.BACKGAMMON_ROWS do
		state.board[y] = {}
		for x=1,core.BACKGAMMON_COLS do
			state.board[y][x] = {}
		end
	end

	state.board[1][ 1] = make_pieces(core.PLAYER_BLACK, 5)
	state.board[1][ 5] = make_pieces(core.PLAYER_WHITE, 3)
	state.board[1][ 7] = make_pieces(core.PLAYER_BLACK, 5)
	state.board[1][12] = make_pieces(core.PLAYER_BLACK, 2)

	state.board[2][ 1] = make_pieces(core.PLAYER_WHITE, 5)
	state.board[2][ 5] = make_pieces(core.PLAYER_BLACK, 3)
	state.board[2][ 7] = make_pieces(core.PLAYER_WHITE, 5)
	state.board[2][12] = make_pieces(core.PLAYER_WHITE, 2)

	return state
end

function core.get_player_dir(player)
	if player == 1 then return 1
	elseif player == 2 then return -1
	else error(string.format("unexpected player %s", player), 2) end
end

function core.print_state(state)
	print("state = {")
	print(string.format("    player_turn = %s", state.player_turn))
	print(string.format("    player_cant_move = %s", state.player_cant_move))
	print(string.format("    dice_vals = %s", utils.ary_to_str(state.dice_vals)))
	print(string.format("    used_dice = %s", utils.ary_to_str(state.used_dice)))
	print(string.format("    player_selected = %s", state.player_selected))
	print(string.format("    finished_pieces = %s", utils.ary_to_str(state.finished_pieces)))
	for i=1,2*core.BACKGAMMON_COLS do
		local coords = core.board_idx_to_coords(i)
		print(string.format("    board[%2d][%2d] (board idx: %2d) = %s",
		                    coords.y, coords.x, i,
		                    utils.ary_to_str(state.board[coords.y][coords.x])))
	end
	for player=1,core.NUM_PLAYERS do
		print(string.format("    pieces_in_middle[%d] = %s", player, utils.ary_to_str(state.pieces_in_middle[player])))
	end
	print("}")
end

local function set_dice(state, dice_vals)
	state.dice_vals = dice_vals
	set_used_dice(state, state.dice_vals)
end

local function roll_dice(state, player, num_dice)
	assert(num_dice ~= nil)
	state.dice_vals = dice.roll_multiple_dice(num_dice, core.DICE_MAX)
	if num_dice == 2 and
	   state.dice_vals[1] == state.dice_vals[2] then
		for i=1,2 do
			table.insert(state.dice_vals, state.dice_vals[1])
		end
	end
	set_dice(state, state.dice_vals)
end

function core.player_selecting_dst(state, player)
	return state.player_selected ~= nil
end

-- indicates if a destination is free to move to (e.g. is not occupied by
-- more than one enemy piece)
local function can_move_to_pos(state, y_idx, x_idx)
	local dst = {y=y_idx, x=x_idx}
	if core.coords_are_bearing_off(dst) then
		return true
	end
	local dst_cell = core.get_cell(state, player, dst)
	return (#dst_cell == 0 or #dst_cell == 1 or
	       dst_cell[1] == state.player_turn)
end

-- if a (pseudo) position is outside a board in the player's
-- forward direction, meaning that moving a place to this
-- position will remove it from the board (i.e. bearing off)
local function in_bearing_off_region(player, pos_idx)
	return (player == core.PLAYER_BLACK and pos_idx > core.BOARD_IDX_END or
	        player == core.PLAYER_WHITE and pos_idx < core.BOARD_IDX_START)
end

-- given a move choice, see if it is a valid move based on the dice sums.
-- TODO this generates all the sums and checks each one against the dst.
-- it would be more efficient to generates sums, find dsts that can be highlighted,
-- then only try to highlight those.
function core.valid_dst(state, player, src, dst)
	if src == nil then return false end
	src = core.coords_to_board_idx(player, src)

	local possib_dst_idx = core.coords_to_board_idx(player, dst)

	local avail_dice_vals = core.get_avail_dice(state.used_dice, state.dice_vals)
	local sums_info = combinations.get_distinct_sums(avail_dice_vals)
	-- Need to sort this for the case of bearing off, where
	-- instead of moving to a specific destination, you just
	-- need to move to a spot greater than 24 or less than 1.
	-- In that case, we must start with the smaller sums first,
	-- to avoid wasting more than necessary dice moving to a spot
	-- further than max+1 or min-1
	table.sort(sums_info, function (left, right)
		return left.val < right.val
	end)

	for _, sum_info in ipairs(sums_info) do
		if sum_info.val == 0 then
			goto next_sum
		end
		local dice_move_pos = src + core.get_player_dir(state.player_turn) * sum_info.val
		if dice_move_pos == possib_dst_idx or
		   core.coords_are_bearing_off(dst) and in_bearing_off_region(player, dice_move_pos) then 
			local dst_coords = core.board_idx_to_coords(possib_dst_idx)
			local is_valid = can_move_to_pos(state, dst_coords.y, dst_coords.x)
			if is_valid then
				local indexes_used = utils.get_val_indexes(avail_dice_vals, sum_info.parts)
				--print("avail_dice_vals = %s", utils.ary_to_str(avail_dice_vals))
				--print(string.format("Used dice %s", utils.ary_to_str(indexes_used)))
				return { is_valid = true, used_dice = indexes_used }
			end
		end
		::next_sum::
	end

	return { is_valid = false, used_dice = {} }
end

function valid_board_idx(board_idx)
	return 1 <= board_idx and board_idx <= core.BACKGAMMON_COLS*2
end

function core.get_avail_dice(used_dice, dice_vals)
	if used_dice == nil or dice_vals == nil then
		error(string.format("get_avail_dice: nil args used_dice=%s, dice_vals=%s", used_dice, dice_vals), 2)
	end

	if #used_dice ~= #dice_vals then
		error(string.format("get_avail_dice: used_dice len: %d, dice_vals len: %d", #used_dice, #dice_vals))
	end

	local dice_avail = {}
	for i, dice_val in ipairs(dice_vals) do
		if used_dice[i] then
			dice_val = 0
		end
		table.insert(dice_avail, dice_val)
	end
	return dice_avail
end

function core.player_can_move(state, player)
	for y=1,core.BACKGAMMON_ROWS do
		for x=1,core.BACKGAMMON_COLS do
			if core.piece_can_move(state, player, {y=y, x=x}) then
				return true
			end
		end
	end
	return false
end

-- returns true if a piece is able to move.
-- This is meant for when the player is selecting a piece to move,
-- whether or not it should be highlighted in the UI, and if it can be
-- selected by the player
function core.piece_can_move(state, player, coords)
	if player == nil then
		return false
	end

	if state.game_state ~= STATE_WAITING_FOR_MOVE_COMPLETE then
		return false
	end

	if not core.all_init_roll_complete(state, player) then
		return false
	end
	--print(string.format("piece_can_move(player=%d, coords=%s)", player, core.coords_to_str(coords)))
	local cell = core.get_cell(state, player, coords)
	if #cell == 0 or cell[1] ~= state.player_turn then
		return false
	end

	if #state.pieces_in_middle[player] > 0 and
	   not core.coords_are_middle(coords) then
		return false
	end

	local src = core.coords_to_board_idx(player, coords)

	local avail_dice = core.get_avail_dice(state.used_dice, state.dice_vals)
	--print(string.format("piece_can_move: avail_dice = %s", utils.ary_to_str(avail_dice)))
	local sums_info = combinations.get_distinct_sums(avail_dice)


	local can_bear_off = core.piece_can_bear_off(state, player, coords)

	for _, sum_info in ipairs(sums_info) do
		if sum_info.val == 0 then
			goto next_sum
		end
		local possib_dst_idx = src + core.get_player_dir(state.player_turn) * sum_info.val

		if can_bear_off and in_bearing_off_region(player, possib_dst_idx) then
			return true
		end

		if not valid_board_idx(possib_dst_idx) then
			goto next_sum
		end
		local dst_coords = core.board_idx_to_coords(possib_dst_idx)
		if can_move_to_pos(state, dst_coords.y, dst_coords.x) then
			return true
		end
		::next_sum::
	end

	return false
end

-- returns true if any dice have not been used yet
function core.any_dice_avail(state)
	return utils.any_eq(state.used_dice, false)
end

local function next_turn(state)
	--print("Moving to next player's turn")
	state.player_turn = (state.player_turn % core.NUM_PLAYERS) + 1
	state.game_state = STATE_WAITING_FOR_ROLL_NO_DBL
	state.move_timer = nil
	state.dice_vals = {}
	set_used_dice(state, state.dice_vals)

	if not core.player_can_move(state, state.player_turn) then
		state.player_cant_move = true
	end

end

local function mark_dice_used(state, dice_used_in_move)
	for _, dice_idx in ipairs(dice_used_in_move) do
		if state.used_dice[dice_idx] then
			error(string.format("tried to use dice %s but they were already used, previous use state = %s",
			      utils.ary_to_str(dice_used_in_move),
			      utils.ary_to_str(orig_dice_used)))
		end
		state.used_dice[dice_idx] = true
	end
end

-- TODO make sure that middle can't be used as a destination
local function move_player(state, player, dst_coords, dice_used_in_move)
	print(string.format("move_player %d, selected=%s, dst=%s, dice_used_in_move=%s",
	      player, core.coords_to_str(state.player_selected), core.coords_to_str(dst_coords),
	      utils.ary_to_str(dice_used_in_move)))
	local src = core.get_cell(state, player, state.player_selected)
	local dst = core.get_cell(state, player, dst_coords)

	print(string.format("move_player src_cell=%s, dst_cell=%s", utils.ary_to_str(src), utils.ary_to_str(dst)))

	-- If dst is opponent, handle "hit": place piece in middle
	if #dst > 0 and dst[1] ~= player then
		if #dst ~= 1 then
			error("move_player called with dst containing more than one opponent piece")
		end
		local piece = table.remove(dst)
		table.insert(state.pieces_in_middle[piece], piece)
	end

	local piece = table.remove(src)
	assert(piece == player)
	table.insert(dst, piece)

	local orig_dice_used = utils.ary_copy(state.used_dice)
	mark_dice_used(state, dice_used_in_move)
	state.player_selected = nil

	if not core.any_dice_avail(state) then
		print("no dice remaining, next player's turn")
		next_turn(state)
	elseif not core.player_can_move(state, player) then
		print("dice remain but player can not move anywhere")
		state.player_cant_move = true
	end
	-- if dice are available, but no moves can be made, then player needs to press a "can't move" button to progress
end

function core.player_cant_move_ack(state, player)
	if player ~= state.player_turn then
		return core.NOT_YOUR_TURN
	end

	if not state.player_cant_move then
		error("player_cant_move_ack called when state.player_cant_move is false")
	end

	state.player_cant_move = false
	next_turn(state)
	return core.SUCCESS
end

function core.coords_are_middle(coords)
	if coords == nil then error("arg is nil", 2) end
	return coords.y == -1 and coords.x == -1
end

function core.get_middle_coords()
	return { y = -1, x = -1 }
end

function core.coords_are_bearing_off(coords)
	if coords == nil then
		error("arg is nil", 2)
	end
	return coords.y == -2 and coords.x == -2
end

function core.get_bearing_off_coords()
	return { y = -2, x = -2 }
end

function core.get_cell(state, player, coords)
	if coords == nil then error("arg is nil", 2) end
	if core.coords_are_middle(coords) then
		return state.pieces_in_middle[player]
	elseif core.coords_are_bearing_off(coords) then
		return state.finished_pieces[player]
	else
		if state.board[coords.y] == nil or state.board[coords.y][coords.x] == nil then
			error(string.format("core.get_cell: unexpected coords %s", core.coords_to_str(coords)), 2)
		end
		local cell = state.board[coords.y][coords.x]
		return cell
	end
end

function core.coords_to_str(coords)
	if coords == nil then return "nil"
	else return string.format("{y=%s, x=%s}", coords.y, coords.x) end
end

function core.player_at_pos(state, coords)
	return state.board[coords.y][coords.x][1]
end

function core.get_valid_dsts(state, player, src)
	local valid_dsts = {}
	for y=1,core.BACKGAMMON_ROWS do
		for x=1,core.BACKGAMMON_COLS do
			local dst = { y = y, x = x }
			if core.valid_dst(state, player, src, dst).is_valid then
				table.insert(valid_dsts, dst)
			end
		end
	end

	return valid_dsts
end

function core.player_touch(state, player, coords)
	print(string.format("player %s touched %s", player, core.coords_to_str(coords)))
	if state.player_turn ~= player then
		return core.NOT_YOUR_TURN
	end

	-- if player selects something that isn't a piece, clear their selection
	if coords == nil then
		state.player_selected = nil
		return core.SUCCESS
	end

	if state.player_selected == nil then
		-- player is choosing a piece to select
		local cell = core.get_cell(state, player, coords)
		if #cell == 0 then
			return core.NO_PIECE_IN_SRC
		elseif cell[1] ~= player then
			return core.NOT_YOUR_PIECE
		end

		if #state.pieces_in_middle[player] > 0 and 
		   not core.coords_are_middle(coords) then
			return core.MUST_MOVE_MIDDLE
		end

		-- TODO need to make this function return false when player has pieces in middle 
		-- TODO need to handle middle highlighted as selected
		local can_move = core.piece_can_move(state, player, coords)
		if not can_move then
			return core.PIECE_CAN_NOT_MOVE
		else
			state.player_selected = coords
			return core.SUCCESS
		end
	else

		-- if the player presses the piece that they just selected,
		-- and if there is only one move available, then move there.
		-- If more than one move is available, then do nothing?
		-- (not sure if that's the most intuitive, but unselecting
		-- might be worse, since it looks similar to moving)
		if pt_eq(coords, state.player_selected) then
			local valid_dsts = core.get_valid_dsts(state, player, state.player_selected)
			--print(string.format("found %s valid dsts", #valid_dsts))
			if #valid_dsts == 1 then
				coords = valid_dsts[1]
				print(string.format("Player double tapped piece with only one destination, " ..
				                    "attempting to move to {y=%s,x=%s}", coords.y, coords.x))
			end
		end

		--print(string.format("Player selected dst index %s", possib_dst_idx))

		-- TODO should this "valid_dst" function check for middle?
		-- player is choosing a destination for their selected piece
		local valid_dst_info = core.valid_dst(state, player, state.player_selected, coords)
		if not valid_dst_info.is_valid then

			-- if the player presses a different piece that they control,
			-- then select that instead
			if not core.coords_are_bearing_off(coords) and
			   not core.coords_are_middle(coords) and
			   player == core.player_at_pos(state, coords) then
				state.player_selected = coords
				return core.SUCCESS
			end
			return core.INVALID_DST
		else
			move_player(state, player, coords, valid_dst_info.used_dice)
			return core.SUCCESS
		end
	end
end

-- Checks if a position is in the last 6 positions
-- leading up to the end of the board.
-- If all a player's pieces are in this region, they may start
-- bearing off.
local function is_final_region(player, coords)
	if player == core.PLAYER_BLACK then
		return coords.y == 2 and coords.x > 6
	elseif player == core.PLAYER_WHITE then
		return coords.y == 1 and coords.x > 6
	else
		error(string.format("unexpected player %s", player))
	end
end

local function players_pieces_all_in_final_region(state, player)
	for board_idx=core.BOARD_IDX_START,core.BOARD_IDX_END do
		local coords = core.board_idx_to_coords(board_idx)
		if not is_final_region(player, coords) and core.player_at_pos(state, coords) == player then
			return false
		end
	end

	return true
end

function core.player_can_bear_off(state, player)
	if state.game_state ~= STATE_WAITING_FOR_MOVE_COMPLETE then
		return false
	end

	if not core.all_init_roll_complete(state) then
		return false
	end
	if player ~= state.player_turn then
		return false
	end

	if not players_pieces_all_in_final_region(state, player) then
		return false
	end

	return true
end

function core.piece_can_bear_off(state, player, selection)
	if state.game_state ~= STATE_WAITING_FOR_MOVE_COMPLETE then
		return false
	end

	if not core.all_init_roll_complete(state) then
		return false
	end
	if not core.player_can_bear_off(state, player) then
		return false
	end

	if selection == nil then
		return false
	end

	local dst = core.get_bearing_off_coords()
	return core.valid_dst(state, player, selection, dst).is_valid
end

function core.increment_move_timer(state)
	if state.move_timer == nil then
		return
	end
	state.move_timer = state.move_timer + 1
end

function core.can_player_double_request(state, player)
	if state.game_state ~= STATE_WAITING_FOR_ROLL_NO_DBL then
		return false
	end

	if player ~= state.player_turn then
		return false
	end

	return true
end

function core.double_request(state, player)
	if not core.can_player_double_request(state, player) then
		return core.INVALID_MOVE
	end

	state.game_state = STATE_WAITING_FOR_ROLL_AFTER_DBL
	return core.SUCCESS
end

function core.double_response(state, player, accepted)
	if not accepted then
		-- TODO need to forfeit
	else
		state.double_val = state.double_val * 2
		state.game_state = STATE_WAITING_FOR_ROLL_AFTER_DBL
	end

end

function core.can_roll_rc(state, player)
	if state.game_state ~= STATE_WAITING_FOR_INIT_ROLLS and
	   state.game_state ~= STATE_WAITING_FOR_ROLL_NO_DBL and
	   state.game_state ~= STATE_WAITING_FOR_ROLL_AFTER_DBL then
		return core.INVALID_MOVE
	end

	if player ~= state.player_turn then
		return core.NOT_YOUR_TURN
	end

	return core.SUCCESS
end

-- dice_vals param should be nil for local multiplayer, but
-- should be the dice value when the dice is rolled by the other
-- player in network multiplayer
function core.roll(state, player, dice_vals)
	local can_roll_rc = core.can_roll_rc(state, player)
	if can_roll_rc ~= core.SUCCESS then
		return can_roll_rc
	end

	if state.game_state ~= STATE_WAITING_FOR_INIT_ROLLS then
		if dice_vals == nil then
			roll_dice(state, player, core.NUM_DICE)
		else
			set_dice(state, dice_vals)
		end
		state.game_state = STATE_WAITING_FOR_MOVE_COMPLETE
		state.move_timer = 0
	else

		if dice_vals == nil then
			roll_dice(state, player, --[[ num_dice = --]] 1)
		else
			set_dice(state, dice_vals)
		end
	
		if not core.all_init_roll_complete(state) then
			if player ~= get_next_init_roll_player(state) then
				error("game error: get_next_init_roll_player not current player")
			end
	
			state.player_init_rolls[player] = state.dice_vals[1]
	
			state.player_turn = get_next_init_roll_player(state)
			if state.player_turn == nil then
				state.game_state = STATE_WAITING_FOR_INIT_ACK
				local first_player_info = get_init_first_player(state)
				state.player_turn = first_player_info.player
			end
		end

	end

	return core.SUCCESS
end

return core
-- Game:   Backgammon
-- author: Alex Barry (github.com/alexbarry)
local draw = {}
local alex_c_api = require("alex_c_api")
local draw_more    = require("libs/draw/draw_more")
local draw_shapes  = require("libs/draw/draw_shapes")
local draw_colours = require("libs/draw/draw_colours")
local utils = require("libs/utils")
local buttons = require("libs/ui/buttons")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local core = require("games/backgammon/backgammon_core")
local dice_draw = require("libs/dice/dice_draw")

local BACKGAMMON_COLS = 12
local BOARD_COLOUR = '#ec9a34'

local BOARD_TRI_WHITE = 'backgammon_triangle_white'
local BOARD_TRI_BLACK = 'backgammon_triangle_black'
local BOARD_TRI_HIGHLIGHT = 'backgammon_triangle_highlight'

local brightness_percent = nil
local dice_invert = nil


local HIGHLIGHT_OUTLINE_WIDTH = 3
local HIGHLIGHT_COLOUR   = '#ffff0066'
local HIGHLIGHT_OUTLINE = '#ffff00'
local DICE_BG_COLOUR = '#ffffff'
local DICE_USED_COLOUR = '#555555ee'

local LINE_COLOUR = '#444444'
local TEXT_COLOUR = '#ccccff'
local TEXT_SIZE   = 18
local TEXT_PADDING = 5
local MIDDLE_LINE_SIZE = '20'

local BTN_COLOUR_BG     = '#888888'
local BTN_COLOUR_FG     = '#000000'
local BTN_OUTLINE_WIDTH = 4

local board_height = 480
local board_width  = 480


local DICE_Y_SIZE = 50
local DICE_X_SIZE = 50
local DICE_PADDING = 10

local SIDE_BUTTONS_WIDTH = math.floor(((board_width - MIDDLE_LINE_SIZE)/2 - DICE_PADDING)/2)

local BEARING_OFF_BUTTON_WIDTH = SIDE_BUTTONS_WIDTH
local BEARING_OFF_BUTTON_HEIGHT = DICE_Y_SIZE

local DOUBLE_BTN_WIDTH  = SIDE_BUTTONS_WIDTH
local DOUBLE_BTN_HEIGHT = DICE_Y_SIZE

local middle_padding_target = 50

local DICE_Y_POS_START = math.floor((board_height - DICE_Y_SIZE)/2)
--local DICE_X_POS_START = board_width - 2*DICE_PADDING - 2*DICE_X_SIZE - BEARING_OFF_BUTTON_WIDTH - 2*DICE_PADDING
--local DICE_X_POS_START = math.floor(((board_width - middle_padding_target)/4 - DICE_X_SIZE))
local DICE_X_POS_START = 2*DICE_PADDING

local DICE_GROUP_Y_POS_START = DICE_Y_POS_START
local DICE_GROUP_X_POS_START = DICE_PADDING
local DICE_GROUP_Y_POS_END   = DICE_Y_POS_START + DICE_Y_SIZE
local DICE_GROUP_X_POS_END   = DICE_X_POS_START + 2 * DICE_X_SIZE + DICE_PADDING
local DICE2_OFFSET = 10

local TIMER_Y_POS = math.floor(board_height/2 - TEXT_SIZE/2 - TEXT_PADDING/2)
local TIMER_X_POS = math.floor(board_width/2 - MIDDLE_LINE_SIZE - TEXT_PADDING)
local TIMER_TEXT_ALIGN = alex_c_api.TEXT_ALIGN_RIGHT

local DBL_TEXT_Y_POS = math.floor(board_height/2 + TEXT_SIZE/2 + TEXT_PADDING/2)
local DBL_TEXT_X_POS = math.floor(board_width/2 - MIDDLE_LINE_SIZE - TEXT_PADDING)

local DBL_BTN_Y_POS = math.floor(board_height/2)
local DBL_BTN_X_POS = math.floor(board_width/2 + MIDDLE_LINE_SIZE/2 + DICE_PADDING + DOUBLE_BTN_WIDTH/2)
local DBL_BTN_Y_START = math.floor(DBL_BTN_Y_POS - DOUBLE_BTN_HEIGHT/2)
local DBL_BTN_Y_END   = math.floor(DBL_BTN_Y_POS + DOUBLE_BTN_HEIGHT/2)
local DBL_BTN_X_START = math.floor(DBL_BTN_X_POS - DOUBLE_BTN_WIDTH/2)
local DBL_BTN_X_END   = math.floor(DBL_BTN_X_POS + DOUBLE_BTN_WIDTH/2)

local BEARING_OFF_BUTTON_X_POS = board_width - DICE_PADDING - BEARING_OFF_BUTTON_WIDTH/2 
local BEARING_OFF_BUTTON_Y_POS = board_height/2
local BEARING_OFF_BUTTON_Y_START = math.floor(BEARING_OFF_BUTTON_Y_POS - BEARING_OFF_BUTTON_HEIGHT/2)
local BEARING_OFF_BUTTON_Y_END   = math.floor(BEARING_OFF_BUTTON_Y_POS + BEARING_OFF_BUTTON_HEIGHT/2)
local BEARING_OFF_BUTTON_X_START = BEARING_OFF_BUTTON_X_POS - BEARING_OFF_BUTTON_WIDTH/2 
local BEARING_OFF_BUTTON_X_END   = BEARING_OFF_BUTTON_X_POS + BEARING_OFF_BUTTON_WIDTH/2 

local board_triangle_width_incl_padding = math.floor((board_width - middle_padding_target)/BACKGAMMON_COLS)
local middle_padding = board_width - board_triangle_width_incl_padding * BACKGAMMON_COLS
local padding = 0
local board_triangle_width = board_triangle_width_incl_padding  - padding
local board_triangle_height = math.floor(board_height / 2.0 * 0.85)

local piece_radius = math.floor(board_triangle_width/2.0*0.9)
local MAX_PIECES_TO_DRAW_PER_DST = math.floor(board_triangle_height/(2*piece_radius))
local PIECE_TEXT_SIZE = math.floor(piece_radius)
local PIECE_TEXT_COLOUR = TEXT_COLOUR

local MIDDLE_OFFSET_Y = math.floor(piece_radius*1.5)
local MIDDLE_STACK_OFFSET_Y = math.floor(piece_radius*2/3)


local draw_state = nil

draw.BTN_ID_CANT_MOVE = "btn_cant_move"
draw.BTN_ID_UNDO = "btn_undo"
draw.BTN_ID_REDO = "btn_redo"
draw.BTN_ID_DOUBLE_REQUEST = "btn_double_request"
draw.BTN_ID_UNSELECT = "btn_unselect"
draw.BTN_ID_ROLL = "btn_roll"
draw.BTN_ID_ACK  = "btn_ack"

draw.POPUP_ID_DOUBLE_REQUEST = "popup_double_request"

local double_request_btns = {
	"Accept",
	"Decline",
}
draw.DOUBLE_REQUEST_BTN_ACCEPT  = 0
draw.DOUBLE_REQUEST_BTN_DECLINE = 1

local TEXT_DICE_LOADING = "Waiting..."

local PLAYER_IDX_TO_COLOUR_MAP = {
	-- [core.PLAYER_WHITE] = '#cc3333',
	-- [core.PLAYER_BLACK] = '#3333cc',
	[core.PLAYER_WHITE] = '#ffffff',
	[core.PLAYER_BLACK] = '#222222',
}

if alex_c_api.get_user_colour_pref() == "dark" then
	BOARD_COLOUR = '#4f2d0f'
	brightness_percent = 60
	DICE_BG_COLOUR = '#666666'
	TEXT_COLOUR = '#6666ff'
	if alex_c_api.is_feature_supported("draw_graphic_invert") then
		dice_invert = true
		DICE_BG_COLOUR = '#000000'
	end

	PLAYER_IDX_TO_COLOUR_MAP = {
		[core.PLAYER_WHITE] = '#aaaaaa',
		[core.PLAYER_BLACK] = '#222222',
	}
end

local function get_piece_text_colour(player_idx)
	if player_idx == core.PLAYER_WHITE then
		return '#000000'
	elseif player_idx == core.PLAYER_BLACK then
		return '#ffffff'
	else
		error(string.format("Unhandled player idx %s", player_idx), 2)
	end
end

local function should_highlight_dst(state, player, y_idx, x_idx)
	return (core.player_selecting_dst(state, player) and
	        core.valid_dst(state, player, state.player_selected, {y=y_idx, x=x_idx}).is_valid)
end

local function is_last_piece(state, player, coords, piece_idx)
	if piece_idx == MAX_PIECES_TO_DRAW_PER_DST then
		return true
	else
		return core.is_last_piece(state, player, coords, piece_idx)
	end
end

local function should_highlight_piece(state, coords, piece_idx)
	return (state.player_selected == nil and
	        core.piece_can_move(state, state.player_turn, coords) and
	        is_last_piece(state, state.player_turn, coords, piece_idx))
end

function draw.init(state, params)
	alex_c_api.create_btn(draw.BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(draw.BTN_ID_REDO, "Redo", 1)
	alex_c_api.create_btn(draw.BTN_ID_CANT_MOVE, "Can't move", 2)
	alex_c_api.set_btn_enabled(draw.BTN_ID_CANT_MOVE, false)
	alex_c_api.set_btn_enabled(draw.BTN_ID_UNDO, false)
	alex_c_api.set_btn_enabled(draw.BTN_ID_REDO, false)

	draw_state = {}
	draw_state.buttons_state = buttons.new_state()

	local buttons_info_left = {
		{ id = draw.BTN_ID_ROLL, label = "Roll" },
		{ id = draw.BTN_ID_ACK,  label = "Ack"  },
	}

	for _, info in ipairs(buttons_info_left) do
		buttons.new_button(draw_state.buttons_state, {
			id             = info.id,
			text           = info.label,
			bg_colour      = BTN_COLOUR_BG,
			fg_colour      = BTN_COLOUR_FG,
			outline_colour = BTN_COLOUR_FG,
			outline_width  = BTN_OUTLINE_WIDTH,
			text_size      = TEXT_SIZE,
			padding        = 5,
			y_start        = DICE_GROUP_Y_POS_START,
			x_start        = DICE_GROUP_X_POS_START,
			y_end          = DICE_GROUP_Y_POS_END,
			x_end          = DICE_GROUP_X_POS_END,
			callback       = params.handle_btn_clicked,
		})
		buttons.set_visible(draw_state.buttons_state, info.id, false)
	end


	local buttons_info = {
		--{ id = draw.BTN_ID_ROLL,           label = "Roll"       },
		{ id = draw.BTN_ID_DOUBLE_REQUEST, label = "Double"     },
		{ id = draw.BTN_ID_UNSELECT,       label = "Unselect"   },
		{ id = draw.BTN_ID_CANT_MOVE,      label = "Can't move" },
	}

	for _, info in ipairs(buttons_info) do
		--print(string.format("added btn %s", info.id))
		buttons.new_button(draw_state.buttons_state, {
			id             = info.id,
			text           = info.label,
			bg_colour      = BTN_COLOUR_BG,
			fg_colour      = BTN_COLOUR_FG,
			outline_colour = BTN_COLOUR_FG,
			outline_width  = BTN_OUTLINE_WIDTH,
			text_size      = TEXT_SIZE,
			padding        = 5,
			y_start        = DBL_BTN_Y_START,
			x_start        = DBL_BTN_X_START,
			y_end          = DBL_BTN_Y_END,
			x_end          = DBL_BTN_X_END,
			callback       = params.handle_btn_clicked,
		})
		buttons.set_enabled(draw_state.buttons_state, info.id, false)
		buttons.set_visible(draw_state.buttons_state, info.id, false)
	end
	buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_DOUBLE_REQUEST, true)
	buttons.set_enabled(draw_state.buttons_state, draw.BTN_ID_DOUBLE_REQUEST, true)

end

local function format_time(total_seconds)
	local minutes = math.floor(total_seconds/60)
	local seconds = math.floor(total_seconds) % 60
	return string.format('%2d:%02d', minutes, seconds)
end

local function get_double_text(state)
	return string.format("x%d", state.double_val)
end

local HIGHLIGHT_TYPE_NORMAL = 1
local HIGHLIGHT_TYPE_ALT    = 2

local function get_piece_highlight_type(state, player, coords, piece_idx)
	if should_highlight_piece(state, coords, piece_idx) then
		return HIGHLIGHT_TYPE_NORMAL
	elseif core.piece_is_selected(state, coords) and 
	       is_last_piece(state, state.player_turn, coords, piece_idx) then
		return HIGHLIGHT_TYPE_ALT
	else
		return nil
	end
end

local function draw_piece_highlight(state, highlight_type, player, piece_pos_y, piece_pos_x, piece_radius)
	local piece_highlight_fill    = nil
	local piece_highlight_outline = nil
	if highlight_type == HIGHLIGHT_TYPE_NORMAL then
		if player == state.player_turn then
			piece_highlight_fill    = draw_colours.HIGHLIGHT_FILL
			piece_highlight_outline = draw_colours.HIGHLIGHT_OUTLINE
		else
			piece_highlight_fill    = draw_colours.HIGHLIGHT_FILL_REMOTE
			piece_highlight_outline = draw_colours.HIGHLIGHT_OUTLINE_REMOTE
		end
	elseif highlight_type == HIGHLIGHT_TYPE_ALT then
		if player == state.player_turn then
			piece_highlight_fill    = draw_colours.ALT_HIGHLIGHT_FILL
			piece_highlight_outline = draw_colours.ALT_HIGHLIGHT_OUTLINE
		else
			piece_highlight_fill    = draw_colours.ALT_HIGHLIGHT_FILL_REMOTE
			piece_highlight_outline = draw_colours.ALT_HIGHLIGHT_OUTLINE_REMOTE
		end
	end

	if piece_highlight_fill ~= nil then
		alex_c_api.draw_circle(piece_highlight_fill, piece_highlight_outline,
		                       piece_pos_y, piece_pos_x, piece_radius + HIGHLIGHT_OUTLINE_WIDTH, HIGHLIGHT_OUTLINE_WIDTH)
	end
end

local function draw_triangle(state, player, y_pos, x_tri_pos,
				             board_triangle_width,
				             board_triangle_height, flip_y)

				local y1 = y_pos
				local y2 = y_pos
				local y3
				if flip_y then
					y3 = y_pos - board_triangle_height
				else
					y3 = y_pos + board_triangle_height
				end

				local x1 = x_tri_pos
				local x2 = x_tri_pos + board_triangle_width
				local x3 = x_tri_pos + board_triangle_width/2

				local fill_colour    = draw_colours.HIGHLIGHT_FILL
				local outline_colour = draw_colours.HIGHLIGHT_OUTLINE

				if player ~= state.player_turn then
					fill_colour    = draw_colours.HIGHLIGHT_FILL_REMOTE
					outline_colour = draw_colours.HIGHLIGHT_OUTLINE_REMOTE
				end

				alex_c_api.draw_triangle(fill_colour,
				                         y1, x1,
				                         y2, x2,
				                         y3, x3)
				draw_shapes.draw_triangle_outline(outline_colour, HIGHLIGHT_OUTLINE_WIDTH,
				                         y1, x1,
				                         y2, x2,
				                         y3, x3)
end


function draw.draw_state(state, session_id, player)
	alex_c_api.draw_clear()
	alex_c_api.draw_rect(BOARD_COLOUR, 0, 0, board_height, board_width)
	for y_idx=1,2 do
		local y_idx_draw = y_idx-1
		for x_idx=1,BACKGAMMON_COLS do
			local coords = {y = y_idx, x = x_idx }
			local x_idx_draw = x_idx-1
			local img_id
			if (x_idx + y_idx * (BACKGAMMON_COLS+1)) % 2 == 0 then
				img_id = BOARD_TRI_WHITE
			else
				img_id = BOARD_TRI_BLACK
			end
			local y_tri_pos = 0
			local y_pos = 0
			local x_pos = x_idx_draw * board_triangle_width_incl_padding + math.floor(padding/2)
			local x_tri_pos = x_pos
			local angle = 0
			local flip_y = false
			if y_idx == 2 then
				y_pos = board_height
				y_tri_pos = board_height - board_triangle_height
				--x_pos = x_pos + board_triangle_width
				-- angle = 180

				flip_y = true
				-- TODO why is this needed?? flip_y shouldn't affect the x pos, right?
				--x_tri_pos = x_pos - board_triangle_width
			end
			if x_idx > BACKGAMMON_COLS/2 then
				x_pos = x_pos + middle_padding
				x_tri_pos = x_tri_pos + middle_padding
			end

			draw_more.draw_graphic_ul(img_id, y_tri_pos, x_tri_pos,
			                        board_triangle_width, board_triangle_height,
			                        { angle_degrees = angle, flip_y = flip_y,
			                          brightness_percent = brightness_percent })
			if should_highlight_dst(state, player, y_idx, x_idx) then
				--[[
				draw_more.draw_graphic_ul(BOARD_TRI_HIGHLIGHT, y_pos, x_tri_pos,
				                        board_triangle_width, board_triangle_height,
				                        { angle_degrees = angle, flip_y = flip_y,
				                          brightness_percent = brightness_percent })
				--]]
				draw_triangle(state, player, y_pos, x_tri_pos,
				              board_triangle_width,
				              board_triangle_height, flip_y)
			end
			local piece_count = #state.board[y_idx][x_idx]
			for piece_idx, player_idx in ipairs(state.board[y_idx][x_idx]) do
				if piece_idx > MAX_PIECES_TO_DRAW_PER_DST then
					break
				end
				local player_colour = PLAYER_IDX_TO_COLOUR_MAP[player_idx]
				local sign_map = {
					[1] = 1,
					[2] = -1,
				}
				local piece_pos_x = x_pos + math.floor(board_triangle_width/2)
				local piece_pos_y = y_pos + sign_map[y_idx]*(piece_idx-1) * 2*piece_radius + piece_radius
				if y_idx == 2 then
					piece_pos_y = piece_pos_y - 2*piece_radius
				end
				alex_c_api.draw_circle(player_colour, LINE_COLOUR,
				                       piece_pos_y, piece_pos_x, piece_radius)
				if piece_idx == 1 then
					local extra_pieces = math.max(0, piece_count - MAX_PIECES_TO_DRAW_PER_DST)
					if extra_pieces > 0 then
						local extra_pieces_txt = string.format("+%d", extra_pieces)
						alex_c_api.draw_text(extra_pieces_txt, get_piece_text_colour(player_idx),
						                     piece_pos_y + PIECE_TEXT_SIZE/2, piece_pos_x,
						                     PIECE_TEXT_SIZE, alex_c_api.TEXT_ALIGN_CENTRE)
					end
				end

				local highlight_type = get_piece_highlight_type(state, player, coords, piece_idx)
				draw_piece_highlight(state, highlight_type, player, piece_pos_y, piece_pos_x, piece_radius)
			end
		end
	end

	alex_c_api.draw_line(LINE_COLOUR, MIDDLE_LINE_SIZE, 
	                     0,            board_width/2,
	                     board_height, board_width/2)

	for player_idx, pieces_in_middle in pairs(state.pieces_in_middle) do
		local pos_y_offset_sign = 1
		if player_idx == core.PLAYER_BLACK then
			pos_y_offset_sign = -1
		end
		local piece_pos_x = math.floor(board_width/2)
		local piece_pos_base_y = math.floor(board_height/2) + pos_y_offset_sign * MIDDLE_OFFSET_Y
		local player_colour = PLAYER_IDX_TO_COLOUR_MAP[player_idx]

		for i=1,#pieces_in_middle do
			local piece_pos_y = piece_pos_base_y + (i-1)*pos_y_offset_sign*MIDDLE_STACK_OFFSET_Y
			alex_c_api.draw_circle(player_colour, LINE_COLOUR,
			                       piece_pos_y, piece_pos_x,
			                       piece_radius)
			local highlight_type = get_piece_highlight_type(state, player, core.get_middle_coords(), i)
			draw_piece_highlight(state, highlight_type, player, piece_pos_y, piece_pos_x, piece_radius)
			--[[
			if should_highlight_piece(state, core.get_middle_coords(), i) then
				alex_c_api.draw_circle(HIGHLIGHT_COLOUR, HIGHLIGHT_OUTLINE,
				                       piece_pos_y, piece_pos_x, piece_radius)
			end
			--]]
		end
	end

	local dice_y_pos_start = DICE_Y_POS_START
	local dice_x_pos_start = DICE_X_POS_START

	if core.show_roll_button(state, player) or
	   core.show_ack_button(state, player) then
		dice_y_pos_start = dice_y_pos_start - DOUBLE_BTN_HEIGHT - DICE_PADDING
	end

	if state.dice_loading then
		alex_c_api.draw_text(TEXT_DICE_LOADING, TEXT_COLOUR,
		                     dice_y_pos_start + TEXT_SIZE/2 + DICE_Y_SIZE/2, dice_x_pos_start,
		                     TEXT_SIZE, alex_c_api.TEXT_ALIGN_LEFT)
		                     
	end

	if state.dice_vals ~= nil then
		if #state.dice_vals == 0 then
			-- do nothing
		elseif #state.dice_vals == 2 or #state.dice_vals == 1 then
			dice_draw.draw_dice(state.dice_vals,
			                    dice_y_pos_start, dice_x_pos_start,
			                    DICE_Y_SIZE, DICE_X_SIZE,
			                    {padding = DICE_PADDING, background_colour = DICE_BG_COLOUR,
			                     used_dice = state.used_dice, dice_used_overlay_colour = DICE_USED_COLOUR,
			                     brightness_percent = brightness_percent, invert = dice_invert })
		elseif #state.dice_vals == 4 then
			local dice2 = utils.ary_of(state.dice_vals[1], 2)
			local used_dice2_back  = { state.used_dice[1], state.used_dice[3] }
			local used_dice2_front = { state.used_dice[2], state.used_dice[4] }
			dice_draw.draw_dice(dice2,
			                    dice_y_pos_start - DICE2_OFFSET, dice_x_pos_start - DICE2_OFFSET,
			                    DICE_Y_SIZE, DICE_X_SIZE,
			                    {padding = DICE_PADDING, background_colour = DICE_BG_COLOUR,
			                     used_dice = used_dice2_back, dice_used_overlay_colour = DICE_USED_COLOUR,
			                     brightness_percent = brightness_percent, invert = dice_invert  })
			dice_draw.draw_dice(dice2,
			                    dice_y_pos_start, dice_x_pos_start,
			                    DICE_Y_SIZE, DICE_X_SIZE,
			                    {padding = DICE_PADDING, background_colour = DICE_BG_COLOUR,
			                     used_dice = used_dice2_front, dice_used_overlay_colour = DICE_USED_COLOUR,
			                     brightness_percent = brightness_percent, invert = dice_invert  })
		else
			error(string.format("Unexpected dice count %s", #state.dice_vals))
		end
	end

	if core.piece_can_bear_off(state, player, state.player_selected) then
		alex_c_api.draw_graphic("arrow",
		                        BEARING_OFF_BUTTON_Y_POS, BEARING_OFF_BUTTON_X_POS,
		                        BEARING_OFF_BUTTON_WIDTH, BEARING_OFF_BUTTON_HEIGHT)
	end


	if state.move_timer ~= nil then
		alex_c_api.draw_text(format_time(state.move_timer), TEXT_COLOUR,
		                     TIMER_Y_POS, TIMER_X_POS, TEXT_SIZE,
		                     TIMER_TEXT_ALIGN)
	end

	if state.double_val > 1 then
		alex_c_api.draw_text(get_double_text(state), TEXT_COLOUR,
		                     DBL_TEXT_Y_POS, DBL_TEXT_X_POS, TEXT_SIZE,
		                     TIMER_TEXT_ALIGN)
	end

	alex_c_api.set_btn_enabled(draw.BTN_ID_CANT_MOVE, state.player_cant_move)
	alex_c_api.set_btn_enabled(draw.BTN_ID_UNDO, alex_c_api.has_saved_state_offset(session_id, -1))
	alex_c_api.set_btn_enabled(draw.BTN_ID_REDO, alex_c_api.has_saved_state_offset(session_id,  1))


	local can_player_double = core.can_player_double_request(state, player)
	--buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_DOUBLE_REQUEST, can_player_double)
	buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_DOUBLE_REQUEST, can_player_double)
	--buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_ROLL,           not state.player_rolled)

	buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_ROLL, core.show_roll_button(state, player))
	buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_ACK,  core.show_ack_button(state, player))

	local show_unselect_btn = (state.player_selected ~= nil and player == state.player_turn)
	buttons.set_visible(draw_state.buttons_state, draw.BTN_ID_UNSELECT, show_unselect_btn)
	buttons.set_enabled(draw_state.buttons_state, draw.BTN_ID_UNSELECT, true)

	buttons.draw(draw_state.buttons_state)

	alex_c_api.draw_refresh()
end

function draw.double_request(state)
	local requester_player_name = core.get_player_name(state.player_turn)
	local msg = string.format("Player %s has requested to increase double cube from " ..
	                          "%s to %s, do you accept?\n" ..
	                          "If you decline, you will forfeit this game.",
	                          requester_player_name, state.double_val, 2*state.double_val)
	show_buttons_popup.show_popup(draw.POPUP_ID_DOUBLE_REQUEST,
	                              "Double Request", msg,
	                              double_request_btns)
end

-- TODO need to handle selecting the middle too, at least when there are
-- pieces in it
function draw.screen_coords_to_board_coords(pos_y, pos_x, player_can_bear_off)
	local middle_l = math.floor((board_width - middle_padding)/2)
	local middle_r = math.floor((board_width + middle_padding)/2)

	--print(string.format("{%s, %s}; [%s %s] [%s %s]", pos_y, pos_x, BEARING_OFF_BUTTON_Y_START, BEARING_OFF_BUTTON_Y_END,
	--                                                 BEARING_OFF_BUTTON_X_START, BEARING_OFF_BUTTON_X_END))
	if player_can_bear_off and
	   BEARING_OFF_BUTTON_Y_START <= pos_y and pos_y <= BEARING_OFF_BUTTON_Y_END and
	   BEARING_OFF_BUTTON_X_START <= pos_x and pos_x <= BEARING_OFF_BUTTON_X_END then
		return core.get_bearing_off_coords()
	end


	if middle_l <= pos_x and pos_x <= middle_r then
		return core.get_middle_coords()
	end
	local y_idx
	if 0 <= pos_y and pos_y < board_triangle_height then
		y_idx = 1
	elseif board_height - board_triangle_height <= pos_y and pos_y <= board_height then
		y_idx = 2
	end

	local x_idx
	if 0 <= pos_x and pos_x <= (board_width - middle_padding)/2 then
		x_idx = math.floor(pos_x/board_triangle_width_incl_padding) + 1
	elseif (board_width + middle_padding)/2 <= pos_x and pos_x <= board_width then
		x_idx = math.floor((pos_x - middle_padding)/board_triangle_width_incl_padding) + 1
	else
		x_idx = nil
	end

	if y_idx ~= nil and x_idx ~= nil then
		return { y = y_idx, x = x_idx }
	end

	return nil
end

-- returned true if the user clicked a button
function draw.handle_user_clicked(pos_y, pos_x)
	local btn_id_clicked = buttons.on_user_click(draw_state.buttons_state, pos_y, pos_x)
	if btn_id_clicked ~= nil then
		return true
	else
		return false
	end
end

return draw
-- Game:   Backgammon
-- author: Alex Barry (github.com/alexbarry)
--[[
TODO:
* players take turns rolling dice to decide who goes first?
* limit number of checkers on UI in each column to 6 or so, then show "+n"
* change piece highlights to yellow for "select a piece to move",
* then highlight selected piece in blue
* investigate errors


The network multiplayer sequence is mostly:
* local user presses the screen to make a move,
* local game handles the move, draws on the screen, and
* send move to remote player
* remote player handles the move and updates the screen

Dice rolling is handled by one player serving as "host"
(let's call the other player "client"),
currently it is the player that selected {black or white}
first:
* when the host player rolls the dice, they send the "dice" (CMD_DICE) command.
  This causes the remote player to call core.roll(state, game, dice_vals = <vals received>).
  The core game logic should behave the same as if the local player rolled, but
  instead of using its own random number generator, it uses the received dice values.
* when a client player rolls the dice:
      - client sends the "roll request" (CMD_ROLL_REQ) command and do nothing else locally for now
      - host should respond with CMD_DICE, which will cause the client player to roll
        with the provided dice value

# Host rolls the dice

            host                            client
            player 1                        player 2
             |                                 |
     roll    |                                 |
    request  |                                 |
             |                                 |
 core.roll(  |                                 |
   player=1, |                                 |
   vals=nil) |                                 |
             |                                 |
 (this       |                                 |
  generates  |                                 |
  dice vals) |                                 |
             |                                 |
             | ---> CMD_ROLL, dice vals ------>| core.roll(player=1, vals)
             |                                 |
             |                                 | (this advances game
             |                                 |  state but uses the
             |                                 |  provided dice vals
             |                                 |  instead of generating
             |                                 |  any)
             |                                 |

# Client rolls the dice

            host                            client
            player 1                        player 2
             |                                 |
             |                                 |  roll
             |                                 |  request
             | <------- CMD_ROLL_REQ <-------- |
 core.roll(  |                                 |
   player=2, |                                 |
   vals=nil) |                                 |
             |                                 |
 (this       |                                 |
  generates  |                                 |
  dice vals) |                                 |
             | ----> CMD_DICE, dice_vals ----> | core.roll(vals)
             |                                 |
             |                                 |
             |                                 |
  
--]]
local core = require("games/backgammon/backgammon_core")
local draw = require("games/backgammon/backgammon_draw")
local serialize = require("games/backgammon/backgammon_serialize")

local two_player = require("libs/multiplayer/two_player")
local utils = require("libs/utils")

local alex_c_api = require("alex_c_api")

local session_id = alex_c_api.get_new_session_id()
local state = core.new_game()

-- I uncomment this when testing bearing off, without having to play a full game
--[[
state.board = {
	{
		{},
		{},
		{},
		{},
		{},
		{},

		{},
		{},
		{},
		{2,2,2,2,2,2,2,2,2},
		{},
		{},
	},

	{
		{},
		{},
		{},
		{},
		{},
		{},

		{},
		{},
		{},
		{1,1,1,1,1,1,1,1,1},
		{},
		{},
	},
}
--]]

local player = nil
local local_multiplayer = nil
local is_host = true -- TODO set this
local player_name_to_id = {}
local g_other_player = nil
local invalid_dst_in_a_row = 0

local GAME_OPTION_NEW_GAME = "option_new_game"

local POPUP_ID_SELECT_PLAYER = "popup_select_player"
local PLAYER_CHOICE_BTNS = {
	core.get_player_name(core.PLAYER_WHITE),
	core.get_player_name(core.PLAYER_BLACK),
}
local BTN_MAP = {
	[0] = core.PLAYER_WHITE,
	[1] = core.PLAYER_BLACK,
}

local function get_player()
	if local_multiplayer then
		return state.player_turn
	else
		return player
	end
end

local function save_state()
	local serialized_state = serialize.serialize_state(state)
	alex_c_api.save_state(session_id, serialized_state)
end

function draw_board()
	core.increment_move_timer(state)
	draw.draw_state(state, session_id, get_player())
	print(string.format("Game state is %d", state.game_state))
	--core.print_state(state)
	--alex_c_api.set_status_msg(core.get_status_msg(state))
end

local function handle_rc(rc)
	print(string.format("handle_rc(rc=%s(%s))", rc, core.get_err_msg(rc)))
	if rc ~= core.SUCCESS then
		local err_msg = core.get_err_msg(rc)
		if rc == core.INVALID_DST then
			invalid_dst_in_a_row = invalid_dst_in_a_row + 1
			if invalid_dst_in_a_row  >= 3 then
				err_msg = err_msg .. " (To change your selected piece, press the " ..
				                     "middle of the board or the currently selected piece)"
			end
		else
			invalid_dst_in_a_row = 0
		end
		alex_c_api.set_status_err(err_msg)
	else
		invalid_dst_in_a_row = 0
		local msg = core.get_status_msg(state)
		alex_c_api.set_status_msg(msg)

		-- TODO only do this if a move was actually made
		if rc == core.SUCCESS then
			save_state()
		end
	end
end

local function double_request(player)
	alex_c_api.set_status_msg(string.format("%s has proposed doubling the value of winning the match.", core.get_player_name(player)))
	local rc = core.double_request(state, get_player())
	draw.double_request(state)
	return rc
end


local game_msg_prefix    = "backgammon"

local CMD_TOUCH          = "touch"
local CMD_DOUBLE_REQUEST = "double_request"
local CMD_ROLL           = "roll"
local CMD_ROLL_REQ       = "roll_request"
local CMD_ACK_INIT       = "ack_init"
local CMD_ACK_CANT_MOVE  = "ack_cant_move" -- TODO combine with the other ack
local CMD_UNSELECT       = "unselect"

local CMD_DICE           = "dice"

-- This should be called when the user presses the "roll" button.
-- It either does the roll locally, or sends a message and shows "waiting"
-- to the user until the dice values are received from the host player.
function roll_request(state, player)
	if local_multiplayer or two_player.am_first_player() then
		local request_is_local = (player == get_player())
		local for_player_str = nil
		if request_is_local then
			for_player_str = string.format("for local player %s", player)
		else
			for_player_str = string.format("on behalf of player %s", player)
		end
		print(string.format("We are player 1 of %d, rolling dice (%s) and broadcasting value", two_player.get_player_count(), for_player_str))
		local rc = core.roll(state, player)
		if rc == core.SUCCESS then
			if state.dice_vals ~= nil then
				print(string.format("dice_vals len is %d, vals: %s", #state.dice_vals, utils.ary_to_str(state.dice_vals)))
			else
				print(string.format("dice_vals == nil"))
			end
			if request_is_local then
				send_cmd(CMD_ROLL, player, state.dice_vals)
			else
				send_cmd(CMD_DICE, player, state.dice_vals)
			end
		end

		return rc
	else
		-- this is a bit awkward, but we don't want to let
		-- the remote player send the roll command if it isn't their turn
		if state.player_turn ~= get_player() then
			return core.NOT_YOUR_TURN
		end
		print(string.format("We are not player 1 of %d, send a cmd to roll and hope the other player sends us the dice value", two_player.get_player_count()))
		send_cmd(CMD_ROLL_REQ, player)
		state.dice_vals = {}
		state.dice_loading = true
		-- when CMD_DICE is received, we'll call core.roll(state, player, dice_vals)
		-- to act as if this player rolled, but providing the dice values sent by the
		-- other player
		return core.SUCCESS
	end
end

function send_cmd(cmd, player, params)
	local params_str = ""
	if params ~= nil then
		params_str = table.concat(params, ",")
	end
	local msg = string.format("%s:%s,%s,%s", game_msg_prefix, cmd, player, params_str)
	print(string.format("sending msg %s", msg))
	--print(string.format("pieces were: cmd (%s), player (%s), params_str(%s)", cmd, player, params_str))
	alex_c_api.send_message("all", msg)
end

local function str_ary_to_number_ary(str_ary)
	local num_ary = {}
	for _, s in ipairs(str_ary) do
		table.insert(num_ary, tonumber(s))
	end
	return num_ary
end

local function parse_cmd(cmd_str)
	local cmd_pieces = utils.gmatch_to_list("([^,]+)", cmd_str)
	local cmd, player_str = table.unpack(cmd_pieces, 1, 2)
	local params = {table.unpack(cmd_pieces, 3)}
	params = str_ary_to_number_ary(params)
	--print(string.format("params type=%s, val=%s", type(params), params))

	--print(string.format("parsed cmd to: %s %s %s (cmd_pieces was %s)", cmd, player_str, params, utils.ary_to_str(cmd_pieces)))
	return cmd, tonumber(player_str), params
end

local function handle_cmd(cmd, player, params)
	print(string.format("handle_cmd(cmd=%s, player=%s, params=%s)", cmd, player, utils.ary_to_str(params)))
	if cmd == CMD_TOUCH then
		local coords = nil
		if params ~= nil and #params > 0 then
			coords = { y = params[1], x = params[2] }
		end
		return core.player_touch(state, player, coords)
	elseif cmd == CMD_DOUBLE_REQUEST then
		return double_request(player)
	elseif cmd == CMD_ACK_INIT then
		return core.ack_init(state, player)
	elseif cmd == CMD_ACK_CANT_MOVE then
		return core.player_cant_move_ack(state, player)
	elseif cmd == CMD_UNSELECT then
		if player ~= state.player_turn then
			error(string.format("Player %s tried to unselect when not their turn", player))
		end
		state.player_selected = nil
		return core.SUCCESS
	elseif cmd == CMD_DICE or
	       cmd == CMD_ROLL then
		local dice_vals = params

		if dice_vals == nil then
			error(string.format("Received cmd %s without dice val params", cmd))
		end


		rc = core.roll(state, player, dice_vals)
		state.dice_loading = false
		print(string.format("Dice vals are now: %s", utils.ary_to_str(state.dice_vals)))
		draw_board()
		return rc
	elseif cmd == CMD_ROLL_REQ then
		rc = roll_request(state, player)
		handle_rc(rc)
		draw_board()
	else
		error(string.format("Unhandled cmd \"%s\"", cmd))
	end
end

local function send_and_handle_cmd(cmd, player, params)
	if cmd == CMD_ROLL or cmd == CMD_ROLL_REQ then
		error("send_and_handle_cmd does not handle CMD_ROLL")
	end

	local rc = handle_cmd(cmd, player, params)
	if rc == core.SUCCESS then
		send_cmd(cmd, player, params)
	end
	print(string.format("cmd %s returned status %s (%s)", cmd, rc, core.get_err_msg(rc)))

	return rc
end


function handle_user_clicked(pos_y, pos_x)
	local can_bear_off = core.player_can_bear_off(state, get_player())
	-- NOTE that this can be "middle" too
	local sel_coords = draw.screen_coords_to_board_coords(pos_y, pos_x, can_bear_off)

	local btn_clicked = draw.handle_user_clicked(pos_y, pos_x)

	if not btn_clicked then
		local params = nil
		if sel_coords ~= nil then
			params = {sel_coords.y, sel_coords.x}
		end
		local rc = send_and_handle_cmd(CMD_TOUCH, get_player(), params)
		handle_rc(rc)
	end
	draw.draw_state(state, session_id, get_player())
	--core.print_state(state)

end

local function load_state(session_id_arg, serialized_state)
	session_id = session_id_arg
	state = serialize.deserialize_state(serialized_state)
end

local function load_saved_state_offset(move_id_offset)
	local serialized_state = alex_c_api.get_saved_state_offset(session_id, move_id_offset)
	if serialized_state == nil then
		error(string.format("get_saved_state_offset(offset=%d) returned nil", move_id_offset))
	end
	load_state(session_id, serialized_state)
	draw_board()
end

function handle_btn_clicked(btn_id)
	print("handle_btn_clicked: " .. btn_id)
	local rc
	if btn_id == draw.BTN_ID_CANT_MOVE then
		rc = send_and_handle_cmd(CMD_ACK_CANT_MOVE, get_player())
		draw.draw_state(state, session_id, get_player())
	elseif btn_id == draw.BTN_ID_UNDO then
		load_saved_state_offset(-1)
		-- TODO broadcast state
	elseif btn_id == draw.BTN_ID_REDO then
		load_saved_state_offset(1)
		-- TODO broadcast state
	elseif btn_id == draw.BTN_ID_DOUBLE_REQUEST then
		rc = send_and_handle_cmd(CMD_DOUBLE_REQUEST, get_player())
	elseif btn_id == draw.BTN_ID_ROLL then
		--rc = send_and_handle_cmd(CMD_ROLL, get_player())
		rc = roll_request(state, get_player())
		draw_board()
	elseif btn_id == draw.BTN_ID_ACK then
		rc = send_and_handle_cmd(CMD_ACK_INIT, get_player())
		draw_board()
	elseif btn_id == draw.BTN_ID_UNSELECT then
		rc = send_and_handle_cmd(CMD_UNSELECT, get_player())
		draw_board()
	else
		error(string.format("unhandled btn_id=%s", btn_id))
	end
	handle_rc(rc)
end

function handle_popup_btn_clicked(popup_id, btn_id)
	if two_player.handle_popup_btn_clicked(popup_id, btn_id) then
		-- do nothing
	elseif popup_id == draw.POPUP_ID_DOUBLE_REQUEST then
		local accepted = nil
		if btn_id == draw.DOUBLE_REQUEST_BTN_ACCEPT then
			accepted = true
		elseif btn_id == draw.DOUBLE_REQUEST_BTN_DECLINE then
			accepted = false
		else
			error(string.format("Unhandled popup btn id %s, in popup id %s", btn_id, popup_id))
		end
		core.double_response(state, get_player(), accepted)
		alex_c_api.hide_popup()
		draw_board()
	else
		error(string.format("Unhandled popup_id = %s", popup_id))
	end
end

local function new_game()
	alex_c_api.set_status_msg("Starting new game")
	session_id = alex_c_api.get_new_session_id()
	state = core.new_game()
	draw_board()
end

function handle_game_option_evt(option_id)
	if option_id == GAME_OPTION_NEW_GAME then
		new_game()
		alex_c_api.send_message("all", "derp hello world test to see if this is sent to sender")
	else
		error(string.format("unhandled game option id %s", option_id))
	end
end

function handle_msg_received(src, msg)
	print("Recvd msg " .. msg)

	if two_player.handle_msg_received(src, msg) then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	if m == nil then
		print("Unable to parse header from msg " .. msg)
		return
	end
	local header, payload = m()

	if header == game_msg_prefix then
		local params = {parse_cmd(payload)}
		--print(string.format("params len: %d", #params))
		--print(string.format("Received game cmd %s", utils.ary_to_str(params)))
		local rc = handle_cmd(table.unpack(params))
		handle_rc(rc)
		draw_board()
	-- TODO handle "game_cmd" messages, call handle_cmd
	elseif false then
--[[
	if header == "move" then
		local m2 = payload:gmatch("(%d+),(%d+),(%d+)")
		if m2 == nil then
			error("Invalid \"move\" msg from " .. src)
			return
		end
		local player_idx, y, x = m2()
		player_idx = tonumber(player_idx)
		y = tonumber(y)
		x = tonumber(x)
		local coords = { y = y, x = x }
		local rc = core.player_touch(state, player_idx, coords)
		handle_rc(rc,  true)

		if rc ~= core.SUCCESS then
			alex_c_api.set_status_err("Other player made an invalid move")
		else
			alex_c_api.set_status_msg("Your move")
			draw_board()
			save_state()
		end

--]]
	elseif header == "get_state" then
		alex_c_api.send_message(src, "state:" .. serialize.serialize_state(state))
	elseif header == "state" then
		local recvd_state = serialize.deserialize_state(payload)
		print("Recieved state:")
		--core.print_state(recvd_state)
		state = recvd_state
		draw_board()
		save_state()
	elseif header == "player_left" and src == "ctrl" then
	elseif header == "player_joined" then
	else
		error("Unhandled message: " .. header )
	end
end

function two_player_init()
	local args = {
		supports_local_multiplayer = true,
		title = "Choose piece colour",
		player_choices = PLAYER_CHOICE_BTNS,
		handle_multiplayer_type_choice = function (multiplayer_type)
			if multiplayer_type == two_player.MULTIPLAYER_TYPE_LOCAL then
				local_multiplayer = true
			elseif multiplayer_type == two_player.MULTIPLAYER_TYPE_NETWORK then
				local_multiplayer = false
			end
		end,
		choice_id_to_player_id = function (btn_id)
			return BTN_MAP[btn_id]
		end,
		player_name_to_id = player_name_to_id,
		player_id_to_nice_name = function (player_id)
			local player_colour = core.get_player_name(player_id)
			return utils.make_first_char_uppercase(player_colour)
		end,
		get_msg = function ()
			local msg = ""
			if utils.table_len(player_name_to_id) == 0 then
				msg = msg .. "\nThe other player has not yet chosen."
			else
				--msg = msg .. string.format("The other player has chosen %s",
				--                            core.player_id_to_name(other_player))
				for player_name, player_id in pairs(player_name_to_id) do
					local player_colour = core.get_player_name(player_id)
					msg = msg .. string.format("\n%s is chosen by %s", utils.make_first_char_uppercase(player_colour), player_name)
				end
			end
			return msg
		end,
		handle_player_choice = function (player_name, player_id)
			local choice_str = core.get_player_name(player_id)
			print(string.format("handle_player_choice{ player_name=\"%s\", choice=%q (%q) }", player_name, player_id, choice_str))

			if player_name == two_player.LOCAL_PLAYER then
				player = player_id
			else
				g_other_player = player_id
			end
		end,

		need_reselect = function ()
			local this_player  = player
			local other_player = g_other_player

			return this_player == nil or this_player == other_player
		end,

		get_local_player_choice = function ()
			return player
		end
	}

	two_player.init(args)
end

function get_state()
	return serialize.serialize_state(state)
end


function start_game(session_id_arg, serialized_state)
	if serialized_state ~= nil then
		load_state(session_id_arg, serialized_state)
	else
		local last_sess_id = alex_c_api.get_last_session_id()
		if last_sess_id ~= nil then
			serialized_state = alex_c_api.get_saved_state_offset(last_sess_id, 0)
			if serialized_state ~= nil then
				load_state(last_sess_id, serialized_state)
			end
		end
	end

	-- TODO ideally the draw library could handle the button presses, forward a
	-- generic event to main which could be passed to the core API
	--draw.init(state)

	-- TODO call new game if no loaded state

	alex_c_api.add_game_option(GAME_OPTION_NEW_GAME, { label = "New game", type = alex_c_api.OPTION_TYPE_BTN })

	alex_c_api.set_timer_update_ms(1000)

	local msg = core.get_status_msg(state)
	alex_c_api.set_status_msg(msg)

	alex_c_api.send_message("all", "get_state:")
	two_player_init()
end

-- TODO ideally the draw library could handle the button presses, forward a
-- generic event to main which could be passed to the core API
draw.init(state, {
	handle_btn_clicked = handle_btn_clicked,
})
local serialize = {}

local core = require("games/backgammon/backgammon_core")
local serialize_lib = require("libs/serialize/serialize")

serialize.CURRENT_VERSION = 2

-- when encoding dice
local USED_DICE_BIT_OFFSET   = 3
assert(6 < 2^USED_DICE_BIT_OFFSET)

-- when encoding cells
local CELL_PLAYER_BIT_OFFSET = 5
assert(24 < 2^CELL_PLAYER_BIT_OFFSET)

local function bit_idx_to_mask(bit_idx)
	return (1<<bit_idx) - 1
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(serialize.CURRENT_VERSION)
	output = output .. serialize_lib.serialize_byte(state.game_state)
	output = output .. serialize_lib.serialize_byte(state.player_turn)
	output = output .. serialize_lib.serialize_byte(math.floor(math.log(state.double_val)/math.log(2)))
	output = output .. serialize_lib.serialize_byte(#state.player_init_rolls)
	for i=1,#state.player_init_rolls do
		output = output .. serialize_lib.serialize_byte(state.player_init_rolls[i])
	end
	output = output .. serialize_lib.serialize_byte(#state.dice_vals)
	for i=1,#state.dice_vals do
		local used_dice_int = 0
		if state.used_dice[i] then
			used_dice_int = 1
		end
		local dice_val_encoded = state.dice_vals[i] | (used_dice_int << USED_DICE_BIT_OFFSET)
		output = output .. serialize_lib.serialize_byte(dice_val_encoded)
	end
	for _,player_idx in ipairs(core.PLAYERS) do
		output = output .. serialize_lib.serialize_byte(#state.pieces_in_middle[player_idx])
		output = output .. serialize_lib.serialize_byte(#state.finished_pieces[player_idx])
	end

	for board_idx=core.BOARD_IDX_START,core.BOARD_IDX_END do
		local coords = core.board_idx_to_coords(board_idx)
		local cell = state.board[coords.y][coords.x]
		local cell_enc = 0

		if #cell > 0 then
			local player_in_cell = cell[1]
			cell_enc = (#cell) | (player_in_cell << CELL_PLAYER_BIT_OFFSET)
		end
		output = output .. serialize_lib.serialize_byte(cell_enc)
	end

	return output
end

function serialize.deserialize_state(byte_str)
	local bytes = serialize_lib.bytestr_to_byteary(byte_str)
	local state = {
		dice_vals = {},
		used_dice = {},

		pieces_in_middle = {},
		finished_pieces = {},
		board = {},
	}
	for _, player_idx in ipairs(core.PLAYERS) do
		state.pieces_in_middle[player_idx] = {}
		state.finished_pieces[player_idx]  = {}
	end
	for y=1,core.BACKGAMMON_ROWS do
		table.insert(state.board, {})
		for x=1,core.BACKGAMMON_COLS do
			table.insert(state.board[y], {})
		end
	end

	local version = serialize_lib.deserialize_byte(bytes)
	if version ~= serialize.CURRENT_VERSION then
		error(string.format("Received serialized state encoded with version %d, can only handle %d", version, serialize.CURRENT_VERSION))
	end


	state.game_state = serialize_lib.deserialize_byte(bytes)
	state.player_turn = serialize_lib.deserialize_byte(bytes)
	state.double_val = 2^serialize_lib.deserialize_byte(bytes)

	local player_init_rolls_count = serialize_lib.deserialize_byte(bytes)
	state.player_init_rolls = {}
	for _=1,player_init_rolls_count do
		table.insert(state.player_init_rolls, serialize_lib.deserialize_byte(bytes))
	end

	local dice_count = serialize_lib.deserialize_byte(bytes)
	for _=1,dice_count do
		local dice_enc_val = serialize_lib.deserialize_byte(bytes)
		table.insert(state.dice_vals, dice_enc_val & bit_idx_to_mask(USED_DICE_BIT_OFFSET))
		table.insert(state.used_dice, (dice_enc_val >> USED_DICE_BIT_OFFSET) ~= 0)
	end

	for _,player_idx in ipairs(core.PLAYERS) do
		local middle_count = serialize_lib.deserialize_byte(bytes)
		local finished_count = serialize_lib.deserialize_byte(bytes)
		for _=1,middle_count do
			table.insert(state.pieces_in_middle[player_idx], player_idx)
		end
		for _=1,finished_count do
			table.insert(state.finished_pieces[player_idx], player_idx)
		end
	end

	for board_idx=core.BOARD_IDX_START,core.BOARD_IDX_END do
		local coords = core.board_idx_to_coords(board_idx)
		local cell_enc = serialize_lib.deserialize_byte(bytes)
		if cell_enc > 0 then
			local player_in_cell = cell_enc >> CELL_PLAYER_BIT_OFFSET
			local cell_piece_count = cell_enc & bit_idx_to_mask(CELL_PLAYER_BIT_OFFSET)
			for _=1,cell_piece_count do
				table.insert(state.board[coords.y][coords.x], player_in_cell)
			end
		end
	end

	if #bytes ~= 0 then
		error(string.format("After deserializing state, %d bytes remain, expected 0", #bytes))
	end

	return state
end

return serialize
local core = {}

local shuffle = require("libs/shuffle")

core.PIECE_EMPTY = 0

core.PIECES = {
	["white" ]    = 1,
	["black" ]    = 2,
	["red"   ]    = 3,
	["yellow"]    = 4,
	["blue"  ]    = 5,
}

core.PIECE_COLOUR_COUNT     = 5
core.PIECE_PER_COLOUR_COUNT = 20
core.PIECES_PER_PILE        = 4

-- Passed as an argument to core.place_piece to indicate
-- that the player is selecting from the discard pile
core.PILE_DISCARD = -1

core.RC_SUCCESS      = 0
core.RC_ROW_OCCUPIED = 1

function core.rc_to_string(rc)
	local MAP = {
		[core.RC_SUCCESS]      = "Success",
		[core.RC_ROW_OCCUPIED] = "This row already contains a different colour piece",
	}
	return MAP[rc]
end

function core.get_card_piece_type(y, x)
	return 1 + ((y-1 + -x ) % core.PIECE_COLOUR_COUNT)
end

local function get_num_piles(num_players)
	local MAP = {
		[2] = 5,
		[3] = 7,
		[4] = 9,
	}
	return MAP[num_players]
end

function core.new_game(num_players)
	local state = {
		pieces = {},
		piles = {},
		discard_penalty = true,
		discard_pile = {},
		player_states = {},
	}

	for _, piece_colour in pairs(core.PIECES) do
		for _=1,core.PIECE_PER_COLOUR_COUNT do
			table.insert(state.pieces, piece_colour)
		end
	end
	shuffle.shuffle(state.pieces)

	for pile_idx=1,get_num_piles(num_players) do
		state.piles[pile_idx] = {}
		for i=1,core.PIECES_PER_PILE do
			local piece = table.remove(state.pieces)
			table.insert(state.piles[pile_idx], piece)
		end
	end

	for i=1,num_players do
		state.player_states[i] = {
			score   =  0,
			staging = {},
			card    = {},
		}

		for y=1,core.PIECE_COLOUR_COUNT do
			state.player_states[i].staging[y] = { colour = nil, count = 0 }
			state.player_states[i].card[y] = {}
			for x=1,core.PIECE_COLOUR_COUNT do
				state.player_states[i].card[y][x] = core.PIECE_EMPTY
			end
		end

		
	end

	return state
end

function core.can_place_piece(state, player, selected_pile, selected_piece_colour, dst_row)
	local staging_row = state.player_states[player].staging[dst_row]
	return staging_row.count == 0 or 
	       (staging_row.colour == selected_piece_colour and staging_row.count < dst_row)
end

function core.place_piece(state, player, selected_pile, selected_piece_colour, dst_row)
	print(string.format("place_piece(player=%s, selected_pile=%s, selected_colour=%s, dst_row=%s)",
	                    player, selected_pile, selected_piece_colour, dst_row))
	if not core.can_place_piece(state, player, selected_pile, selected_piece_colour, dst_row) then
		return core.RC_ROW_OCCUPIED
	end

	local penalty = 0
	local pile
	if selected_pile == core.PILE_DISCARD then
		pile = state.discard_pile
		if state.discard_penalty then
			-- TODO handle discard penalty
			penalty = -1
			state.discard_penalty = false
		end
	else
		pile = state.piles[selected_pile]
		state.piles[selected_pile] = nil
	end
	local pieces_to_move = {}
	local pieces_to_discard = {}
	for _, piece in ipairs(pile) do
		if piece == selected_piece_colour then
			table.insert(pieces_to_move, piece)
		else
			table.insert(pieces_to_discard, piece)
		end
	end

	if pile == state.discard_pile then
		state.discard_pile = {}
	end

	for _, piece in ipairs(pieces_to_discard) do
		table.insert(state.discard_pile, piece)
	end

	local staging = state.player_states[player].staging
	-- TODO handle putting too many in staging area
	staging[dst_row].colour = pieces_to_move[1]
	staging[dst_row].count  = staging[dst_row].count + #pieces_to_move

	return core.RC_SUCCESS
end

return core
local draw = {}

local ui   = require("games/blue/blue_ui")
local core = require("games/blue/blue_core")
local draw_shapes = require("libs/draw/draw_shapes")
local alex_c_api = require("alex_c_api")

local BTN_SELECT_BACKGROUND = '#55555588'

--local PIECE_OUTLINE_COLOUR = '#666666'
local PIECE_OUTLINE_COLOUR = '#8888aa'
--local PIECE_OUTLINE_COLOUR = '#ffffff' 


local HIGHLIGHT_COLOUR_BG      = '#ffff0066'
local HIGHLIGHT_COLOUR_BG_LIGHT = '#ffff0033'
local HIGHLIGHT_COLOUR_OUTLINE = '#ffff00'
local HIGHLIGHT_COLOUR_OUTLINE_TRANSPARENT = '#ffff0066'

local SELECTED_COLOUR_BG       = '#ffffff66'
local SELECTED_COLOUR_OUTLINE  = '#88cccc'

local PENALTY_TEXT_ICON_COLOUR_BG = '#66cc66'
local PENALTY_TEXT_ICON_COLOUR_OUTLINE = '#008800'

local COLOUR_MAP = {
	--[core.PIECES["white"]]  = { filled = "#ccffff", empty = "#ccffff33" },
	[core.PIECES["white"]]  = { filled = "#aacccc", empty = "#aacccc33" },
	[core.PIECES["black"]]  = { filled = "#000000", empty = "#00000033" },
	[core.PIECES["red"  ]]  = { filled = "#ff0000", empty = "#ff000033" },
	--[core.PIECES["yellow"]] = { filled = "#ffff00", empty = "#ffff0033" },
	-- making yellow a little darker to distinguish it from the highlight
	[core.PIECES["yellow"]] = { filled = "#ddc249", empty = "#ddc24966" },
	[core.PIECES["blue"]]   = { filled = "#0000ff", empty = "#0000ff33" },
}

local SQUARE_SIZE = 40
local CARD_SIZE = core.PIECE_COLOUR_COUNT * SQUARE_SIZE

local SMALL_SQUARE_SIZE = 15

local text_size = 18

local board_width  = 480
local board_height = 480
local padding = 5

local big_padding   = 5
local small_padding = 1


local big_pile_space_radius = math.floor(board_width/5)/2 
local pile_select_y_start = 0
local pile_select_x_start = 0

local small_pile_space_radius = math.floor(board_width/5*0.3)/2
local view_players_select_piles_y_start = board_height/2 - 5 * small_pile_space_radius
local view_players_select_piles_x_start = board_width/2 - 5 * small_pile_space_radius
local view_players_select_piles_y_end   = view_players_select_piles_y_start + 4 * small_pile_space_radius
local view_players_select_piles_x_end   = view_players_select_piles_x_start + 10 * small_pile_space_radius

local piece_select_pile_radius = 2*big_pile_space_radius

local piece_select_pile_pos = {
	y = big_padding + piece_select_pile_radius,
	x = math.floor(board_width/2),
}
local piece_select_pile_params = {
	text_size = 18,
	padding           = big_padding,
	pile_radius       = piece_select_pile_radius,
	piece_size_factor = 1/5,
	pile_space_radius = piece_select_pile_radius,
}

-- Only used when drawing _only_ the discard pile
-- (not when drawing all the piles, or when drawing the small pile button)
local discard_pile_params = {
	text_size = 24,
	-- Note that y_start/x_start are the centre of the pile
	y_start = padding + piece_select_pile_radius,
	x_start = board_width/2,

	padding           = big_padding,
	pile_radius       = piece_select_pile_radius,
	piece_size_factor = 1/5,
	pile_space_radius = piece_select_pile_radius,

}

local pile_select_pile_params = {
		padding = big_padding,
		pile_space_radius = big_pile_space_radius,
		pile_radius       = big_pile_space_radius - padding,
		y_start = pile_select_y_start,
		x_start = pile_select_x_start,
		piece_size_factor = 1/5,
}

local back_btn_y_start = view_players_select_piles_y_end + padding
local back_btn_x_start = padding
local back_btn_y_end   = back_btn_y_start + 40
local back_btn_x_end   = back_btn_x_start + 80

local function draw_game_card(state, params, player_idx)
	local card_size = core.PIECE_COLOUR_COUNT * params.square_size
	for y=1,core.PIECE_COLOUR_COUNT do
		for x=1,core.PIECE_COLOUR_COUNT do
			local square_colour_type = core.get_card_piece_type(y,x)
			local colour = COLOUR_MAP[square_colour_type]
			local y_pos = params.y_pos + (y-1)*params.square_size
			local x_pos = params.x_pos + (x-1)*params.square_size

			alex_c_api.draw_rect(colour.empty,
			                     y_pos, x_pos,
			                     y_pos + params.square_size, x_pos + params.square_size)

			if state.game_state.player_states[player_idx].card[y][x] ~= core.PIECE_EMPTY then
				alex_c_api.draw_circle(colour.filled, '#000000',
				                       math.floor(y_pos + params.square_size/2),
				                       math.floor(x_pos + params.square_size/2),
				                       math.floor(params.square_size*0.8/2))
			end
		end
	end
	draw_shapes.draw_rect_outline('#000000', 3,
	                              params.y_pos, params.x_pos,
	                              params.y_pos + card_size, params.x_pos + card_size)
end

local function get_game_staging_row_info(params, row_idx)
	return {
		y_start = params.y_pos + (row_idx-1)*params.square_size,
		y_end   = params.y_pos + (row_idx)*params.square_size,

		x_start = params.x_pos + (core.PIECE_COLOUR_COUNT-row_idx)*params.square_size,
		x_end   = params.x_pos + core.PIECE_COLOUR_COUNT*params.square_size,
	}
end

local function draw_game_staging_area(state, params, player_idx)
	for y=1,core.PIECE_COLOUR_COUNT do
		for x=1,y do
			-- x2 is x "flipped". x is position from the left,
			-- and x2 is position from the right.
			local x2 = (core.PIECE_COLOUR_COUNT - x + 1)
			local y_pos = params.y_pos + (y-1)*params.square_size
			local x_pos = params.x_pos + (x2-1)*params.square_size
			draw_shapes.draw_rect_outline('#000000', 1,
			                              y_pos, x_pos,
			                              y_pos + params.square_size, x_pos + params.square_size)
			local staging_row = state.game_state.player_states[player_idx].staging[y]
			-- y-x is:
			--         1
			--       1 2
			--     1 2 3
			--   1 2 3 4
			-- 1 2 3 4 5
			if staging_row.count > y - x then
				local square_colour_type = core.get_card_piece_type(y,x)
				local colour = COLOUR_MAP[staging_row.colour]
				alex_c_api.draw_circle(colour.filled, colour.outline,
				                       math.floor(y_pos + params.square_size/2),
				                       math.floor(x_pos + params.square_size/2),
				                       math.floor(params.square_size/2 - small_padding))
			end
		end
		local row_info = get_game_staging_row_info(params, y)
		if params.highlight_rows[y] then
			alex_c_api.draw_rect(HIGHLIGHT_COLOUR_BG,
			                     row_info.y_start, row_info.x_start,
			                     row_info.y_end,   row_info.x_end)
			local padding = 3
			draw_shapes.draw_rect_outline(HIGHLIGHT_COLOUR_OUTLINE_TRANSPARENT, 3,
			                     row_info.y_start + padding, row_info.x_start + padding,
			                     row_info.y_end   - padding, row_info.x_end   - padding)
		end
	end
end

local function get_player_params(pos)
	local main_player_text_size = 36
	local other_player_text_size = 18
	if pos == 1 then
		return {
			y_pos = board_height - CARD_SIZE - padding,
			x_pos = math.floor(board_width/2),
			square_size = SQUARE_SIZE,
			text_size = main_player_text_size,
		}
	elseif pos == 2 then
		return {
			y_pos = math.floor(board_height - 2*5*SMALL_SQUARE_SIZE)/2,
			x_pos = 5*SMALL_SQUARE_SIZE + padding,
			square_size = SMALL_SQUARE_SIZE,
			text_size = other_player_text_size,
		}
	elseif pos == 3 then
		return {
			y_pos = math.floor(board_height - 2*5*SMALL_SQUARE_SIZE)/2,
			x_pos = board_width - 5*SMALL_SQUARE_SIZE - padding,
			square_size = SMALL_SQUARE_SIZE,
			text_size = other_player_text_size,
		}
	elseif pos == 4 then
		return {
			y_pos = padding,
			x_pos = math.floor((board_width)/2),
			square_size = SMALL_SQUARE_SIZE,
			text_size = other_player_text_size,
		}
	else
		error(string.format("unhandled player pos %s", pos))
	end
	
end

local function draw_back_btn()
	draw_shapes.draw_rect_outline('#000000', 1,
	                              back_btn_y_start, back_btn_x_start,
	                              back_btn_y_end,   back_btn_x_end)
	alex_c_api.draw_rect(BTN_SELECT_BACKGROUND,
	                     back_btn_y_start, back_btn_x_start,
	                     back_btn_y_end,   back_btn_x_end)
	alex_c_api.draw_text("Back", '#000000',
	                     back_btn_y_start + (back_btn_y_end - back_btn_y_start)/2 + text_size/2,
	                     back_btn_x_start + (back_btn_x_end - back_btn_x_start)/2,
	                     text_size,
	                     0)
end

local function within_back_btn(y_pos, x_pos)
	return (back_btn_y_start <= y_pos and y_pos <= back_btn_y_end and
	        back_btn_x_start <= x_pos and x_pos <= back_btn_x_end)
end

local function get_main_player_card_params()
	local params = get_player_params(1)
	params.x_pos = params.x_pos - core.PIECE_COLOUR_COUNT * params.square_size
	return params
end

local function draw_player_state(state, params, player_idx)
	local card_params = {
		y_pos = params.y_pos,
		x_pos = params.x_pos,
		square_size = params.square_size,
	}
	draw_game_card(state, card_params, player_idx)
	local card_params = {
		highlight_rows = {},
		y_pos = params.y_pos,
		x_pos = params.x_pos - core.PIECE_COLOUR_COUNT * params.square_size,
		square_size = params.square_size,
	}

	for i=1,core.PIECE_COLOUR_COUNT do
		--if state.selected_pile ~= nil and
		if 
		   state.selected_piece_colour ~= nil then
			card_params.highlight_rows[i] = core.can_place_piece(state.game_state, player_idx, state.selected_pile, state.selected_piece_colour, i)
		else
			card_params.highlight_rows[i] = false
		end
	end
	draw_game_staging_area(state, card_params, player_idx)

	local score = state.game_state.player_states[player_idx].score
	alex_c_api.draw_text(string.format("%3d", score), '#000000',
	                     params.y_pos + params.text_size + params.square_size,
	                     params.x_pos - 3*params.square_size,
	                     params.text_size,
	                     -1)


end


local function pile_idx_to_pt(idx)
	local MAP = {
		[1] = { y=1, x=1},
		[2] = { y=1, x=2},
		[3] = { y=1, x=3},
		[4] = { y=1, x=4},
		[5] = { y=1, x=5},

		[6] = { y=2, x=1},
		[7] = { y=2, x=5},
		[8] = { y=2, x=2},
		[9] = { y=2, x=4},
	}
	if MAP[idx] == nil then
		error(string.format("pile idx %d not handled", idx))
	end

	return MAP[idx]
end

local function pile_coords_to_pos(y_start, x_start, y, x, pile_space_radius)
	local y_pos = y_start + pile_space_radius + (y-1) * 2*pile_space_radius
	local x_pos = x_start + pile_space_radius + (x-1) * 2*pile_space_radius
	return { y = y_pos, x = x_pos }
end

local function pile_idx_to_pos(idx, y_start, x_start, pile_space_radius)
	local pt = pile_idx_to_pt(idx)
	return pile_coords_to_pos(y_start, x_start, pt.y, pt.x, pile_space_radius)
end

local function piece_idx_to_pos(pile_pos, pile_params, piece_idx)
	local piece_radius = math.floor(pile_params.pile_radius*2*pile_params.piece_size_factor) - pile_params.padding - 2
	local dy = 1 + 2*(math.floor((piece_idx-1)/2) - 1)
	local dx = 1 + 2*(((piece_idx-1)%2)  - 1)
	local info = {
		radius = piece_radius,
		y = math.floor(pile_pos.y + dy * (piece_radius + pile_params.padding)),
		x = math.floor(pile_pos.x + dx * (piece_radius + pile_params.padding)),
	}
	return info
end

local function draw_pile(state, params, pile, pos, selected_colour)
	alex_c_api.draw_circle(BTN_SELECT_BACKGROUND, '#000000',
	                       pos.y, pos.x, params.pile_radius)
	if params.highlight_colour ~= nil then
		alex_c_api.draw_circle(params.highlight_colour_bg, params.highlight_colour,
		                       pos.y, pos.x, params.pile_radius + 2)
	end
	alex_c_api.draw_circle(BTN_SELECT_BACKGROUND, '#000000',
	                       pos.y, pos.x, params.pile_radius)
	for piece_idx, piece_colour_type in ipairs(pile) do
		local colour = COLOUR_MAP[piece_colour_type].filled
		local piece_pos = piece_idx_to_pos(pos, params, piece_idx)
		local highlight_colour_bg = nil
		local highlight_colour   = nil
		if state.ui_state == ui.UI_STATE_SELECT_PIECES and selected_colour == nil then
			highlight_colour_bg = HIGHLIGHT_COLOUR_BG
			highlight_colour    = HIGHLIGHT_COLOUR_OUTLINE
		elseif state.ui_state == ui.UI_STATE_SELECT_PIECES and selected_colour == piece_colour_type then
			highlight_colour_bg = SELECTED_COLOUR_BG
			highlight_colour    = SELECTED_COLOUR_OUTLINE
		end
		if highlight_colour ~= nil then
			alex_c_api.draw_circle(highlight_colour, highlight_colour,
			                       piece_pos.y, piece_pos.x,
			                       math.floor(piece_pos.radius/2))
		end
		alex_c_api.draw_circle(colour, '#000000',
		                       piece_pos.y, piece_pos.x, piece_pos.radius)
		if highlight_colour ~= nil then
			alex_c_api.draw_circle(highlight_colour_bg, highlight_colour,
			                       piece_pos.y, piece_pos.x,
			                       math.floor(piece_pos.radius/2))
		end

	end
end

local function get_discard_pile_info(params)
	local info = {
		y_start = params.y_start - params.pile_space_radius + padding,
		x_start = params.x_start - params.pile_space_radius + padding,
	}
	info.y_end = info.y_start + 2*params.pile_space_radius - 2*padding
	info.x_end = info.x_start + 2*params.pile_space_radius - 2*padding

	info.pile_space_radius  = params.pile_space_radius 
	info.pile_radius        = params.pile_radius 
	info.piece_size_factor  = params.piece_size_factor 
	info.padding            = params.padding

	return info
end

local function get_discard_piece_info(params, distinct_colours, x_idx, piece_idx)
	local discard_centre = {
		y = params.y_start + params.pile_space_radius - params.padding,
		x = params.x_start + params.pile_space_radius - params.padding,
	}
	local piece_info = piece_idx_to_pos(discard_centre, params, 1)
	discard_centre.y = discard_centre.y - piece_info.radius

	local piece_group_offset = {}
	if x_idx == 1 then
		piece_group_offset.y = 0
		piece_group_offset.x = 0
	else
		if x_idx == 2 or x_idx == 3 then
			piece_group_offset.y = -2*piece_info.radius
		elseif x_idx == 4 or x_idx == 5 then
			piece_group_offset.y = 2*piece_info.radius
		end

		if x_idx == 2 or x_idx == 4 then
			piece_group_offset.x = -2*piece_info.radius
		elseif x_idx == 3 or x_idx == 5 then
			piece_group_offset.x = 2*piece_info.radius
		end
	end

	local piece_offset_y = math.floor(piece_info.radius*2/3)

	return {
		y = discard_centre.y + piece_group_offset.y + piece_idx*piece_offset_y,
		x = discard_centre.x + piece_group_offset.x,
		radius = piece_info.radius,
	}
end

local function default_discard_pile_highlight_params()
	return {
		highlight_bg         = false,
		highlight_selectable = false,
		highlighted_colour   = nil,
	}
end

local function draw_discard_pile(state, params, highlight_params)
		local pile_info = get_discard_pile_info(params)
		if highlight_params.highlight_bg then
			alex_c_api.draw_rect(HIGHLIGHT_COLOUR_BG,
			                    pile_info.y_start, pile_info.x_start,
			                    pile_info.y_end,   pile_info.x_end)
			draw_shapes.draw_rect_outline('#000000', 1,
			                    pile_info.y_start, pile_info.x_start,
			                    pile_info.y_end,   pile_info.x_end)
			draw_shapes.draw_rect_outline(HIGHLIGHT_COLOUR_OUTLINE_TRANSPARENT, 3,
			                    pile_info.y_start, pile_info.x_start,
			                    pile_info.y_end,   pile_info.x_end)
		end
		local discarded_colours = {}
		for _, discarded_colour_type in ipairs(state.game_state.discard_pile) do
			if discarded_colours[discarded_colour_type] == nil then
				discarded_colours[discarded_colour_type] = 0
			end
			discarded_colours[discarded_colour_type] = discarded_colours[discarded_colour_type] + 1
		end
		local distinct_colours = 0
		for _, num_colours in pairs(discarded_colours) do
			distinct_colours = distinct_colours + 1
		end

		local radius = 0
		local x_idx = 1
		for colour_type, count in pairs(discarded_colours) do
			local colour = COLOUR_MAP[colour_type]
			for piece_idx=1,count do
				local discard_piece_info = get_discard_piece_info(pile_info, distinct_colours, colour_type, piece_idx)
				radius = discard_piece_info.radius
				-- I want a slight grey outline so that you can count the number of
				-- black pieces when they're stacked in the middle
				alex_c_api.draw_circle(PIECE_OUTLINE_COLOUR, PIECE_OUTLINE_COLOUR,
				                       discard_piece_info.y,
				                       discard_piece_info.x,
				                       discard_piece_info.radius)

				alex_c_api.draw_circle(colour.filled, PIECE_OUTLINE_COLOUR,
				                       discard_piece_info.y,
				                       discard_piece_info.x,
				                       discard_piece_info.radius - 1)
				local highlight_colour_bg
				local highlight_colour_outline
				if colour_type == highlight_params.highlighted_colour then
					highlight_colour_bg      = SELECTED_COLOUR_BG
					highlight_colour_outline = SELECTED_COLOUR_OUTLINE
				elseif highlight_params.highlight_selectable then
					highlight_colour_bg      = HIGHLIGHT_COLOUR_BG
					highlight_colour_outline = HIGHLIGHT_COLOUR_OUTLINE
				end
				if highlight_colour_bg ~= nil then
					alex_c_api.draw_circle(highlight_colour_bg, highlight_colour_outline,
					                       discard_piece_info.y,
					                       discard_piece_info.x,
					                       math.floor(discard_piece_info.radius/2))
				end
			end
			x_idx = x_idx + 1
		end
		if state.game_state.discard_penalty then
			local text_size = params.text_size
			local penalty_text_pos = {
				y = pile_info.y_end + text_size + radius,
				x = pile_info.x_start + math.floor((pile_info.x_end - pile_info.x_start)/2),
			}
			alex_c_api.draw_circle(PENALTY_TEXT_ICON_COLOUR_BG, PENALTY_TEXT_ICON_COLOUR_OUTLINE,
			                       penalty_text_pos.y - text_size/2,
			                       penalty_text_pos.x,
			                       text_size)
			local highlight_colour_bg      = nil
			local highlight_colour_outline = nil
			if highlight_params.highlighted_colour ~= nil then
				highlight_colour_bg      = SELECTED_COLOUR_BG
				highlight_colour_outline = SELECTED_COLOUR_OUTLINE
			end
			if highlight_colour_bg ~= nil then
				alex_c_api.draw_circle(highlight_colour_bg, highlight_colour_outline,
				                       penalty_text_pos.y - text_size/2,
				                       penalty_text_pos.x,
				                       math.floor(text_size/2))
			end

			alex_c_api.draw_text("-1", "#000000", penalty_text_pos.y, penalty_text_pos.x, text_size, 0)
		end
end

local function get_pile_params(is_big)
	local pile_space_radius
	local pile_radius
	local y_start
	local x_start
	local piece_size_factor
	local padding
	local text_size

	if is_big then
		padding = big_padding
		pile_space_radius = big_pile_space_radius
		pile_radius       = pile_space_radius - padding
		y_start = pile_select_y_start
		x_start = pile_select_x_start
		piece_size_factor = 1/5
		text_size = 18
	else
		padding = small_padding
		pile_space_radius = small_pile_space_radius 
		pile_radius       = pile_space_radius - small_padding
		y_start = view_players_select_piles_y_start
		x_start = view_players_select_piles_x_start

		piece_size_factor = 1/3
		text_size = 8
	end
	local params = {
		y_start           = y_start,
		x_start           = x_start,
		padding           = padding,
		pile_radius       = pile_radius,
		pile_space_radius = pile_space_radius,
		piece_size_factor = piece_size_factor,
		text_size         = text_size,
	}
	return params
end

local function get_discard_pile_params(is_big)
	local params = get_pile_params(is_big)
	local pos = pile_coords_to_pos(params.y_start, params.x_start, 2, 3, params.pile_space_radius)
	params.y_start = pos.y
	params.x_start = pos.x
	return params
end

-- Draws the 5-9 circles with pieces in them,
-- and the discarded pieces (with -1) if present.
--
-- Called both when:
-- * is_big=false (drawing this small),  as a button in thre centre of the screen, and
-- * is_big=true  (drawing this larger), to select individual piles
local function draw_piles(state, is_big)
	local params = get_pile_params(is_big)
	if not is_big then
		alex_c_api.draw_rect(BTN_SELECT_BACKGROUND, params.y_start, params.x_start,
		                     view_players_select_piles_y_end, view_players_select_piles_x_end)
		draw_shapes.draw_rect_outline('#000000', 1,
		                              params.y_start, params.x_start,
		                              view_players_select_piles_y_end, view_players_select_piles_x_end)
		alex_c_api.draw_rect(HIGHLIGHT_COLOUR_BG, params.y_start, params.x_start,
		                     view_players_select_piles_y_end, view_players_select_piles_x_end)
		draw_shapes.draw_rect_outline(HIGHLIGHT_COLOUR_OUTLINE, 3,
		                              params.y_start, params.x_start,
		                              view_players_select_piles_y_end, view_players_select_piles_x_end)
	end
	local tmp_info = get_discard_piece_info(params, 1, 1, 1)
	params.piece_radius = params
	for i, pile in pairs(state.game_state.piles) do
		local pos = pile_idx_to_pos(i, params.y_start, params.x_start, params.pile_space_radius)
			
		if state.ui_state == ui.UI_STATE_SELECT_PILE then
			params.highlight_colour    = HIGHLIGHT_COLOUR_OUTLINE
			params.highlight_colour_bg = HIGHLIGHT_COLOUR_BG
		end
		draw_pile(state, params, pile, pos)
	end

	if #state.game_state.discard_pile > 0 then
		local params = get_discard_pile_params(is_big)
		local highlight_params = default_discard_pile_highlight_params()
		if state.ui_state == ui.UI_STATE_SELECT_PILE then
			highlight_params.highlight_bg = true
		end
		draw_discard_pile(state, params, highlight_params)
	end
end

local function draw_player_states(state)
	alex_c_api.draw_clear()

	for player_idx, _ in ipairs(state.game_state.player_states) do
		local player_pos = player_idx -- TODO
		local params = get_player_params(player_pos)
		draw_player_state(state, params, player_idx)
	end
	draw_piles(state, false)
end

local function get_discard_piece_count(game_state, colour_type)
	local count = 0
	for _, discard_piece_colour in ipairs(game_state.discard_pile) do
		if colour_type == discard_piece_colour then
			count = count + 1
		end
	end
	return count
end

local function within_circle_bounding_box(circle_info, pos_y, pos_x)
	return (circle_info.y - circle_info.radius <= pos_y and pos_y <= circle_info.y + circle_info.radius and
	        circle_info.x - circle_info.radius <= pos_x and pos_x <= circle_info.x + circle_info.radius)
end

local function get_player_row_selected(y_pos, x_pos)
	for row_idx=1,core.PIECE_COLOUR_COUNT do
		local params = get_main_player_card_params()
		local row_info = get_game_staging_row_info(params, row_idx)
		if row_info.y_start <= y_pos and y_pos <= row_info.y_end and
		   row_info.x_start <= x_pos and x_pos <= row_info.x_end then
			return row_idx
		end
	end
end

function draw.pos_to_action(state, y_pos, x_pos)
	if state.ui_state == ui.UI_STATE_VIEW_OTHER_PLAYERS then
		y_start = view_players_select_piles_y_start
		x_start = view_players_select_piles_x_start
		y_end   = view_players_select_piles_y_end
		x_end   = view_players_select_piles_x_end

		if y_start <= y_pos and y_pos <= y_end and
		   x_start <= x_pos and x_pos <= x_end then
			return {
				action         = ui.ACTION_CHANGE_UI_STATE,
				action_arg_idx = ui.UI_STATE_SELECT_PILE,
			}
		end
	elseif state.ui_state == ui.UI_STATE_SELECT_PILE then
		if within_back_btn(y_pos, x_pos) then
			return {
				action         = ui.ACTION_CHANGE_UI_STATE,
				action_arg_idx = ui.UI_STATE_VIEW_OTHER_PLAYERS,
			}
		end
		for i, pile in pairs(state.game_state.piles) do
			local pos = pile_idx_to_pos(i, pile_select_y_start, pile_select_x_start, big_pile_space_radius)
			if pos.y - big_pile_space_radius <= y_pos and y_pos <= pos.y + big_pile_space_radius and
			   pos.x - big_pile_space_radius <= x_pos and x_pos <= pos.x + big_pile_space_radius then
				return {
					action         = ui.ACTION_SELECT_PILE,
					action_arg_idx = i,
				}
			end
		end

		if #state.game_state.discard_pile > 0 then
			local tmp_params = get_discard_pile_params(get_pile_params(true))
			local discard_pile_info = get_discard_pile_info(tmp_params)
			if discard_pile_info.y_start <= y_pos and y_pos <= discard_pile_info.y_end and
			   discard_pile_info.x_start <= x_pos and x_pos <= discard_pile_info.x_end then
				return {
						action         = ui.ACTION_SELECT_DISCARD_PILE,
						action_arg_idx = nil,
				}
			end
		end
	elseif state.ui_state == ui.UI_STATE_SELECT_PIECES then
		if within_back_btn(y_pos, x_pos) then
			return {
				action         = ui.ACTION_CHANGE_UI_STATE,
				action_arg_idx = ui.UI_STATE_SELECT_PILE,
			}
		end

		for piece_idx, piece_colour_type in ipairs(state.game_state.piles[state.selected_pile]) do
			local piece_pos = piece_idx_to_pos(piece_select_pile_pos, piece_select_pile_params, piece_idx)
			if piece_pos.y - piece_pos.radius <= y_pos and y_pos <= piece_pos.y + piece_pos.radius and
			   piece_pos.x - piece_pos.radius <= x_pos and x_pos <= piece_pos.x + piece_pos.radius then
				return {
					action = ui.ACTION_SELECT_PIECE,
					action_arg_idx = piece_colour_type,
				}
			end
		end

		local selected_row_idx = get_player_row_selected(y_pos, x_pos)
		if selected_row_idx ~= nil then
			return {
				action         = ui.ACTION_PLACE_PIECE,
				action_arg_idx = selected_row_idx,
			}
		end
	elseif state.ui_state == ui.UI_STATE_SELECT_DISCARDED_PIECES then
		if within_back_btn(y_pos, x_pos) then
			return {
				action         = ui.ACTION_CHANGE_UI_STATE,
				action_arg_idx = ui.UI_STATE_SELECT_PILE,
			}
		end

		local idx = 1
		for _, colour_type in pairs(core.PIECES) do
			for same_piece_idx=1,get_discard_piece_count(state.game_state, colour_type) do
	
				local pile_info = get_discard_pile_info(discard_pile_params)
				local discard_piece_info = get_discard_piece_info(pile_info, core.PIECE_COLOUR_COUNT, colour_type, same_piece_idx)
				if within_circle_bounding_box(discard_piece_info, y_pos, x_pos) then
					return {
						action         = ui.ACTION_SELECT_DISCARD_PIECE_COLOUR,
						action_arg_idx = colour_type,
					}
				end
			end
			idx = idx + 1
		end

		local selected_row_idx = get_player_row_selected(y_pos, x_pos)
		if selected_row_idx ~= nil then
			return {
				action         = ui.ACTION_PLACE_PIECE,
				action_arg_idx = selected_row_idx,
			}
		end

	end

	return nil
end

function draw.draw_state(state, player)
	-- alex_c_api.draw_rect('#ffffff', 0, 0, 480, 480)
	alex_c_api.draw_clear()
	if state.ui_state == ui.UI_STATE_VIEW_OTHER_PLAYERS then
		draw_player_states(state)
	elseif state.ui_state == ui.UI_STATE_SELECT_PILE then
		draw_piles(state, true)
		local params = get_player_params(1)
		draw_player_state(state, params, player)
		draw_back_btn()
	elseif state.ui_state == ui.UI_STATE_SELECT_PIECES then
		local pile = state.game_state.piles[state.selected_pile]
		draw_pile(state, piece_select_pile_params, pile, piece_select_pile_pos, state.selected_piece_colour)

		local params = get_player_params(1)
		draw_player_state(state, params, player)

		draw_back_btn()
	elseif state.ui_state == ui.UI_STATE_SELECT_DISCARDED_PIECES then
		local params = get_player_params(1)
		draw_player_state(state, params, player)

		local highlight_params = default_discard_pile_highlight_params()
		highlight_params.highlight_selectable = (state.selected_piece_colour == nil)
		highlight_params.highlighted_colour = state.selected_piece_colour
		draw_discard_pile(state, discard_pile_params, highlight_params)

		draw_back_btn()
	else
		error(string.format("Unhandled ui state %s", state.ui_state))
	end
	alex_c_api.draw_refresh()
end

return draw

--[[
-- TODO:
--  * draw player names (or just "Player 1" for now) by each game card
--  * change player turn
--  * on end of turn, commit pieces from staging area to card if possible, calculate points
--  * implement state serialization for network multiplayer
--  * use save state API
--]]


local ui   = require("games/blue/blue_ui")
local core = require("games/blue/blue_core")
local draw = require("games/blue/blue_draw")

local g_game_state = core.new_game(4)
local g_ui_state   = ui.new_state(g_game_state)

local function get_player()
	return 1 -- TODO
end

function draw_board()
	draw.draw_state(g_ui_state, get_player())
end

function handle_user_clicked(y_pos, x_pos)
	local click_info = draw.pos_to_action(g_ui_state, y_pos, x_pos)
	if click_info ~= nil then
		print(string.format("User clicked { action=%s, arg=%s }", click_info.action, click_info.action_arg_idx))
		local rc = ui.handle_action(g_ui_state, get_player(), click_info.action, click_info.action_arg_idx)
		draw_board()
	end
end
	
local ui = {}

local core = require("games/blue/blue_core")

local alex_c_api = require("alex_c_api")

ui.UI_STATE_VIEW_OTHER_PLAYERS = 1
ui.UI_STATE_SELECT_PILE        = 2
ui.UI_STATE_SELECT_PIECES      = 3
ui.UI_STATE_SELECT_DISCARDED_PIECES = 4
--ui.UI_STATE_PLACE_PIECES       = 4

ui.ACTION_CHANGE_UI_STATE      = 1
ui.ACTION_SELECT_PILE          = 2
ui.ACTION_SELECT_PIECE         = 3
ui.ACTION_PLACE_PIECE          = 4
ui.ACTION_SELECT_DISCARD_PILE  = 5
ui.ACTION_SELECT_DISCARD_PIECE_COLOUR = 6

function ui.new_state(game_state)
	return {
		game_state = game_state,
		ui_state              = ui.UI_STATE_VIEW_OTHER_PLAYERS,
		selected_pile         = nil,
		selected_piece_colour = nil,
	}
end

local function get_status_msg(state)
	if state.ui_state == ui.UI_STATE_VIEW_OTHER_PLAYERS then
		return "Select the piles when ready"
	elseif state.ui_state == ui.UI_STATE_SELECT_PILE then
		return "Select a pile"
	elseif state.ui_state == ui.UI_STATE_SELECT_PIECES then
		if state.selected_piece_colour == nil then
			return "Select a piece colour"
		else
			return "Select a destination row"
		end
	else
		return nil
	end
end

function ui.handle_action(ui_state, player, action, action_arg_idx)
	-- TODO consider clearing "selected_pile" and "selected_piece_colour" when back button is pressed
	if action == ui.ACTION_CHANGE_UI_STATE then
		ui_state.ui_state = action_arg_idx
		ui_state.selected_pile         = nil
		ui_state.selected_piece_colour = nil
	elseif action == ui.ACTION_SELECT_PILE then
		ui_state.ui_state = ui.UI_STATE_SELECT_PIECES
		ui_state.selected_pile = action_arg_idx
	elseif action == ui.ACTION_SELECT_DISCARD_PILE then
		ui_state.ui_state = ui.UI_STATE_SELECT_DISCARDED_PIECES
		ui_state.selected_pile = nil
	elseif action == ui.ACTION_SELECT_PIECE then
		--ui_state.ui_state = ui.UI_STATE_PLACE_PIECES
		ui_state.selected_piece_colour = action_arg_idx
	elseif action == ui.ACTION_PLACE_PIECE then
		local selected_pile
		if ui_state.ui_state == ui.UI_STATE_SELECT_PIECES then
			selected_pile = ui_state.selected_pile
		elseif ui_state.ui_state == ui.UI_STATE_SELECT_DISCARDED_PIECES then
			selected_pile = core.PILE_DISCARD
		end
		local rc = core.place_piece(ui_state.game_state, player,
		                            selected_pile, ui_state.selected_piece_colour, action_arg_idx)
		if rc == core.RC_SUCCESS then
			ui_state.ui_state              = ui.UI_STATE_VIEW_OTHER_PLAYERS
			ui_state.selected_pile         = nil
			ui_state.selected_piece_colour = nil
		else
			alex_c_api.set_status_err(core.rc_to_string(rc))
			return
		end
	elseif action == ui.ACTION_SELECT_DISCARD_PIECE_COLOUR then
		ui_state.selected_piece_colour = action_arg_idx
		print(string.format("set selected piece colour to %s", ui_state.selected_piece_colour))
	else
		error(string.format("unhandled action %s", action))
	end

	alex_c_api.set_status_msg(get_status_msg(ui_state))
	
end

return ui
local core = {}

local PLAYER_MOVE_SPEED = 3.0/1000

core.ITEM_ID_PLAYER         =  1
core.ITEM_ID_PATIENT_IN_BED =  2
core.ITEM_ID_PATIENT_IN_BED_FLIPPED = 3
core.ITEM_ID_BED            =  4
core.ITEM_ID_BED_FLIPPED    =  5
core.ITEM_ID_BED_SEGMENT_2  =  6
core.ITEM_ID_IV_BAG         =  7
core.ITEM_ID_DEFIB          =  8
core.ITEM_ID_VENTILATOR     =  9
core.ITEM_ID_XRAY_SHEET     = 10
core.ITEM_ID_XRAY_SOURCE    = 11

core.NEEDS_LOW_FLUIDS   = 1
core.NEEDS_LOW_OXYGEN   = 2
core.NEEDS_NO_HEARTBEAT = 3
core.NEEDS_BROKEN_BONE  = 4


core.ACTION_DIR_PAD_POS_CHANGE  = 1
core.ACTION_USE_BTN_DOWN        = 2
core.ACTION_USE_BTN_RELEASE     = 3
core.ACTION_DROP_BTN_DOWN       = 4
core.ACTION_DROP_BTN_RELEASE    = 5

core.USING_ACTION_REVEAL_NEEDS = 1
core.USING_ACTION_LOW_FLUIDS   = 2
core.USING_ACTION_DEFIB        = 3
core.USING_ACTION_VENTILATOR   = 4
core.USING_ACTION_PICK_UP_PATIENT = 5
core.USING_ACTION_PUT_PATIENT_IN_BED = 6

core.EVT_PATIENT_NEED_EXPIRED = 1
core.EVT_PATIENT_CURED        = 2

core.USE_PROGRESS_MAX = 100

local TIME_TO_REVEAL_NEEDS    = 1.0
local TIME_TO_PICK_UP_PATIENT = 0.7

local NEED_LIST = {
	core.NEEDS_LOW_FLUIDS,
	core.NEEDS_NO_HEARTBEAT,
	core.NEEDS_LOW_OXYGEN,
	core.NEEDS_BROKEN_BONE,
}

local NEEDS_TO_USE_TIME_MAP = {
	[core.NEEDS_LOW_FLUIDS]   = 2.5,
	[core.NEEDS_NO_HEARTBEAT] = 1.5,
	[core.NEEDS_LOW_OXYGEN]   = 2.5,
}

local NEED_TO_BED_FIX_TIME_MS = {
	[core.NEEDS_BROKEN_BONE] = 20*1000,
}


local NEEDS_TO_ITEMS_MAP = {
		[core.NEEDS_LOW_FLUIDS]    = { core.ITEM_ID_IV_BAG     },
		[core.NEEDS_NO_HEARTBEAT]  = { core.ITEM_ID_DEFIB      },
		[core.NEEDS_LOW_OXYGEN]    = { core.ITEM_ID_VENTILATOR },
		[core.NEEDS_BROKEN_BONE]   = { },
}

local ITEMS_DROPPED_ON_USE_MAP = {
	[core.ITEM_ID_IV_BAG] = true,
	[core.ITEM_ID_VENTILATOR] = true,
}

-- These seem good for one player...
-- rough ideas, should be sum of:
--    * time to reveal max-ish number of patients that could reasonably need to have
--      their needs revealed at any given time, plus
--    * time to walk halfway across the map, plus
--    * time to fix patient with equipment 
local NEED_TYPE_TO_TIME_LEFT = {
	[core.NEEDS_LOW_FLUIDS]   = 60,
	[core.NEEDS_NO_HEARTBEAT] = 25,
	[core.NEEDS_LOW_OXYGEN]   = 40,
	[core.NEEDS_BROKEN_BONE]  = 90,
}


local DIRS = {
	{ y =  1, x =  0 },
	{ y =  1, x = -1 },
	{ y =  0, x = -1 },
	{ y = -1, x = -1 },
	{ y = -1, x =  0 },
	{ y = -1, x =  1 },
	{ y =  0, x =  1 },
	{ y =  1, x =  1 },
}

local PICK_UP_ITEMS = {
	[core.ITEM_ID_IV_BAG]     = true,
	[core.ITEM_ID_DEFIB]      = true,
	[core.ITEM_ID_VENTILATOR] = true,
}


local function get_player_starting_pos(i)
	--[[
	local map = {
		[1] = { y = 2.5, x = 2.5 },
		[2] = { y = 7.5, x = 7.5 },
		[3] = { y = 7.5, x = 2.5 },
		[4] = { y = 2.5, x = 7.5 },
	}
	]]

	local map = {
		--[1] = { y = 2.5, x = 5.0 },
		--[2] = { y = 7.5, x = 5.0 },
		--[3] = { y = 5.0, x = 2.5 },
		--[4] = { y = 5.0, x = 7.5 },
		[1] = { y = 13, x = 1 },
		[2] = { y = 13, x = 3 },
		[3] = { y = 13, x = 5 },
		[4] = { y = 13, x = 7 },
	}
	return map[i]
end

local function new_item(id)
	return {
		id = id,
	}
end

local function new_bed(id, fixes_needs)
	local item = new_item(id)
	if not core.is_bed(item) then
		error(string.format("Item id %s is not bed", id), 2)
	end
	item.fixes_needs = fixes_needs
	return item
end

local needs_type_debug = 0


function core.is_patient(item_info)
	if item_info == nil then
		error("arg is nil", 2)
	end
	return item_info.id == core.ITEM_ID_PATIENT_IN_BED or
	       item_info.id == core.ITEM_ID_PATIENT_IN_BED_FLIPPED
end

function core.is_player(item_info)
	return item_info.id == core.ITEM_ID_PLAYER
end

function core.is_bed(item_info)
	return item_info.id == core.ITEM_ID_BED or
	       item_info.id == core.ITEM_ID_BED_FLIPPED
end

local function new_patient(y, x)
	needs_type_debug = needs_type_debug + 1
	return {
		id = core.ITEM_ID_PATIENT_IN_BED,
		y = y,
		x = x,

		requires_help  = false,
		needs_revealed = false,
		needs_type     = needs_type_debug,

		time_left      = nil,
		orig_time_left = nil,

		held_by        = nil,
	}
end

local function set_patient_need(patient, need_type)
	patient.requires_help  = true
	patient.needs_revealed = false
	patient.needs_type     = need_type
	patient.time_left      = NEED_TYPE_TO_TIME_LEFT[need_type]
	patient.orig_time_left = NEED_TYPE_TO_TIME_LEFT[need_type]
end

local function bad_row(row)
	return function (y, x)
		if row == y then return 2 
		else return 1 end
	end
end

local function combine(func1, func2)
	return function (y, x)
		if func1(y,x) > func2(y,x) then return func1(y,x)
		else return func2(y,x) end
	end
end

--[[
pattern = {
	combine( bad_row(9), bad_row(8) ),
	combine( bad_row(7), bad_row(6) ),
	combine( bad_row(5), bad_row(4) ),
	combine( bad_row(3), bad_row(2) ),
	combine( bad_row(1), bad_row(0) ),
}

]]

local function reset_step(state)
	state.time_to_step = state.step_time
	state.step = 0
end

local function between(lower, val, upper)
	return lower <= val and val < upper
end

local function load_level1(state)

	state.tile_bad_levels = {
		 function (y,x, step)
			step = (10 - step - 1) % 12
			return y == step
		end,

		function (y,x,step)
			local val = (4 <= y and y <= 5) or
				        (4 <= x and x <= 5)
			step = step % 12
			if step < 3 then
				return false
			elseif step < 6 then
				return val
			elseif step < 9 then
				return false
			else
				return not val
			end
		end,

		function (y,x,step)
			step = step % 12
			return x == step
		end,

		--   0 1 2 3 4 5 6 7 8 9
		-- 0 a a . . . . . . . . 
		-- 1 a a . . . . . . . . 
		-- 2 . . b b . . . . . . 
		-- 3 . . b b . . . . . . 
		-- 4 . . . . c c . . . . 
		-- 5 . . . . c c . . . . 
		-- 6 . . . . . . b b . . 
		-- 7 . . . . . . b b . . 
		-- 8 . . . . . . . . a a 
		-- 9 . . . . . . . . a a 

		function (y,x,step)
			step = math.floor((step % 6)/2)
			if step == 0 then
				return (0 <= y and y <= 1 or  8 <= y and y <= 9) and
				       (0 <= x and x <= 1 or  8 <= x and x <= 9)
			elseif step == 1 then
				return (2 <= y and y <= 3 or 6 <= y and y <=  7) and
				       (2 <= x and x <= 3 or 6 <= x and x <=  7)
			elseif step == 2 then
				return (4 <= y and y <= 5 and
				       4 <= x and x <= 5)
			else
				return false
			end
		end,

		function (y,x,step)
			step = step % 8
			if step < 1 then
				return between(0,y,2) or between(8,y,10)
			elseif step < 2 then
				return between(2,y,4) or between(6,y,8)
			elseif step < 4 then
				return false
			elseif step < 6 then
				return between(4,y,6)
			else
				return false
			end
		end,

		function (y,x,step)
			step = step % 14
			if step < 5 then return between(2*step,y,2*step+2) and between(2*step, x, 2*step+2)
			elseif step < 10 then
				step = step - 5
				return between(2*step, y,2*step+2) and between(2*step, 10 - x-1, 2*step+2)
			elseif step < 12 then
				return between(2,y,4) and between(2,x,9) or
				       between(7,y,9) and between(2,x,9) or
				       between(2,x,4) and between(2,y,9) or
				       between(7,x,9) and between(2,y,9)
			end
		end
	}

	local level_map = {
		--0  1  2  3  4  5  6  7  8  9
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  0
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  1
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  2
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  3
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  4
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  5
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  6
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  7
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  8
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   --  9
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   -- 10
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   -- 11
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   -- 13
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, },   -- 14
		--{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   -- 0
		--{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   -- 1
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 2
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 3
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 4
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 5
	}

	state.y_size = #level_map
	state.x_size = #level_map[1]

	for row_idx, row in ipairs(level_map) do
		local y = row_idx-1
		state.cells[y] = {}
		for col_idx, cell in ipairs(row) do
			local x = col_idx-1
			if level_map[row_idx][col_idx] == 1 then
				state.cells[y][x] = {}
			end
		end
	end

	state.step_time = 300
	reset_step(state)
	state.tile_bad_level_idx = 1
	state.tile_bad = function(y,x)
		local step = state.step
		if y >= 12 or y < 2 then return false
		else
			y = y - 2
			return state.tile_bad_levels[state.tile_bad_level_idx](y,x,step)
		end
	end

	state.tile_win = function (y,x)
		return y <= 1
	end

	local level_items = {
	}

	for _, item_info in ipairs(level_items) do
		if core.is_patient(item_info.item) then
			local patient_info = new_patient(item_info.y, item_info.x)
			table.insert(state.patients, patient_info)
			table.insert(state.cells[item_info.y][item_info.x], patient_info)
		else
			table.insert(state.cells[item_info.y][item_info.x], item_info.item)
		end
	end

	--set_patient_need(state.patients[1], core.NEEDS_BROKEN_BONE)
	--set_patient_need(state.patients[2], core.NEEDS_LOW_FLUIDS)
end

local function add_player(state, player_idx, pos_y, pos_x)
	local player_item = new_item(core.ITEM_ID_PLAYER)
	player_item.player_idx = player_idx
	table.insert(state.cells[math.floor(pos_y)][math.floor(pos_x)], player_item)
	state.players[player_idx] = {
		y = pos_y,
		x = pos_x,
		vel_y = 0,
		vel_x = 0,
		use_btn_down  = false,
		drop_btn_down = false,
		holding = nil,
		is_using = false,
		use_progress = 0,
		use_time     = nil,
	}
end

function core.init(game_params)
	local state = {
		y_size  = game_params.y_size,
		x_size  = game_params.x_size,
		cells   = {},
		patients = {},
		players = {},

		-- 15 seconds was a bit too hard for just one player
		new_sickness_period = 18*1000,
		time_to_new_sickness  = nil,
		new_sickness_count    = 2,
	}
	state.time_to_new_sickness = state.new_sickness_period

	-- print("loading level 1...")
	load_level1(state)


	for i=1,game_params.num_players do
		local pos = get_player_starting_pos(i)
		add_player(state, i, pos.y, pos.x)
	end


	return state
end

function core.handle_player_dirpad_update(state, player, vec_y, vec_x)

	if vec_y ~= 0 or vec_x ~= 0 then
		-- TODO could probably simplify this with a trig identity?
		local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)
		local angle = math.atan(vec_y, vec_x)
		angle = angle - math.pi/4
		
		vec_y = mag * math.sin(angle)
		vec_x = mag * math.cos(angle)
	end

	state.players[player].vel_y = vec_y * PLAYER_MOVE_SPEED
	state.players[player].vel_x = vec_x * PLAYER_MOVE_SPEED
end

function core.handle_player_use_btn(state, player, btn_down)
	local player_state = state.players[player]
	player_state.use_btn_down = btn_down
	if btn_down then
		return core.use_start(state, player)
	else
		return core.use_stop(state, player)
	end
end

function core.handle_player_drop_btn(state, player, btn_down)
	local player_state = state.players[player]
	player_state.drop_btn_down = btn_down
	if btn_down then
		if player_state.holding ~= nil and
		   not core.is_patient(player_state.holding) then
			core.drop_item(state, player)
		end
	end
end

local function clip_min_max(min_val, max_val, val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end

local function is_collision(state, player_idx, tentative_y, tentative_x)
	local tentative_y_idx = math.floor(tentative_y)
	local tentative_x_idx = math.floor(tentative_x)

	-- If we'are already in this cell-- let the player walk through it to escape.
	-- Otherwise they would be completely trapped
	if tentative_y_idx == math.floor(state.players[player_idx].y) and
	   tentative_x_idx == math.floor(state.players[player_idx].x) then
		return false
	end

	if state.cells[tentative_y_idx] == nil or
	   state.cells[tentative_y_idx][tentative_x_idx] == nil then
		return true
	elseif #state.cells[tentative_y_idx][tentative_x_idx] == 0 then
		return false
	elseif #state.cells[tentative_y_idx][tentative_x_idx] == 1 then
		local item_info = state.cells[tentative_y_idx][tentative_x_idx][1]
		return not (item_info.id == core.ITEM_ID_PLAYER and item_info.player_idx == player_idx)
	else
		-- more than one item in dst, so must be collision
		return true
	end
		
end

local function move_player(state, player_idx, pos_y, pos_x)
	local player_state = state.players[player_idx]
	local old_y_idx = math.floor(player_state.y)
	local old_x_idx = math.floor(player_state.x)
	local new_y_idx = math.floor(pos_y)
	local new_x_idx = math.floor(pos_x)
	player_state.y = pos_y
	player_state.x = pos_x

	if old_y_idx ~= new_y_idx or
	   old_x_idx ~= new_x_idx then
		local old_cell = state.cells[old_y_idx][old_x_idx]
		local player_tbl_idx = nil
		for idx, item_info in ipairs(old_cell) do
			if item_info.id == core.ITEM_ID_PLAYER and item_info.player_idx == player_idx then
				player_tbl_idx = idx
				goto found_elem
			end
		end
		::found_elem::

		local item_info = table.remove(old_cell, player_tbl_idx)
		table.insert(state.cells[new_y_idx][new_x_idx], item_info)
	end
end

local function player_can_move(player_state)
	return not player_state.is_using
end

local function player_died(state, player_idx)
	local pos = get_player_starting_pos(player_idx)
	move_player(state, player_idx, pos.y, pos.x)
end

function core.update_state(state, dt)
	local events = {}
	for player_idx, player_state in ipairs(state.players) do

		if player_can_move(player_state) then
			local tentative_y = player_state.y + player_state.vel_y * dt
			local tentative_x = player_state.x + player_state.vel_x * dt

			-- Try to move to the new position.
			-- If it is blocked, try moving in just the y direction, or just the x direction
			if not is_collision(state, player_idx, tentative_y, tentative_x) then
				move_player(state, player_idx, tentative_y, tentative_x)
				player_state.y = tentative_y
				player_state.x = tentative_x
			elseif not is_collision(state, player_idx, tentative_y, player_state.x) then
				move_player(state, player_idx, tentative_y, player_state.x)
				player_state.y = tentative_y
			elseif not is_collision(state, player_idx, player_state.y, tentative_x) then
				move_player(state, player_idx, player_state.y, tentative_x)
				player_state.x = tentative_x
			end
		end

		if player_state.is_using then
			player_state.use_progress = player_state.use_progress + (dt/1000.0/player_state.use_time)*core.USE_PROGRESS_MAX
			if player_state.use_progress >=	core.USE_PROGRESS_MAX then
				player_state.use_progress = core.USE_PROGRESS_MAX
				core.on_use_complete_func(state, player_idx, events)
			end
		end
	end

	for _, patient in ipairs(state.patients) do
		if patient.requires_help then
			if patient.fix_time ~= nil then
				patient.fix_time = patient.fix_time - dt
				if patient.fix_time <= 0 then
					table.insert(events, {
						event = core.EVT_PATIENT_CURED,
						patient = patient,
					})
					patient.requires_help  = false
					patient.needs_revealed = false
					patient.needs_type     = nil
					patient.time_left      = nil
					patient.orig_time_left = nil
					patient.fix_time       = nil
					patient.orig_fix_time  = nil
					goto next_patient
				end
				
			end
			patient.time_left = patient.time_left - dt / 1000.0
			if patient.time_left <= 0 then
				patient.time_left = 0
				table.insert(events, {
					event = core.EVT_PATIENT_NEED_EXPIRED,
					patient = patient,
				})
				patient.requires_help  = false
				patient.needs_revealed = false
				patient.needs_type     = nil
				patient.time_left      = nil
				patient.orig_time_left = nil
				patient.fix_time       = nil
				patient.orig_fix_time  = nil
			end
		end
		::next_patient::
	end

	state.time_to_new_sickness = state.time_to_new_sickness - dt
	if state.time_to_new_sickness <= 0 then
		state.time_to_new_sickness = state.new_sickness_period
		local healthy_patients = {}
		for _, patient in ipairs(state.patients) do
			if not patient.requires_help then
				table.insert(healthy_patients, patient)
			end
		end
		for _=1,state.new_sickness_count do
			if #healthy_patients > 0 then
				local idx = math.random(#healthy_patients)
				set_patient_need(healthy_patients[idx], NEED_LIST[math.random(#NEED_LIST)])
				table.remove(healthy_patients, idx)
			end
		end
	end


	state.time_to_step = state.time_to_step - dt
	if state.time_to_step <= 0 then
		state.time_to_step = state.step_time
		state.step = state.step + 1
	end

	for player_idx, player in ipairs(state.players) do
		if state.tile_bad(math.floor(player.y), math.floor(player.x)) then
			player_died(state, player_idx)
		end
	end

	local advance_to_next_level = true
	for player_idx, player in ipairs(state.players) do
		if not state.tile_win(player.y, player.x) then
			advance_to_next_level = false
		end
	end

	if advance_to_next_level then
		state.tile_bad_level_idx = 1 + ((state.tile_bad_level_idx) % #state.tile_bad_levels)
		reset_step(state)
		for player_idx, player in ipairs(state.players) do
			local pos = get_player_starting_pos(player_idx)
			move_player(state, player_idx, pos.y, pos.x)
		end
	end

	return events
end

function core.get_item_needs_type(item_id)
	local map = {
		[core.ITEM_ID_IV_BAG]        = core.NEEDS_LOW_FLUIDS,
		[core.ITEM_ID_DEFIB]         = core.NEEDS_NO_HEARTBEAT,
		[core.ITEM_ID_VENTILATOR]    = core.NEEDS_LOW_OXYGEN,

	}
	return map[item_id]
end

local function in_range_coords(state, y, x)
	return state.cells[y] ~= nil and state.cells[y][x] ~= nil
end

local function item_id_can_be_picked_up(item_id)
	return PICK_UP_ITEMS[item_id] == true
end


local function ary_contains(ary, elem)
	for _, val in ipairs(ary) do
		if val == elem then return true end
	end
	return false
end

local function patient_can_be_interacted(player_state, patient_info)
	if patient_info.requires_help then
		if not patient_info.needs_revealed then
			return true
		else
			if player_state.holding ~= nil and
			       ary_contains(NEEDS_TO_ITEMS_MAP[patient_info.needs_type], player_state.holding.id) then
				return true
			elseif patient_info.needs_type == core.NEEDS_BROKEN_BONE and
			       -- don't let the player pick up a patient if they are already holding one...
			       -- unless the patients should be swapped? That might be an option in the future
			       (player_state.holding == nil or not core.is_patient(player_state.holding)) then
				return true
			end
		end
	end
	if player_state.holding == nil then
		-- can always pick up patients to move them around
		return true
	end

	return false
end

local function item_id_can_be_interacted(player_state, item_info)
	if item_id_can_be_picked_up(item_info.id) then
		return true
	end

	if core.is_patient(item_info) then
		return patient_can_be_interacted(player_state, item_info)
	end

	if core.is_bed(item_info) and
	   player_state.holding ~= nil and
	   core.is_patient(player_state.holding) then
		return true
	end

	return false
end

local function get_interact_in_cell_idx(state, player_idx, y, x)
	for idx, item in ipairs(state.cells[y][x]) do
		if item_id_can_be_interacted(state.players[player_idx], item) then
			return idx
		end
	end
	return nil
end

local function calc_dist(player_state, y, x)
	local dy = player_state.y - y
	local dx = player_state.x - x
	return math.sqrt( dy*dy + dx*dx )
end

function core.get_closest_item_cell(state, player_idx)
	local player_state = state.players[player_idx]
	local y, x = math.floor(player_state.y), math.floor(player_state.x)

	if in_range_coords(state, y, x) then
		local item_idx = get_interact_in_cell_idx(state, player_idx, y, x)

		if item_idx ~= nil then
			return { y = y, x = x }
		end
	end

	local min_dist = nil
	local closest_cell = nil
	for _, dir in ipairs(DIRS) do
		local y2 = y + dir.y
		local x2 = x + dir.x
		if not in_range_coords(state, y2, x2) then
			goto next_dir
		end
		local item_idx = get_interact_in_cell_idx(state, player_idx, y2, x2)

		if item_idx ~= nil then
			local dist = calc_dist(player_state, y2, x2)
			if min_dist == nil or dist < min_dist then
				min_dist = dist
				closest_cell = { y = y2, x = x2 }
			end
		end
		::next_dir::
	end

	return closest_cell
end

function core.get_patient_pos(patient_info)
	if patient_info.held_by == nil then
		return { y = patient_info.y, x = patient_info.x }
	else
		return { y = patient_info.held_by.y,
		         x = patient_info.held_by.x }
	end
end

function core.get_cells_to_highlight(state)
	local cells_to_highlight = {}

	local items_to_highlight = {}

	for _, patient_info in ipairs(state.patients) do
		if patient_info.requires_help and patient_info.held_by == nil then
			if not patient_info.needs_revealed or 
			   patient_info.needs_type == core.NEEDS_BROKEN_BONE then
				
				local pt = core.get_patient_pos(patient_info)
				if pt.y == nil or pt.x == nil then
					error(string.format("received nil coords, %s", patient_info.held_by) )
				end
				table.insert(cells_to_highlight, pt)
			else
				for _, item in ipairs(NEEDS_TO_ITEMS_MAP[patient_info.needs_type]) do
					items_to_highlight[item] = true
				end
			end
		end
	end

	for y, row in pairs(state.cells) do
		for x, cell in pairs(row) do
			for _, item in ipairs(cell) do
				if items_to_highlight[item.id] then
					table.insert(cells_to_highlight, { y = y, x = x })
					goto next_cell
				end
			end
			::next_cell::
		end
	end

	return cells_to_highlight
end

local function get_item_idx_can_be_picked_up(state, cell)
	for cell_item_idx, item_info in ipairs(state.cells[cell.y][cell.x]) do
		if item_id_can_be_picked_up(item_info.id) then
			return cell_item_idx
		end
	end
	return nil
end

function core.pick_up_item(state, player_idx)
	local cell = core.get_closest_item_cell(state, player_idx)
	if cell == nil then
		return false
	else
		local cell_pick_up_item_idx = get_item_idx_can_be_picked_up(state, cell)
		state.players[player_idx].holding = table.remove(state.cells[cell.y][cell.x], cell_pick_up_item_idx)
		
	end
end

function core.drop_item(state, player_idx, drop_pt)
	local player_state = state.players[player_idx]
	if drop_pt == nil then
		drop_pt = {
			y = math.floor(player_state.y),
			x = math.floor(player_state.x),
		}
	end
	local cell = state.cells[drop_pt.y][drop_pt.x]
	table.insert(cell, player_state.holding)
	player_state.holding = nil
end

local function id_is_patient(info_id)
	return info_id == core.ITEM_ID_PATIENT_IN_BED or
	       info_id == core.ITEM_ID_PATIENT_IN_BED_FLIPPED
end

local function get_patient_in_cell(state, cell)
	for _, info in ipairs(state.cells[cell.y][cell.x]) do
		if id_is_patient(info.id) then
			return info
		end
	end
	return nil
end

local function needs_type_to_using_action(needs_type)
	local map = {
		[core.NEEDS_LOW_FLUIDS]   = core.USING_ACTION_LOW_FLUIDS,
		[core.NEEDS_LOW_OXYGEN]   = core.USING_ACTION_DEFIB,
		[core.NEEDS_NO_HEARTBEAT] = core.USING_ACTION_VENTILATOR,
	}
	return map[needs_type]
end

function empty_bed_in_cell(state, cell_pos)
	local cell = state.cells[cell_pos.y][cell_pos.x]
	local bed_present = false
	local patient_present = false
	for _, item_info in ipairs(cell) do
		if core.is_bed(item_info) then
			bed_present = true
		elseif core.is_patient(item_info) then
			patient_present = true
		end
	end
	return bed_present and not patient_present
end

function core.use_start(state, player_idx)
	local player_state = state.players[player_idx]
	local nearest_item_cell = core.get_closest_item_cell(state, player_idx)

	if player_state.holding == nil and
		nearest_item_cell ~= nil and
		get_item_idx_can_be_picked_up(state, nearest_item_cell) then
		return core.pick_up_item(state, player_idx)
	end

	local patient_info = nil
	
	if nearest_item_cell ~= nil then
		patient_info = get_patient_in_cell(state, nearest_item_cell)
	end

	
	local can_help = false
	local use_time = nil

	-- if the player is holding a patient and near a bed
	if player_state.holding ~= nil and
	   core.is_patient(player_state.holding) and
	   nearest_item_cell ~= nil and
	   empty_bed_in_cell(state, nearest_item_cell) then
		can_help = true
		player_state.using_action = core.USING_ACTION_PUT_PATIENT_IN_BED
		player_state.patient_drop_pos = { y = nearest_item_cell.y, x = nearest_item_cell.x }
		use_time = TIME_TO_PICK_UP_PATIENT
	-- if the player is near a patient who requires aid
	elseif patient_info ~= nil and patient_info.requires_help then
		if not patient_info.needs_revealed then
			can_help = true
			player_state.helping_patient = patient_info
			player_state.using_action    = core.USING_ACTION_REVEAL_NEEDS
			use_time = TIME_TO_REVEAL_NEEDS
		else
			if patient_info.needs_type ~= core.NEEDS_BROKEN_BONE and
			   player_state.holding ~= nil and
			   ary_contains(NEEDS_TO_ITEMS_MAP[patient_info.needs_type], player_state.holding.id) then
				can_help = true
				player_state.helping_patient = patient_info
				player_state.using_action    = needs_type_to_using_action(patient_info.needs_type)
				use_time = NEEDS_TO_USE_TIME_MAP[patient_info.needs_type]
			end
		end
	end

	if not can_help and patient_info ~= nil and
	   (player_state.holding == nil or not core.is_patient(player_state.holding)) then
		-- can move any patient, whether they need help or not
		can_help = true
		player_state.helping_patient = patient_info
		player_state.using_action    = core.USING_ACTION_PICK_UP_PATIENT
		use_time = TIME_TO_PICK_UP_PATIENT
	end



	if can_help then
		player_state.is_using     = true
		player_state.use_progress = 0
		player_state.use_time     = use_time
		return true
	else
		return false
	end
end

function core.use_stop(state, player_idx)
	local player_state = state.players[player_idx]
	player_state.is_using     = false
	player_state.use_progress = 0
	player_state.helping_patient = nil
	player_state.using_action    = nil
end

local function get_patient_item_pos(patient_info)
	return {
		y = patient_info.y - 1,
		x = patient_info.x + 1,
	}
end

local function get_patient_cell_idx(state, patient_info)
	local cell = state.cells[patient_info.y][patient_info.x]
	for idx, item_in_cell in ipairs(cell) do
		if item_in_cell == patient_info then
			return idx
		end
	end
	return nil
end

local function bed_fixes_needs(bed, needs_type)
	if bed.fixes_needs == nil then
		return false
	end
	for _, bed_fixes in ipairs(bed.fixes_needs) do
		if bed_fixes == needs_type then
			return true
		end
	end
	return false
end

local function patient_put_in_bed(state, patient_info)
	local cell = state.cells[patient_info.y][patient_info.x]
	local bed = nil
	for _, item_info in ipairs(cell) do
		if core.is_bed(item_info) then
			bed = item_info
			break
		end
	end

	patient_info.in_bed = bed
	if bed_fixes_needs(bed, patient_info.needs_type) then
		local fix_time = NEED_TO_BED_FIX_TIME_MS[patient_info.needs_type]
		patient_info.orig_fix_time = fix_time
		patient_info.fix_time      = fix_time
	end
end

function core.on_use_complete_func(state, player_idx, events)
	local player_state = state.players[player_idx]
	local patient_info = player_state.helping_patient
	local using_action = player_state.using_action
	core.use_stop(state, player_idx)

	if using_action == core.USING_ACTION_PUT_PATIENT_IN_BED then
		local patient = player_state.holding
		core.drop_item(state, player_idx, player_state.patient_drop_pos)
		patient.y = player_state.patient_drop_pos.y
		patient.x = player_state.patient_drop_pos.x
		patient.held_by = nil
		player_state.patient_drop_pos = nil
		patient_put_in_bed(state, patient)
	elseif using_action == core.USING_ACTION_PICK_UP_PATIENT then
		if player_state.holding ~= nil then
			core.drop_item(state, player_idx)
		end
		local patient_cell_idx = get_patient_cell_idx(state, patient_info)
		table.remove(state.cells[patient_info.y][patient_info.x], patient_cell_idx)
		player_state.holding = patient_info
		patient_info.held_by = player_state
		patient_info.y = nil
		patient_info.x = nil
		patient_info.fix_time = nil
	elseif patient_info.requires_help then
		if not patient_info.needs_revealed then
			if using_action == core.USING_ACTION_REVEAL_NEEDS then
				patient_info.needs_revealed = true
			end
		else
			if needs_type_to_using_action(patient_info.needs_type) == using_action then
				patient_info.requires_help  = false
				patient_info.needs_revealed = false
				if ITEMS_DROPPED_ON_USE_MAP[player_state.holding.id] then
					core.drop_item(state, player_idx, get_patient_item_pos(patient_info))
				end

				table.insert(events, {
					event = core.EVT_PATIENT_CURED,
					patient = patient_info,
				})

			end
		end
	end
end

return core
local draw = {}

local core       = require("games/bound/bound_core")
local alex_c_api = require("alex_c_api")
local draw_more = require("libs/draw/draw_more")

draw.INPUT_TYPE_KEYBOARD = 1
draw.INPUT_TYPE_TOUCH    = 2

local ANIM_TYPE_FLOAT_TEXT = 1

local TIME_LEFT_BG_COLOUR      = '#66666666'
local TIME_LEFT_FG_GOOD_COLOUR = '#008800aa'
local TIME_LEFT_FG_MED_COLOUR  = '#ffff00ff'
local TIME_LEFT_FG_BAD_COLOUR  = '#ff0000ff'
local TIME_LEFT_FG_BAD_COLOUR2 = '#bb5500ff'

local FIX_TIME_PROGRSS_BAR_BG_COLOUR = '#66ff6666'
local FIX_TIME_PROGRSS_BAR_FG_COLOUR = '#22ff22cc'

local HIGHLIGHT_COLOUR     = '#ffff00'
local CONTROLS_TEXT_COLOUR = '#000000'
local CONTROLS_TEXT_SIZE = 12

local TIME_LEFT_ICON_WIDTH = 10
local PADDING = 3

local PLAYER_HIGHLIGHT_COLOURS = {
	{ fill = "#20a4a966", stroke = "#0000ff99" },
	{ fill = "#a72ea566", stroke = "#ff008899" },
	{ fill = "#774a1e66", stroke = "#f7aa5e99" },
	{ fill = "#c5202066", stroke = "#ff000099" },
}

local animations = {}

local highlight_line_size = 5

local TILE_SIZE = 25
local SCREEN_ORIGIN = {
	y = 480/2,
	x = 480/2,
}

local draw_pt_order = nil

local UI_PADDING = 10
local DIRPAD_SIZE = 170
local DIRPAD_SIZE_Y = DIRPAD_SIZE
local DIRPAD_SIZE_X = DIRPAD_SIZE
local dirpad_pos_y  = nil
local dirpad_pos_x  = nil

local THUMB_BUTTONS_SIZE = 150
local THUMB_BUTTONS_SIZE_Y = THUMB_BUTTONS_SIZE
local THUMB_BUTTONS_SIZE_X = THUMB_BUTTONS_SIZE
local thumb_buttons_pos_y = nil
local thumb_buttons_pos_x = nil

local screen_width  = nil
local screen_height = nil



local function point(y, x)
	return { y = y, x = x }
end

-- "cart" (cartesian) meaning the game space, convert it to
-- an isometric grid (how it's drawn)
local function cart_to_iso(pt)
    local x = (pt.x - pt.y)
    local y = (pt.x + pt.y)/2
    return point(y,x)
end

local function iso_to_cart(pt)
    local x = (2*pt.y + pt.x)/2
    local y = (2*pt.y - pt.x)/2
    return point(y,x)
end

local function game_pt_to_gfx_pt(pt, ui_state)
	if pt.x == nil or pt.y == nil then
		error("nil pt.x or y", 2)
	end
	pt = point(pt.y, pt.x)
	pt.y = pt.y + ui_state.offset_y
	pt.x = pt.x + ui_state.offset_x
    pt = point(pt.y*TILE_SIZE, pt.x*TILE_SIZE)
    pt = cart_to_iso(pt)
    pt = point(pt.y + SCREEN_ORIGIN.y, pt.x + SCREEN_ORIGIN.x)
    return pt
end

local function get_doctor_img_id(player_idx)
	local map = {
		[1] = 'hospital_doctor1',
		[2] = 'hospital_doctor2',
		[3] = 'hospital_doctor3',
		[4] = 'hospital_doctor4',
	}
	local img_id = map[player_idx]
	if img_id == nil then
		error(string.format("Could not find doctor img_id for %d", player_idx))
	end
	return img_id
end

local function generate_draw_pt_order(y_size, x_size)
--[[
	local pt_order = {}
	for y=0,y_size-1 do
		local x = 0
		while y >= 0 and x < x_size do
			table.insert(pt_order, { y = y, x = x })
			y = y - 1
			x = x + 1
		end
	end

	for x=0,x_size-1 do
		local y = y_size-1
		while y >= 0 and x < x_size do
			table.insert(pt_order, { y = y, x = x })
			y = y - 1
			x = x + 1
		end
	end
	return pt_order
]]--

	local pt_order = {}
	for y=1,y_size do
		for x=1, x_size do
			table.insert(pt_order, {y=y, x=x})
		end
	end
	return pt_order
end

function draw.init(width, height, game_params)

	screen_width  = width
	screen_height = height

	thumb_buttons_pos_y = height - THUMB_BUTTONS_SIZE_Y - UI_PADDING
	thumb_buttons_pos_x = width  - THUMB_BUTTONS_SIZE_X - UI_PADDING

	dirpad_pos_y  = height - DIRPAD_SIZE_Y - UI_PADDING
	dirpad_pos_x  = UI_PADDING

	local ui_state = {
		dirpad_touch_id   = nil,
		use_btn_touch_id  = nil,
		drop_btn_touch_id = nil,
	}

	--draw_pt_order = generate_draw_pt_order(game_params.y_size, game_params.x_size)
	draw_pt_order = generate_draw_pt_order(game_params.y_size, game_params.x_size) -- TODO FIX THIS TODO TODO TODO
	return ui_state
end

function draw.set_input_type(ui_state, input_type)
	ui_state.input_type = input_type
end

local function get_item_img_id(item_id)
	local map = {
		[core.ITEM_ID_PATIENT_IN_BED] = "hospital_patient_in_bed",
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = "hospital_patient_in_bed_flipped",
		[core.ITEM_ID_BED]        = "hospital_bed",
		[core.ITEM_ID_BED_FLIPPED]= "hospital_bed_flipped",
		[core.ITEM_ID_IV_BAG]     = "hospital_iv_bag",
		[core.ITEM_ID_DEFIB]      = "hospital_defib",
		[core.ITEM_ID_VENTILATOR] = "hospital_ventilator",
		[core.ITEM_ID_XRAY_SHEET] = "hospital_xray_sheet",
		[core.ITEM_ID_XRAY_SOURCE] = "hospital_xray_source",

	}
	local img_id = map[item_id]
	if img_id == nil then
		error(string.format("Could not find image id for item id %s", item_id))
	end
	return img_id
end

local function get_item_size(item_id)
	local sizes = {
		[core.ITEM_ID_PLAYER]         = { x= 1.5*TILE_SIZE,  y= 2*TILE_SIZE },
		[core.ITEM_ID_BED]            = { x= 2.9*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_BED_FLIPPED]    = { x= 2.9*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_PATIENT_IN_BED] = { x= 2.0*TILE_SIZE,  y= 1.5*TILE_SIZE },
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = { x= 2.0*TILE_SIZE,  y= 1.5*TILE_SIZE },
		[core.ITEM_ID_IV_BAG]         = { x= 2*TILE_SIZE,    y= 3*TILE_SIZE },
		[core.ITEM_ID_VENTILATOR]     = { x= 1.8*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_XRAY_SHEET]     = { x= 2.0*TILE_SIZE,  y= 3.0*TILE_SIZE },
		[core.ITEM_ID_XRAY_SOURCE]    = { x= 2.0*TILE_SIZE,  y= 3.0*TILE_SIZE },
		--[core.ITEM_ID_OXYGEN_TANK]    = { x= 2*TILE_SIZE,    y= 3*TILE_SIZE },
		[core.ITEM_ID_DEFIB]          = { x= 2*TILE_SIZE,    y= 2*TILE_SIZE },
	}
	local size = sizes[item_id]
	if size == nil then
		error(string.format("could not find size for id %s", item_id))
	end
	return size
end

local function get_item_offset(item_id)
	local offsets = {
		[core.ITEM_ID_PLAYER] =         { x= 0.50, y= 0.80 },
		[core.ITEM_ID_BED] =            { x= 0.35, y= 0.55 },
		[core.ITEM_ID_BED_FLIPPED] =    { x= 0.35, y= 0.55 },
		[core.ITEM_ID_PATIENT_IN_BED] = { x= 0.35, y= 0.90 },
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = { x= 0.35, y= 0.90 },
		[core.ITEM_ID_IV_BAG] =   { x= 0.6,  y= 0.7  },
		[core.ITEM_ID_VENTILATOR] =     { x= 0.50, y= 0.55 },
		[core.ITEM_ID_XRAY_SHEET] =     { x= 0.60, y= 0.60 },
		[core.ITEM_ID_XRAY_SOURCE] =    { x= 0.50, y= 0.68 },
		--[core.ITEM_ID_OXYGEN_TANK] =    { x= 0.45, y= 0.65 },
		--[core.ITEM_ID_FLOOR_TILE] =       { x= 0.50, y= 0.00 },
		--[core.ITEM_ID_FLOOR_HIGHLIGHT] =  { x= 0.50, y= 0.00 },
		[core.ITEM_ID_DEFIB] =  { x= 0.55, y= 0.50 },
		--[core.ITEM_ID_PATIENT_NEEDS_ICON] =  { x= 0.0, y= 1.5 },
		--[core.ITEM_ID_TUT_NEED_ACTION] =     { x= 0.5, y= 1.5 },
		--[core.ITEM_ID_FIXER_ICON] =          { x= 0.5, y= 1.5 },
		--[core.ITEM_ID_PROGRESS_CIRCLE] =     { x= 0.55, y= 2.20 },
		--[core.ITEM_ID_PATIENT_HEALTH_INDICATORS] =  { x= 0.55, y= 2.20 },
		--[core.ITEM_ID_PATIENT_IND_ICON] =  { x= 0.0*TILE_SIZE, y= 0.0*TILE_SIZE },
	}
	local offset = offsets[item_id]
	if offset == nil then
		error(string.format("could not find offset for id %s", item_id))
	end
	return offset
end

local function draw_item(state, ui_state, item_info, pt)
	local gfx_pt = game_pt_to_gfx_pt(point(pt.y, pt.x), ui_state)
	local size = get_item_size(item_info.id)
	local offset = get_item_offset(item_info.id)
	gfx_pt.y = gfx_pt.y - size.y*offset.y
	gfx_pt.x = gfx_pt.x - size.x*offset.x
	draw_more.draw_graphic_ul(get_item_img_id(item_info.id),
	                        math.floor(gfx_pt.y), math.floor(gfx_pt.x),
	                        math.floor(size.x), math.floor(size.y))
end

local function draw_using_progress(state, ui_state, player_idx)
	local player_state = state.players[player_idx]
	local gfx_pt = game_pt_to_gfx_pt(point(player_state.y, player_state.x), ui_state)
	local size   = { x = 2.5*TILE_SIZE,   y = 0.5*TILE_SIZE }
	local offset = { x = 0.5, y = 4.00 }
	local draw_pt = point(gfx_pt.y - offset.y*size.y,
	                      gfx_pt.x - offset.x*size.x);


	local progress = player_state.use_progress/100.0
	alex_c_api.draw_rect(PLAYER_HIGHLIGHT_COLOURS[player_idx].fill,
	                     math.floor(draw_pt.y), math.floor(draw_pt.x),
	                     math.floor(draw_pt.y + size.y), math.floor(draw_pt.x + size.x))

	alex_c_api.draw_rect(PLAYER_HIGHLIGHT_COLOURS[player_idx].stroke,
	                     math.floor(draw_pt.y), math.floor(draw_pt.x),
	                     math.floor(draw_pt.y + size.y), math.floor(draw_pt.x + progress*size.x))

end

local function draw_player(state, ui_state, item_info)
	local player_state = state.players[item_info.player_idx]
	local gfx_pt = game_pt_to_gfx_pt(point(player_state.y, player_state.x), ui_state)
	local size   = { x = 1.5*TILE_SIZE,   y = 2*TILE_SIZE }
	local offset = { x = 0.50, y = 0.80 }

	local draw_pt = point(gfx_pt.y - offset.y*size.y,
	                      gfx_pt.x - offset.x*size.x);

	draw_more.draw_graphic_ul(get_doctor_img_id(item_info.player_idx),
	                        math.floor(draw_pt.y), math.floor(draw_pt.x),
	                        math.floor(size.x),    math.floor(size.y))

	if player_state.holding ~= nil then
		draw_item(state, ui_state, player_state.holding, player_state)
	end

	if player_state.is_using then
		draw_using_progress(state, ui_state, item_info.player_idx)
	end
end

local function do_nothing(arg1, arg2, arg3)
end

local draw_funcs = {
	[core.ITEM_ID_BED_SEGMENT_2] = do_nothing,
	[core.ITEM_ID_PLAYER] = draw_player,
}

local function draw_items(state, ui_state, player)
	for _, pt in ipairs(draw_pt_order) do
		if state.cells[pt.y][pt.x] == nil then
			goto next_pt
		end
		for _, item_info in ipairs(state.cells[pt.y][pt.x]) do
			local draw_func = draw_funcs[item_info.id]
			if draw_func == draw_player then
				-- do nothing, handled elsewhere now
			elseif draw_func ~= nil then
				draw_func(state, ui_state, item_info)
			else
				draw_item(state, ui_state, item_info, pt)
			end
		end
		::next_pt::
	end

	for i, _ in ipairs(state.players) do
		draw_player(state, ui_state, { player_idx = i })
	end
end

local function patient_to_needs_img_id(patient_info)
	local needs_to_img_id_map = {
		[core.NEEDS_LOW_FLUIDS]   = 'hospital_ui_patient_needs_low_fluids',
		[core.NEEDS_LOW_OXYGEN]   = 'hospital_ui_patient_needs_low_oxygen',
		[core.NEEDS_NO_HEARTBEAT] = 'hospital_ui_patient_needs_no_heartbeat',
		[core.NEEDS_BROKEN_BONE]  = 'hospital_ui_patient_needs_broken_bone',
	}
	if not patient_info.needs_revealed then
		return 'hospital_ui_patient_needs_attention'
	else
		return needs_to_img_id_map[patient_info.needs_type]
	end

end

local function get_time_left_colour(portion)
	if portion > 0.7 then
		return TIME_LEFT_FG_GOOD_COLOUR
	elseif portion > 0.4 then
		return TIME_LEFT_FG_MED_COLOUR
	else
		-- blinking animation
		local time_ms = alex_c_api.get_time_ms()
		if math.floor(time_ms/200) % 2 == 1 then
			return TIME_LEFT_FG_BAD_COLOUR
		else
			return TIME_LEFT_FG_BAD_COLOUR2
		end
	end
end

local function draw_ui_layer_patient(state, ui_state, player, patient)
	if patient.requires_help then
		local pos_pt = patient
		if patient.held_by ~= nil then
			pos_pt = patient.held_by
		end
           local gfx_pt = game_pt_to_gfx_pt(pos_pt, ui_state)
		gfx_pt.y = math.floor(gfx_pt.y - 4.0*TILE_SIZE)
		gfx_pt.x = math.floor(gfx_pt.x)
		local size = { x = math.floor(TILE_SIZE*2.0), y = math.floor(TILE_SIZE*2.5) }
		draw_more.draw_graphic_ul('hospital_ui_patient_needs_bg', 
		                        gfx_pt.y, gfx_pt.x,
		                        size.x, size.y)
		local needs_img_id = patient_to_needs_img_id(patient)
		draw_more.draw_graphic_ul(needs_img_id,
		                        gfx_pt.y, gfx_pt.x,
		                        size.x, size.y)
		if patient.needs_revealed then
		local portion = patient.time_left / patient.orig_time_left
			alex_c_api.draw_rect(TIME_LEFT_BG_COLOUR,
			                     gfx_pt.y,
			                     gfx_pt.x - TIME_LEFT_ICON_WIDTH - PADDING,
			                     gfx_pt.y + size.y,
			                     gfx_pt.x - PADDING)

			alex_c_api.draw_rect(get_time_left_colour(portion),
			                     gfx_pt.y + math.floor((1-portion) * size.y),
			                     gfx_pt.x - TIME_LEFT_ICON_WIDTH - PADDING,
			                     gfx_pt.y + size.y,
			                     gfx_pt.x - PADDING)
		end

		if patient.fix_time ~= nil then
			-- TODO draw a little green cross icon
			local cross_size = {
				y = 10,
				x = 10,
			}

			local fix_bar_pos = {
				y = gfx_pt.y,
				x = gfx_pt.x - 2*TIME_LEFT_ICON_WIDTH - 2*PADDING,
			}
			local fix_bar_size = {
				y = size.y,
				x = TIME_LEFT_ICON_WIDTH,
			}
			draw_more.draw_graphic_ul('hospital_ui_green_cross',
			                        math.floor(fix_bar_pos.y - cross_size.y - PADDING),
			                        math.floor(fix_bar_pos.x),
			                        math.floor(cross_size.y),
			                        math.floor(cross_size.x))
			local portion = patient.fix_time / patient.orig_fix_time
			alex_c_api.draw_rect(FIX_TIME_PROGRSS_BAR_BG_COLOUR,
			                     fix_bar_pos.y,
			                     fix_bar_pos.x,
			                     fix_bar_pos.y + fix_bar_size.y,
			                     fix_bar_pos.x + fix_bar_size.x)
			alex_c_api.draw_rect(FIX_TIME_PROGRSS_BAR_FG_COLOUR,
			                     fix_bar_pos.y + math.floor(portion*size.y),
			                     fix_bar_pos.x,
			                     fix_bar_pos.y + fix_bar_size.y,
			                     fix_bar_pos.x + fix_bar_size.x)
		end
	end
end

local function draw_ui_layer(state, ui_state, player)
	local highlight_needs_types = {}
	for _, patient in ipairs(state.patients) do
		if patient.requires_help and patient.needs_revealed then
			highlight_needs_types[patient.needs_type] = true
		end
	end

	for y=0, state.y_size-1 do
		for x=0, state.x_size-1 do
			for _, item in ipairs(state.cells[y][x]) do
				local items_needs_type = core.get_item_needs_type(item.id)
				if highlight_needs_types[item_needs_type] then
					-- TODO draw fixer icon
				end
			end
		end
	end
			                        
	for _, patient in ipairs(state.patients) do
		draw_ui_layer_patient(state, ui_state, player, patient)
	end

end

local function draw_highlight_floor_cell(ui_state, colour, y, x)
	local padding = 0.1
	local ia = game_pt_to_gfx_pt(point(y - padding,x - padding), ui_state)
	local ib = game_pt_to_gfx_pt(point(y+1+padding,x+0-padding), ui_state)
	local ic = game_pt_to_gfx_pt(point(y+1+padding,x+1+padding), ui_state)
	local id = game_pt_to_gfx_pt(point(y+0-padding,x+1+padding), ui_state)
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ia.y), math.floor(ia.x),
	                     math.floor(ib.y), math.floor(ib.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ib.y), math.floor(ib.x),
	                     math.floor(ic.y), math.floor(ic.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ic.y), math.floor(ic.x),
	                     math.floor(id.y), math.floor(id.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(id.y), math.floor(id.x),
	                     math.floor(ia.y), math.floor(ia.x))
end

local function draw_touch_input()
	draw_more.draw_graphic_ul('hospital_ui_dirpad',
	                        dirpad_pos_y,  dirpad_pos_x,
	                        DIRPAD_SIZE_Y, DIRPAD_SIZE_X)

	draw_more.draw_graphic_ul('hospital_ui_thumb_buttons',
	                        thumb_buttons_pos_y,  thumb_buttons_pos_x,
	                        THUMB_BUTTONS_SIZE_Y, THUMB_BUTTONS_SIZE_X)
end

local function draw_keyboard_input()
	alex_c_api.draw_text('[Z]: Pick up / use', CONTROLS_TEXT_COLOUR,
	                     screen_height - 50, 10, CONTROLS_TEXT_SIZE, 1)
	alex_c_api.draw_text('[X]: Drop', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, 10, CONTROLS_TEXT_SIZE, 1)
	alex_c_api.draw_text('[Arrows]: Move', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, screen_width - 10, CONTROLS_TEXT_SIZE, -1)
end

local function draw_unknown_input()
	alex_c_api.draw_text('Touch screen or use keyboard to select input', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, math.floor(screen_width/2), CONTROLS_TEXT_SIZE, 0)
end

local function draw_animations(animations)
	for _, anim in ipairs(animations) do
		if anim.anim_type == ANIM_TYPE_FLOAT_TEXT then
			alex_c_api.draw_text(anim.text, anim.text_colour,
			                     math.floor(anim.y), math.floor(anim.x),
			                     anim.font_size, 0)
		else
			error("unhandled anim type", anim.anim_type)
		end
	end
end

function draw.draw_state(state, ui_state, player)
	alex_c_api.draw_clear()

	if state == nil then
		return
	end

	local player_state = state.players[player]

	ui_state.offset_y = -player_state.y
	ui_state.offset_x = -player_state.x

    for y, row in pairs(state.cells) do
    	for x, cell in pairs(row) do

            local ia = game_pt_to_gfx_pt(point(y,x), ui_state)
			local tile_id = 'hospital_floor_tile'

			if state.tile_bad(y, x) then
				tile_id = 'hospital_floor_tile_bad'
			end

            draw_more.draw_graphic_ul(tile_id,
			                        math.floor(ia.y), math.floor(ia.x - TILE_SIZE),
			                        2*TILE_SIZE, TILE_SIZE);
		end
	end

	for _, cell in ipairs(core.get_cells_to_highlight(state, player)) do
		if cell.y == nil or cell.x == nil then
			error("cell has nil coords")
		end
		draw_highlight_floor_cell(ui_state, HIGHLIGHT_COLOUR,
		                          cell.y, cell.x)
	end

	for player_idx, _ in ipairs(state.players) do
		local highlight_cell = core.get_closest_item_cell(state, player_idx)
		if highlight_cell ~= nil then
			draw_highlight_floor_cell(ui_state, PLAYER_HIGHLIGHT_COLOURS[player_idx].stroke,
			                          highlight_cell.y, highlight_cell.x)
		end
	end

	draw_items(state, ui_state, player)
	draw_ui_layer(state, ui_state, player)
	draw_animations(animations)

	if ui_state.input_type == draw.INPUT_TYPE_TOUCH then
		draw_touch_input()
	elseif ui_state.input_type == draw.INPUT_TYPE_KEYBOARD then
		draw_keyboard_input()
	else
		draw_unknown_input()
	end

	alex_c_api.draw_text(string.format('Level %d', state.tile_bad_level_idx), CONTROLS_TEXT_COLOUR,
	                     50, 10, CONTROLS_TEXT_SIZE, 1)

	alex_c_api.draw_refresh()
end

local function sign(x)
	if x >= 0 then return 1
	else return -1 end
end

local function get_dirpad_vec(touch)
	local centre_y = math.floor(dirpad_pos_y + DIRPAD_SIZE_Y/2)
	local centre_x = math.floor(dirpad_pos_x + DIRPAD_SIZE_X/2)

	local vec_y = ((touch.y - centre_y)*1.0/(DIRPAD_SIZE/2))
	local vec_x = ((touch.x - centre_x)*1.0/(DIRPAD_SIZE/2))

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	if mag > 1.0 then
		vec_y = vec_y / mag
		vec_x = vec_x / mag
	end

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	return { y = vec_y, x = vec_x}
end

local function touch_in_dirpad(pos)
	local centre_y = math.floor(dirpad_pos_y + DIRPAD_SIZE_Y/2)
	local centre_x = math.floor(dirpad_pos_x + DIRPAD_SIZE_X/2)

	local dy = (pos.y - centre_y)
	local dx = (pos.x - centre_x)

	return (math.abs(dy) <= DIRPAD_SIZE_Y/2 and
	        math.abs(dx) <= DIRPAD_SIZE_X/2)
end

local function touch_in_use_btn(pos)
	local top    = thumb_buttons_pos_y
	local bottom = thumb_buttons_pos_y + THUMB_BUTTONS_SIZE_Y
	local left   = thumb_buttons_pos_x
	local right  = thumb_buttons_pos_x + THUMB_BUTTONS_SIZE_X

	return top  <= pos.y and pos.y <= bottom and
	       left <= pos.x and pos.x <= right and
	       (pos.y - top) >= (pos.x - left)
end

local function touch_in_drop_btn(pos)
	local top    = thumb_buttons_pos_y
	local bottom = thumb_buttons_pos_y + THUMB_BUTTONS_SIZE_Y
	local left   = thumb_buttons_pos_x
	local right  = thumb_buttons_pos_x + THUMB_BUTTONS_SIZE_X

	return top  <= pos.y and pos.y <= bottom and
	       left <= pos.x and pos.x <= right and
	       (pos.y - top) < (pos.x - left)
end

function draw.touches_to_actions(state, ui_state, evt_id, touches)
	local actions = {}
	for _, touch in ipairs(touches) do
		if evt_id == 'touchstart' and ui_state.dirpad_touch_id == nil and touch_in_dirpad(touch) then
			ui_state.dirpad_touch_id = touch.id
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.dirpad_touch_id == touch.id then
			ui_state.dirpad_touch_id = nil
			local action = {
				action = core.ACTION_DIR_PAD_POS_CHANGE,
				vec_y = 0,
				vec_x = 0,
			}
			table.insert(actions, action)
		end
		if ui_state.dirpad_touch_id == touch.id then
			local vec = get_dirpad_vec(touch)
			local action = {
				action = core.ACTION_DIR_PAD_POS_CHANGE,
				vec_y = vec.y,
				vec_x = vec.x
			}
			table.insert(actions, action)
		end

		if evt_id == 'touchstart' and ui_state.use_btn_touch_id == nil and touch_in_use_btn(touch) then
			ui_state.use_btn_touch_id = touch.id
			table.insert(actions, { action = core.ACTION_USE_BTN_DOWN })
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.use_btn_touch_id == touch.id then
			ui_state.use_btn_touch_id = nil
			table.insert(actions, { action = core.ACTION_USE_BTN_RELEASE })
		end

		if evt_id == 'touchstart' and ui_state.drop_btn_touch_id == nil and touch_in_drop_btn(touch) then
			ui_state.drop_btn_touch_id = touch.id
			table.insert(actions, { action = core.ACTION_DROP_BTN_DOWN })
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.drop_btn_touch_id == touch.id then
			ui_state.drop_btn_touch_id = nil
			table.insert(actions, { action = core.ACTION_DROP_BTN_RELEASE })
		end
	end
	return actions
end

function draw.add_animations_for_events(state, ui_state, events)
	for _, event in ipairs(events) do
		if event.event == core.EVT_PATIENT_NEED_EXPIRED then
			local pt = event.patient
			local gfx_pt = game_pt_to_gfx_pt(event.patient, ui_state)
			table.insert(animations, {
				anim_type = ANIM_TYPE_FLOAT_TEXT,
				text        = '-100',
				text_colour = '#ff0000ff',
				font_size   = 16,
				orig_y = gfx_pt.y,
				orig_x = gfx_pt.x,

				y = gfx_pt.y,
				x = gfx_pt.x,

				dst_y = gfx_pt.y - 70,
				dst_x = gfx_pt.x,

				orig_time_left = 3000,
				time_left = 3000,
			})
		elseif event.event == core.EVT_PATIENT_CURED then
			local pt = event.patient
			local gfx_pt = game_pt_to_gfx_pt(event.patient, ui_state)
			table.insert(animations, {
				anim_type = ANIM_TYPE_FLOAT_TEXT,
				text      = '+10',
				text_colour = '#008800cc',
				font_size   = 16,

				orig_y = gfx_pt.y,
				orig_x = gfx_pt.x,

				y = gfx_pt.y,
				x = gfx_pt.x,

				dst_y = gfx_pt.y - 70,
				dst_x = gfx_pt.x,

				orig_time_left = 3000,
				time_left = 3000,
			})
		else
			error("unhandled event", event.event)
		end
	end
end

function draw.update_animations(state, dt)
	for _, anim in ipairs(animations) do
		local dy = (anim.dst_y - anim.orig_y)*1.0/anim.orig_time_left
		local dx = (anim.dst_x - anim.orig_x)*1.0/anim.orig_time_left

		anim.y = anim.y + dy * dt
		anim.x = anim.x + dx * dt
		anim.time_left = anim.time_left - dt
	end

	local i=1
	while i <= #animations do
		if animations[i].time_left <= 0 then
			table.remove(animations, i)
		else
			i = i + 1
		end
	end
end


return draw

local core = require("games/bound/bound_core")
local draw = require("games/bound/bound_draw")
local serialize = require("games/bound/bound_serialize")

local wait_for_players = require("libs/multiplayer/wait_for_players")

local alex_c_api = require("alex_c_api")

--[[
	TODO:
	* fix cursor, make it always go towards closest cell...
      right now it's hard to select something to the top left of you if
	  there's something else (perhaps a full cell away) to the bottom right
	* implement multiplayer
	* implement score, right now I just hardcoded +10 and -100 in animations,
	  but the sum isn't tracked anywhere
	* fix arrow keys as client, didn't work on calc.alexbarry.net
	* I saw "player 'all' joined" as host on calc.alexbarry.net

	* need to fix delay on client when joining a mobile host... it's unplayable
	* missing some things from serializiation like the "time to fix" level, and animations

* Need to make some sort of progression.

# Future ideas for progression

* start out with one of each illness at a time, maybe a few random ones.
	- one of each, in order, then maybe another one of each in a random order
	- in these cases, make a new patient just as the previous one was cured-- so no
	  stress when learning, and fast if you know what you're doing
* then two at once for a bit, three at once
* one some limit is reached (10 patients?) need some unlocks

possible unlocks:
* a nurse who can reveal patients' needs
* another nurse who can also help patients with low fluids
* a nurse or some mechanism of automating everything? But then there are twice as many illnesses occurring
* a new wing of the hospital that opens up, so you have twice as many patients to worry about--
  now you need to keep an eye on more places, and see if the AI working in the other wing is sufficient or needs help
* coffee or some powerup to help you move much faster between wings 
* a pager or cell phone so that you can see if people need help nearby?
* an alarm for code blues, so that people who need defibrillation will be noticed right away, and you don't
  have to keep an eye on everyone?
* an ambulance that could drive inside the hospital and help people? Or that you could use to move around quickly?

The goal is that you start out individually doing everything, but by the end game you should be able
to help something like 10 times as many patients, getting 10 times as many points, and hopefully
10 times the fun and pressure...

Maybe over time, you just get more and more wings of the hospital to work on? It just keeps
growing forever, and you're limited by how quickly you can get around, or how much you can keep an eye on everyone?

That would be interesting... the amount of work remains constant, but the number of places that you may be needed
keeps increasing infinitely... and the transportation delay can hopefully be mitigated somehow, so that the only factor
that affects your skill is awareness. Maybe there are conveyor belts that help you move around very quickly?
Or a highway or something?

Maybe multiple levels in the same hospital... oh just an elevator with no travel time? That would be an easy way to
spread the hospital out infinitely. Although at that point what does it matter? I guess you have to manage where
you leave equipment?



* new challenges: have a mini map to see where you're needed, but you also need to keep an eye on where you step.
	- vomit: sticky, slow you down?
	- broken glass: similar
	- spilled water: make you slide in a random direction
	- slow patients in wheel chairs
	- coffee is a power up to make you move quickly
	- find an empty wheel chair to move quickly
	- banana peel to slip and fall
	- crowd of people wandering
	- marbles/toys on the ground
	- residents/students

new illnesses:
	- dialysis: either bring them a dialysis machine or take them to it.
	- diabetics: insulin or sugar
	- transplant: take a kidney out of one person, bring it to another
	- needs surgery? Appendicits?
	- eyes? glaucoma? need glasses? bring them to the eye chart?
	- ears: iconic ear examining thing




--]]

local players = {
	[1] = "You",
}
local player = 1
local is_client = false
local player_name_to_idx = {}

local FPS = 20
local dt = math.floor(1000.0/FPS)
local keys_down = {}

local screen_width  = 480
local screen_height = 480
local player = 1
local game_params = {
	y_size = 10,
	x_size = 10,
	num_players = 1,
}

local ui_state = draw.init(screen_width, screen_height, game_params)
local state = nil

function draw_board()
	if state == nil then
		return
	end

	draw.update_animations(state, dt)

	-- TODO need to handle animations for client players
	if not is_client then
		local events = core.update_state(state, dt)
		draw.add_animations_for_events(state, ui_state, events)
	end

	draw.draw_state(state, ui_state, player)
	send_state_updates_if_host()
end

local function handle_actions_host(actions, player)
	if state == nil then
		return
	end
	for _, action in ipairs(actions) do
		if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
			core.handle_player_dirpad_update(state, player, action.vec_y, action.vec_x)
		elseif action.action == core.ACTION_USE_BTN_DOWN then
			core.handle_player_use_btn(state, player, true)
		elseif action.action == core.ACTION_USE_BTN_RELEASE then
			core.handle_player_use_btn(state, player, false)
		elseif action.action == core.ACTION_DROP_BTN_DOWN then
			core.handle_player_drop_btn(state, player, true)
		elseif action.action == core.ACTION_DROP_BTN_RELEASE then
			core.handle_player_drop_btn(state, player, false)
		end
	end
end



local function handle_recv_action(src, msg)
	local src_player_idx = player_name_to_idx[src]
	if src_player_idx == nil then
		error("unexpected player src " .. src)
	end
	local m = msg:gmatch("(%d),(.*)")
	if m == nil then
		error(string.format("invalid action msg recvd %s", msg))
	end
	local action_type, payload = m()
	action_type = tonumber(action_type)

	local action = {
		action = action_type,
	}

	if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
		local m2 = payload:gmatch("(-?%d*),(-?%d*)")
		if m2 == nil then
			error(string.format("invalid action dir pad pos msg payload recvd: %s", payload))
		end
		local vec_y_int, vec_x_int = m2()
		vec_y_int = tonumber(vec_y_int)
		vec_x_int = tonumber(vec_x_int)
		action.vec_y = vec_y_int*1.0/1000
		action.vec_x = vec_x_int*1.0/1000
	end

	handle_actions_host({action}, src_player_idx)
	
end

-- Could also throttle this to not send the same position more than once in a row,
-- or within some factor or something
--
-- TODO need to make sure this doesn't happen for keypresses
local last_dirpad_update_time = nil
local MIN_DIRPAD_POS_UPDATE_PERIOD_MS = 50
local function handle_actions_client(actions, player)
	for _, action in ipairs(actions) do
		local payload = ""
		if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
			local curr_time = alex_c_api.get_time_ms()
			if action.vec_y ~= 0 and action.vec_x ~= 0 and
			   last_dirpad_update_time ~= nil and
			   curr_time - last_dirpad_update_time < MIN_DIRPAD_POS_UPDATE_PERIOD_MS then
				goto next_action
			end
			last_dirpad_update_time = curr_time
			payload = string.format("%d,%d", math.floor(action.vec_y*1000),
			                                 math.floor(action.vec_x*1000))
		end
		local msg = string.format("action:%d,%s", action.action, payload)
		alex_c_api.send_message("all", msg)
		::next_action::
	end
end

local function handle_actions(actions, player)
	if is_client then
		handle_actions_client(actions, player)
	else
		handle_actions_host(actions, player)
	end
end



function handle_touch_evt(evt_id, changed_touches)
	draw.set_input_type(ui_state, draw.INPUT_TYPE_TOUCH)
	local actions = draw.touches_to_actions(state, ui_state, evt_id, changed_touches)
	handle_actions(actions, player)
end

local movement_keys = {
       ["ArrowUp"]    = true,
       ["ArrowLeft"]  = true,
       ["ArrowRight"] = true,
       ["ArrowDown"]  = true,
       ["KeyH"]       = true,
       ["KeyJ"]       = true,
       ["KeyK"]       = true,
       ["KeyL"]       = true,
}

function handle_key_evt(evt_id, key_code)
	local handled = false
	draw.set_input_type(ui_state, draw.INPUT_TYPE_KEYBOARD)
	local prev_state = keys_down[key_code]
	if evt_id == 'keydown' then
		keys_down[key_code] = true
	elseif evt_id == 'keyup' then
		keys_down[key_code] = false
	else
		error(string.format("Unhandled key_evt \"%s\"", evt_id))
	end

	if prev_state == keys_down[key_code] then
		-- If the key was one of the movement keys, tell the client that we've handled it.
		-- This is to avoid duplicate arrow keys (sent when you hold one down, after a second or so)
		-- causing the browser to scroll.
		return movement_keys[key_code]
	end

	local vec_y = 0
	local vec_x = 0

	if keys_down["ArrowUp"] or keys_down["KeyK"] then
		vec_y = -1
	elseif keys_down["ArrowDown"] or keys_down["KeyJ"] then
		vec_y = 1
	end

	if keys_down["ArrowLeft"] or keys_down["KeyH"] then
		vec_x = -1
	elseif keys_down["ArrowRight"] or keys_down["KeyL"] then
		vec_x = 1
	end

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	if mag > 0 then
		vec_y = vec_y / mag
		vec_x = vec_x / mag
	end

	if movement_keys[key_code] then
		handle_actions({{
			-- TODO move this to core
			action = core.ACTION_DIR_PAD_POS_CHANGE,
			vec_y = vec_y,
			vec_x = vec_x,
		}}, player)
		handled = true
	end

	if key_code == 'KeyZ' then
		if evt_id == 'keydown' then
			handle_actions({{
				action = core.ACTION_USE_BTN_DOWN,
			}}, player)
		elseif evt_id == 'keyup' then
			handle_actions({{
				action = core.ACTION_USE_BTN_RELEASE,
			}}, player)
		else
			error(string.format("unhandled evt_id = %s", evt_id))
		end
		handled = true
	end

	if key_code == 'KeyX' then
		if evt_id == 'keydown' then
			handle_actions({{
				action = core.ACTION_DROP_BTN_DOWN,
			}}, player)
		elseif evt_id == 'keyup' then
			handle_actions({{
				action = core.ACTION_DROP_BTN_RELEASE,
			}}, player)
		else
			error(string.format("unhandled evt_id = %s", evt_id))
		end
		handled = true
	end

	return handled

end

function new_game(player_count)
	game_params.num_players = player_count
	state = core.init(game_params)
end

function send_state_updates_if_host()
	if is_client then
		return
	end

	if state == nil then
		return
	end

	for dst_player, player_name in pairs(players) do
		if dst_player == player then
			goto next_player
		end
		local state_msg = "state:" .. serialize.serialize_state(state)
		alex_c_api.send_message(player_name, state_msg)
		::next_player::
	end
end



local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false
	new_game(#players)
	send_state_updates_if_host()
	draw_board()
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- no need to draw board here, a state update should soon follow
end

function handle_msg_received(src, msg)

	local handled = wait_for_players.handle_msg_received(src, msg)
	if handled then
		return
	end
	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "state" then
		if not is_client then
			error("Received state as host")
		end
		state = serialize.deserialize_state(payload)
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	elseif header == "action" then
		handle_recv_action(src, payload)
	else
		error(string.format("Unhandled message %s", header))
	end

	send_state_updates_if_host()
	draw_board()
end 

function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end
end


alex_c_api.enable_evt('touch')
alex_c_api.enable_evt('key')
alex_c_api.set_timer_update_ms(math.floor(dt))

wait_for_players.init(players, player, start_host_game, start_client_game)
local serialize = {}

local core = require("games/bound/bound_core")
local utils = require("libs/utils")
local serialize_lib = require("libs/serialize/serialize")

local function get_patient_info_idx(state, item_info)
	for idx, patient_info in ipairs(state.patients) do
		if patient_info == item_info then
			return idx
		end
	end
	return nil
end

local function deserialize_patient_info(state, bytes)
	local info = {}
	info.id             = serialize_lib.deserialize_byte(bytes)
	info.y              = serialize_lib.deserialize_byte(bytes)
	info.x              = serialize_lib.deserialize_byte(bytes)
	info.requires_help  = serialize_lib.deserialize_bool(bytes)
	info.needs_revealed = serialize_lib.deserialize_bool(bytes)
	info.needs_type     = serialize_lib.deserialize_byte(bytes)
	local time_left_s32 = serialize_lib.deserialize_s32(bytes)
	if time_left_s32 == 0x7fffffff then
		info.time_left = nil
	else
		info.time_left      = time_left_s32
	end
	local orig_time_left_s32 = serialize_lib.deserialize_s32(bytes)
	if orig_time_left_s32 ~= 0x7fffffff then
		info.orig_time_left = orig_time_left_s32
	else
		info.orig_time_left = nil
	end
	local held_by_player_idx = serialize_lib.deserialize_byte(bytes)
	if held_by_player_idx == nil then
		info.held_by = nil
	else
		info.held_by = state.players[held_by_player_idx]
	end

	return info
end

local function get_player_idx(state, player_state)
	if player_state == nil then
		return nil
	end
	for idx, player in ipairs(state.players) do
		if player == player_state then
			return idx
		end
	end
	error("could not find player in states")
end

local function serialize_patient_info(state, patient_info)
	local output = ""
	output = output .. serialize_lib.serialize_byte(patient_info.id)
	output = output .. serialize_lib.serialize_byte(patient_info.y)
	output = output .. serialize_lib.serialize_byte(patient_info.x)
	output = output .. serialize_lib.serialize_bool(patient_info.requires_help)
	output = output .. serialize_lib.serialize_bool(patient_info.needs_revealed)
	output = output .. serialize_lib.serialize_byte(patient_info.needs_type)
	if patient_info.time_left ~= nil then
		output = output .. serialize_lib.serialize_s32( math.floor(patient_info.time_left))
	else
		output = output .. serialize_lib.serialize_s32( 0x7fffffff )
	end
	if patient_info.orig_time_left ~= nil then
		output = output .. serialize_lib.serialize_s32( patient_info.orig_time_left)
	else
		output = output .. serialize_lib.serialize_s32( 0x7fffffff )
	end

	output = output .. serialize_lib.serialize_byte(get_player_idx(state, patient_info.held_by))
		
	return output
end

local function deserialize_player_info(bytes)
	local info = {}
	info.id            = core.ITEM_ID_PLAYER
	info.y             = serialize_lib.deserialize_s32(bytes)*1.0/1000
	info.x             = serialize_lib.deserialize_s32(bytes)*1.0/1000
	info.vel_y         = serialize_lib.deserialize_s32(bytes)*1.0/1000/1000
	info.vel_x         = serialize_lib.deserialize_s32(bytes)*1.0/1000/1000
	info.use_btn_down  = serialize_lib.deserialize_bool(bytes)
	info.drop_btn_down = serialize_lib.deserialize_bool(bytes)
	local holding_id   = serialize_lib.deserialize_byte(bytes)
	if holding_id == nil then
		info.holding = nil
	else
		info.holding = { id = holding_id }
	end
	info.is_using      = serialize_lib.deserialize_bool(bytes)
	info.use_progress  = serialize_lib.deserialize_byte(bytes)
	local use_time_byte = serialize_lib.deserialize_byte(bytes)
	if use_time_byte == 0xff then
		info.use_time = nil
	else
		info.use_time      = use_time_byte
	end
	return info
end

local function serialize_player_info(player_info)
	local output = ""
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.y*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.x*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.vel_y*1000*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.vel_x*1000*1000))
	output = output .. serialize_lib.serialize_bool(player_info.use_btn_down)
	output = output .. serialize_lib.serialize_bool(player_info.drop_btn_down)
	local holding_id = nil
	if player_info.holding ~= nil then
		holding_id = player_info.holding.id
	end
	output = output .. serialize_lib.serialize_byte(holding_id)
	output = output .. serialize_lib.serialize_bool(player_info.is_using)
	output = output .. serialize_lib.serialize_byte(math.floor(player_info.use_progress))
	if player_info.use_time ~= nil then
		output = output .. serialize_lib.serialize_byte(math.floor(player_info.use_time))
	else
		output = output .. serialize_lib.serialize_byte(0xff)
	end
	return output
end

local function serialize_cell(state, cell)
	local output = ""
	output = output .. serialize_lib.serialize_byte(#cell)
	local debug_type = nil
	for _, item_info in ipairs(cell) do
		output = output .. serialize_lib.serialize_byte(item_info.id)
		if core.is_patient(item_info) then
			local patient_idx = get_patient_info_idx(state, item_info)
			output = output .. serialize_lib.serialize_byte(patient_idx)
			debug_type = "patient"
		elseif core.is_player(item_info) then
			local player_idx = item_info.player_idx
			output = output .. serialize_lib.serialize_byte(player_idx)
			debug_type = "player"
		else
			debug_type = "none"
		end
	end
	local s = ""
	for _, item_info in ipairs(cell) do
		s = s .. string.format("%d, ", item_info.id)
	end
	--print(string.format("serialized cell into %d bytes, had %d items (%s) (%s) (%s)", #output, #cell, debug_type, s, utils.binstr_to_hr_str(output)))
	return output
end

local function deserialize_cell(state, bytes)
	local start_byte_count = #bytes
	local cell = {}
	local item_count = serialize_lib.deserialize_byte(bytes)
	local debug_type = "nil"
	for i=1,item_count do
		local item_id = serialize_lib.deserialize_byte(bytes)
		local item_info = {
			id = item_id,
		}
		if core.is_patient(item_info) then
			local patient_idx = serialize_lib.deserialize_byte(bytes)
			if not(1 <= patient_idx and patient_idx <= #state.patients) then
				error(string.format("expected patient idx, received %s, have " ..
				      " only %d patient states", patient_idx, #state.patients))
			end
			debug_type = "patient"
			item_info = state.patients[patient_idx]
		elseif core.is_player(item_info) then
			local player_idx = serialize_lib.deserialize_byte(bytes)
			if not(1 <= player_idx and player_idx <= #state.players) then
				error(string.format("expected player idx, received %s, have " ..
				      " only %d player states", player_idx, #state.players))
			end
			debug_type = "player"
			item_info = state.players[player_idx]
			item_info.id = item_id
			item_info.player_idx = player_idx
		else
			debug_type = "none"
		end
		table.insert(cell, item_info)
	end
	--print(string.format("deserialized cell from %d bytes, contained %d items (%s)", start_byte_count - #bytes, item_count, debug_type))
	return cell
end

local function serialize_bad_tiles(state)
	local y_size = state.y_size
	local x_size = state.x_size

	local output = ""
	output = output .. serialize_lib.serialize_byte(y_size)
	output = output .. serialize_lib.serialize_byte(x_size)
	for y=0,y_size-1 do
		for x=0,x_size-1 do
			local val = state.tile_bad(y,x)
			output = output .. serialize_lib.serialize_bool(val)
		end
	end
	return output
end

local function deserialize_bad_tiles(bytes)
	local y_size = serialize_lib.deserialize_byte(bytes)
	local x_size = serialize_lib.deserialize_byte(bytes)
	local map = {}
	for y=0,y_size-1 do
		map[y] = {}
		for x=0,x_size-1 do
			map[y][x] = serialize_lib.deserialize_bool(bytes)
		end
	end

	return function (y,x)
		return map[y][x]
	end
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(state.tile_bad_level_idx)
	output = output .. serialize_lib.serialize_byte(state.y_size)
	output = output .. serialize_lib.serialize_byte(state.x_size)

	output = output .. serialize_lib.serialize_s32(state.new_sickness_period)
	output = output .. serialize_lib.serialize_s32_nilable(state.time_to_new_sickness)
	output = output .. serialize_lib.serialize_byte(state.new_sickness_count)

	output = output .. serialize_lib.serialize_byte(#state.players)
	for _, player in ipairs(state.players) do
		output = output .. serialize_player_info(player)
	end

	output = output .. serialize_bad_tiles(state)

	output = output .. serialize_lib.serialize_byte(#state.patients)

	for _, patient in ipairs(state.patients) do
		output = output .. serialize_patient_info(state, patient)
	end
	local cells_serialized = ""
	local non_empty_cell_count = 0
	for y, row in pairs(state.cells) do
		for x, cell in pairs(row) do
			if state.cells[y][x] ~= nil then
				cells_serialized = cells_serialized .. serialize_lib.serialize_byte(y)
				cells_serialized = cells_serialized .. serialize_lib.serialize_byte(x)
				cells_serialized = cells_serialized .. serialize_cell(state, state.cells[y][x])
				non_empty_cell_count = non_empty_cell_count + 1
			end
		end
	end
	output = output .. serialize_lib.serialize_16bit(non_empty_cell_count)
	output = output .. cells_serialized
	--print(string.format("serialized %d non empty cells into %d bytes", non_empty_cell_count, #cells_serialized))
	--print(string.format("serialized into %d bytes", #output))
	return output
end


function serialize.deserialize_state(byte_str)
	local bytes = serialize_lib.bytestr_to_byteary(byte_str)
	--print(string.format("deserializing %d bytes", #bytes))
	local state = {}
	state.tile_bad_level_idx   = serialize_lib.deserialize_byte(bytes)
	state.y_size = serialize_lib.deserialize_byte(bytes)
	state.x_size = serialize_lib.deserialize_byte(bytes)

	state.new_sickness_period  = serialize_lib.deserialize_s32(bytes)
	state.time_to_new_sickness = serialize_lib.deserialize_s32_nilable(bytes)
	state.new_sickness_count   = serialize_lib.deserialize_byte(bytes)

	local player_count = serialize_lib.deserialize_byte(bytes)
	state.players  = {}
	for i=1,player_count do
		state.players[i] = deserialize_player_info(bytes)
	end

	state.tile_bad = deserialize_bad_tiles(bytes)

	local patient_count = serialize_lib.deserialize_byte(bytes)
	state.patients = {}
	for i=1,patient_count do
		--print("deserializing patient " .. i)
		state.patients[i] = deserialize_patient_info(state, bytes)
	end

	state.cells = {}

	local non_empty_cell_count = serialize_lib.deserialize_16bit(bytes)
	--print("deserializing " .. non_empty_cell_count .. " cells from " .. #bytes .. " remaining bytes" )
	for i=1,non_empty_cell_count do
		--print("i=" .. i ..", remaining bytes: " .. utils.binary_to_hr_str(bytes))
		local y = serialize_lib.deserialize_byte(bytes)
		local x = serialize_lib.deserialize_byte(bytes)
		if state.cells[y] == nil then
			state.cells[y] = {}
		end
		state.cells[y][x] = deserialize_cell(state, bytes)
	end

	if #bytes > 0 then
		error(string.format("received %d leftover bytes when deserializing", #bytes))
	end
	
	return state
end

return serialize
local alex_c_api = require("alex_c_api")
local cards = require("libs/cards/cards")

local core = {}

core.PICK_UP_EVT_ID  = 2
core.PUT_DOWN_EVT_ID = 1
core.MOVE_EVT_ID     = 3

-- when drawing a deck of cards, draw cards in `offset_count` distinct positions,
-- evenly distributed `offset_size` pixels away from the start.
local offset_count = 4
local offset_size = 8

function core.init(args)
	local state = {
		height = args.height,
		width  = args.width,
		reveal_area = args.reveal_area,

		card_height    = args.card_height,
		card_width     = args.card_width,


		player_states = {},

		cards = {},
	}

	for i=1,args.player_count do
		state.player_states[i] = {
			y = nil,
			x = nil,

			card_idx = nil,
			-- either the numeric ID of the touch, or 'mouse' for mouse
			input_src = nil,
			card_orig_y = nil,
			card_orig_x = nil,
		}
	end

	local deck = cards.new_deck()
	cards.shuffle(deck)

	for i, card in ipairs(deck) do
		local offset = math.floor(i*offset_count/#deck) * offset_size / offset_count
		state.cards[#state.cards+1] = {
			recvd = false,
			held_by = nil,
			revealed_to_all    = false,
			revealed_to_player = nil,
			card = card,
			y = math.floor(args.width/2 + offset),
			x = math.floor(args.height/2 - offset),
		}
	end
	return state
end


function core.find_card_under_cursor(state, pos_y, pos_x)
	for i=#state.cards,1,-1 do
		local card_info = state.cards[i]
		if card_info.y - state.card_height/2 <= pos_y and pos_y <= card_info.y + state.card_height/2 and
		   card_info.x - state.card_width/2  <= pos_x and pos_x <= card_info.x + state.card_width/2 then
			return i
		end
	end
	return nil
end

function core.in_revealed_area(state, pos_y, pos_x)
	if (0 <= pos_y and pos_y <= state.reveal_area) then
		return 2
	elseif (state.height - state.reveal_area <= pos_y and pos_y <= state.height) then
		return 1
	else
		return nil
	end
	       
end


local function player_move(state, player_idx, input_src, pos_y, pos_x)
	if not(1 <= player_idx and player_idx <= #state.player_states) then
		error("Invalid player_idx " .. player_idx)
	end
	local player_state = state.player_states[player_idx]
	player_state.y = pos_y
	player_state.x = pos_x
	if player_state.card_idx ~= nil and player_state.input_src == input_src then
		state.cards[player_state.card_idx].y = pos_y
		state.cards[player_state.card_idx].x = pos_x

		local reveal_player = core.in_revealed_area(state, pos_y, pos_x)
		state.cards[player_state.card_idx].revealed_to_player = reveal_player
		if reveal_player ~= nil then
			state.cards[player_state.card_idx].revealed_all = false
		end
	end
end

function core.handle_mousemove(state, player_idx, pos_y, pos_x)
	local input_src = 'mouse'
	player_move(state, player_idx, input_src, pos_y, pos_x)
end

local function touch_start_to_move(state, player_idx, input_src, pos_y, pos_x)
	local player_state = state.player_states[player_idx]
	local card_idx = core.find_card_under_cursor(state, pos_y, pos_x)
	if card_idx == nil then
		print(string.format("Player %d: Found no card at pos y=%f, x=%f", player_idx, pos_y, pos_x))
		return nil
	end
	if state.cards[card_idx].held_by ~= nil then
		print(string.format("Player %d: Card is already held by player %s", player_idx, 
			state.cards[card_idx].held_by))
		return nil
	end

	return { player = player_idx,
			 input_src = input_src,
	         move_type = core.PICK_UP_EVT_ID,
	         y = math.floor(pos_y),
	         x = math.floor(pos_x)
	}
end


local function pick_up_card(state, player_idx, input_src, pos_y, pos_x)
	local player_state = state.player_states[player_idx]
	local card_idx = core.find_card_under_cursor(state, pos_y, pos_x)
	if card_idx == nil then
		print(string.format("Player %d: Found no card at pos y=%f, x=%f", player_idx, pos_y, pos_x))
		return
	end
	if state.cards[card_idx].held_by ~= nil then
		print(string.format("Player %d: Card is already held by player %s", player_idx, 
			state.cards[card_idx].held_by))
		return
	end
	-- note that calling this with card_idx nil will remove the last card
	local tmp = table.remove(state.cards, card_idx)
	local old_card_idx = card_idx
	tmp.held_by = player_idx
	table.insert(state.cards, tmp)
	player_state.card_idx = #state.cards
	player_state.input_src = input_src
	player_state.card_orig_y = pos_y
	player_state.card_orig_x = pos_x
	if player_state.card_idx ~= nil then
		print(string.format("Player %d picked up card idx %d, input_src %s", player_idx, player_state.card_idx, input_src))
	end
	for i = 1, #state.player_states do
		if i == player_idx then
			goto next_player
		end
		if state.player_states[i].card_idx ~= nil and 
		   state.player_states[i].card_idx > old_card_idx then
			state.player_states[i].card_idx = state.player_states[i].card_idx - 1 
		end
		
		::next_player::
	end
end


local function touch_end_to_move(state, player_idx, touch_id, touch_y, touch_x)
	local move = {
		player = player_idx,
		move_type = core.PUT_DOWN_EVT_ID,
		input_src = touch_id,
		y = math.floor(touch_y),
		x = math.floor(touch_x) }
	return move
end

local function touch_move_to_move(state, player_idx, touch_id, touch_y, touch_x)
	local move = {
		player = player_idx,
		move_type = core.MOVE_EVT_ID,
		input_src = touch_id,
		y = math.floor(touch_y),
		x = math.floor(touch_x) }
	return move
end

local function put_down_card(state, player_idx, input_src, pos_y, pos_x)
	local player_state = state.player_states[player_idx]
	if player_state.card_idx ~= nil then
		print(string.format("Player %d Put down card, input_src %s", player_idx, player_state.card_idx, input_src))
		state.cards[player_state.card_idx].held_by = nil
	end

	-- if a card is held, it has not moved, and it is not in a revealed area,
	-- then reveal it to all if clicked
	if player_state.card_idx ~= nil and
	   -- TODO should change this to be a flag that is cleared once it has moved.
	   -- otherwise, if you move it to exactly the same position you took it from,
	   -- it would be revealed
	   pos_y == player_state.card_orig_y and pos_x == player_state.card_orig_x and
	   core.in_revealed_area(state, pos_y, pos_x) == nil then
	
		state.cards[player_state.card_idx].revealed_all = not state.cards[player_state.card_idx].revealed_all
	end
	player_state.card_idx = nil
	player_state.input_src = nil
end



function core.handle_mouse_evt(state, player_idx, evt_id, pos_y, pos_x)
	local input_src = 'mouse'
	if evt_id == 2 then
		pick_up_card(state, player_idx, input_src, pos_y, pos_x)
	elseif evt_id == 1 or
	       evt_id == 3 then
		put_down_card(state, player_idx, input_src, pos_y, pos_x)
	else
		error("Unhandled evt " .. evt_id)
	end
end


function core.touches_to_moves(state, player_idx, evt_id, changed_touches)
	local moves = {}
	local player_state = state.player_states[player_idx]
	if evt_id == 'touchstart' then
		for _, touch in ipairs(changed_touches) do
			local move = touch_start_to_move(state, player_idx, touch.id, touch.y, touch.x)
			table.insert(moves, move)
		end
	elseif evt_id == 'touchmove' then
		for _, touch in ipairs(changed_touches) do
			local move = touch_move_to_move(state, player_idx, touch.id, touch.y, touch.x)
			table.insert(moves, move)
		end
	elseif evt_id == 'touchend' or
	       evt_id == 'touchcancel' then
		for _, touch in ipairs(changed_touches) do
			local move = touch_end_to_move(state, player_idx, touch.id, touch.y, touch.x)
			table.insert(moves, move)
		end
	end
	return moves
end

function core.handle_touch_evt(state, player_idx, evt_id, changed_touches)
	local moves = core.touches_to_moves(state, player_idx, evt_id, changed_touches)
	for _, move in ipairs(moves) do
		if move.move_type == core.PICK_UP_EVT_ID then
			pick_up_card(state, move.player, move.input_src, move.y, move.x)
		elseif move.move_type == core.PUT_DOWN_EVT_ID then
			put_down_card(state, move.player, move.input_src, move.y, move.x)
		elseif move.move_type == core.MOVE_EVT_ID then
			player_move(state, move.player, move.input_src, move.y, move.x)
		else
			error(string.format("Unhandled move type %s", move.move_type))
		end
	end
end

return core
local alex_c_api = require("alex_c_api")
local cards = require("libs/cards/cards")
local card_draw = require("libs/cards/cards_draw")

local draw = {}

local card_height    = nil
local card_width     = nil
local card_font_size = nil

local REVEAL_AREA_COLOUR = '#8888ff33'
local REVEAL_AREA_TEXT   = 'Revealed'
local REVEAL_AREA_TEXT_COLOUR = '#0000ff88'
local REVEAL_AREA_TEXT_SIZE = 18
local text_y_size = 25

local width  = nil
local height = nil
local reveal_area = nil

local PLAYER_CURSOR_RADIUS = 5
local PLAYER_COLOURS = {
	{ fill = '#ff000088', outline = '#ff0000' },
	{ fill = '#0000ff88', outline = '#0000ff' },
	{ fill = '#00ff0088', outline = '#00ff00' },
	{ fill = '#00888888', outline = '#00ffff' },
}

function draw.init(args)
	width  = args.width
	height = args.height
	reveal_area    = args.reveal_area
	card_height    = args.card_height
	card_width     = args.card_width
	card_font_size = args.card_font_size
end

function draw.draw(state, player)
	alex_c_api.draw_clear()

	if state == nil then
		return
	end

	alex_c_api.draw_rect(REVEAL_AREA_COLOUR,
		0, 0, reveal_area, width)
	alex_c_api.draw_text(REVEAL_AREA_TEXT, REVEAL_AREA_TEXT_COLOUR,
		text_y_size, 0, REVEAL_AREA_TEXT_SIZE, 1, 0)

	alex_c_api.draw_rect(REVEAL_AREA_COLOUR,
		height - reveal_area, 0, height, width)
	alex_c_api.draw_text(REVEAL_AREA_TEXT, REVEAL_AREA_TEXT_COLOUR,
		height - reveal_area + text_y_size, 0, REVEAL_AREA_TEXT_SIZE, 1, 0)
	for _, card_info in ipairs(state.cards) do
		local card = nil
		if card_info.recvd or card_info.revealed_all or card_info.revealed_to_player == player then
			card = card_info.card
		else
			card = cards.UNREVEALED_CARD
		end
		card_draw.draw_card(card,
			math.floor(card_info.y - card_height/2),
			math.floor(card_info.x - card_width/2),
			card_width, card_height, card_font_size, false, 0)
	end

	for i=1,#state.player_states do
		if state.player_states[i].y == nil or
		   state.player_states[i].x == nil then
			goto next_player_cursor
		end
		alex_c_api.draw_circle(PLAYER_COLOURS[i].fill, PLAYER_COLOURS[i].outline,
			state.player_states[i].y,
			state.player_states[i].x,
			PLAYER_CURSOR_RADIUS)
		::next_player_cursor::
	end

	alex_c_api.draw_refresh()
end

return draw
local wait_for_players = require("libs/multiplayer/wait_for_players")
local alex_c_api = require("alex_c_api")

local core = require("games/card_sim/card_generic_core")
local draw = require("games/card_sim/card_generic_draw")
local serialize = require("games/card_sim/card_generic_serialize")

-- TODO if two players click the same card, then there is a big bug.
-- Need to remember two things when a player picks up a card: 
--    * who is holding the card,
--    * what touch ID (either 'mouse', or the ID from the touch event)
-- Also need to handle something when someone picks up a card... update the card_idx
-- of other players if they were holding that card?
--
-- Also will likely need to implement throttling.
--
-- Ideally would also implement client side control of the cards, so that I could just send 
-- the held card index and coordinates, instead of sending all the state
--
-- TODO I think there is a bug if you pick up a card, move the mouse off screen, then
-- click to pick up the card again, if another player has picked up a card since then?
-- When re-ordering cards, need to update all the player's card_idx.
-- Maybe remember cards by value, not position in array
--
-- TODO there is still an issue if two players pick up a card at the same time
--

local width  = 480
local height = 480

local MAX_MOVE_PERIOD_MS = 50
local throttled_count = 0


local args = {
	width = width,
	height = height,

	player_count = 2,

	card_height    = 70,
	card_width     = 40,
	card_font_size = 16,

	reveal_area = math.floor(height/5),
}

local players = {
	[1] = "You",
}
local player_name_to_idx = {}
local player = 1
local state = nil
local is_client = false


local function send_state_updates_if_host()
	if is_client then
		return
	end

	for i=1,#state.player_states do
		if i == player then
			goto next_player
		end
		local serialized_state = serialize.serialize_state_for_client(state, i)
		alex_c_api.send_message(players[i], "state:" .. serialized_state)
		::next_player::
	end
end


function draw_board()
	draw.draw(state, player)
end

alex_c_api.enable_evt("mouse_move")
alex_c_api.enable_evt("mouse_updown")

function handle_user_clicked(pos_y, pos_x)
end

local last_move_time = nil
function handle_mousemove(pos_y, pos_x)
	local time = alex_c_api.get_time_ms()
	if last_move_time ~= nil and time - last_move_time < MAX_MOVE_PERIOD_MS then
			throttled_count = throttled_count + 1
		return
	end
	last_move_time = time
	if not is_client then
		core.handle_mousemove(state, player, pos_y, pos_x)
	else
		alex_c_api.send_message("all", string.format("move:%d,%d,%s,%d,%d", player, 3, 'mouse', pos_y, pos_x))
	end
	send_state_updates_if_host()
	draw_board()
end

function handle_mouse_evt(evt_id, pos_y, pos_x)
	if not is_client then
		core.handle_mouse_evt(state, player, evt_id, pos_y, pos_x)
	else
		alex_c_api.send_message("all", string.format("move:%d,%d,%s,%d,%d", player, evt_id, 'mouse', pos_y, pos_x))
	end
	send_state_updates_if_host()
	draw_board()
end

local function handle_recvd_move(state, msg_player, msg_evt, msg_y, msg_x)
	if msg_evt == 1 or msg_evt == 2 then
		core.handle_mouse_evt(state, msg_player, msg_evt, msg_y, msg_x)
	elseif msg_evt == 3 then
		core.handle_mousemove(state, msg_player, msg_y, msg_x)
	else
		error("Unhandled evt_id " .. msg_evt)
	end
	send_state_updates_if_host()
	draw_board()
end

function handle_msg_received(src, msg)
	--print("handle_msg_received (from src:" .. src .. "): " .. msg);

	local handled = wait_for_players.handle_msg_received(src, msg)
	if handled then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "state" then
		local recvd_state = serialize.deserialize_client_state(payload)
		state = recvd_state
	elseif header == "move" then
		local other_player = player_name_to_idx[src]
		local m2 = payload:gmatch("(%d+),(%d+),([^,]+),(%d+),(%d+)")
		if m2 == nil then
			error("Invalid recvd payload " .. payload)
		end
		local msg_player, msg_evt, msg_input_src, msg_y, msg_x = m2()
		msg_player = tonumber(msg_player)
		msg_evt    = tonumber(msg_evt)
		msg_y      = tonumber(msg_y)
		msg_x      = tonumber(msg_x)
		handle_recvd_move(state, msg_player, msg_evt, msg_y, msg_x)
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	else
		error("Unhandled msg: " .. msg)
	end
	draw_board()
end

function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end

	error("Unhandled popup_btn_clicked")
end


local function new_game(player_count)
	state = core.init(args)
	draw.init(args)
end

local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false
	new_game(#players)
	send_state_updates_if_host()
	draw_board()
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- no need to draw board here, a state update should soon follow
end

-- TODO I really don't want to have to serialize all of this...
function handle_touch_evt(evt_id, changed_touches)
	if evt_id == "touchmove" then
		local time = alex_c_api.get_time_ms()
		if last_move_time ~= nil and time - last_move_time < MAX_MOVE_PERIOD_MS then
			throttled_count = throttled_count + 1
			return
		end
		last_move_time = time
	end
	if not is_client then
		core.handle_touch_evt(state, player, evt_id, changed_touches)
	else
		local moves = core.touches_to_moves(state, player, evt_id, changed_touches)
		for _, move in ipairs(moves) do
			local move_msg = string.format("move:%d,%d,%s,%d,%d",
			                               move.player, move.move_type, move.input_src, move.y, move.x)
			alex_c_api.send_message("all", move_msg)
		end
	end
	send_state_updates_if_host()
	draw_board()
end


alex_c_api.enable_evt('touch')

wait_for_players.init(players, player, start_host_game, start_client_game)
draw.init(args)
local cards = require("libs/cards/cards")

local serialize = {}

-- TODO put it a library 
local function serialize_16bit(val)
	local output = ""
	local orig_val = val
	if val == nil then
		val = 0x7fff
	else
		val = math.floor(val)
	end
	val = val + 0x7fff
	if not(0 <= val and val <= 0xffff) then
		error(string.format("Need 16 bit val, recvd %s", orig_val))
		return nil
	end
	output = output .. string.char(math.floor((val/256))&0xff)
	output = output .. string.char(math.floor(val%256))
	return output
end
-- TODO put in a library
local function deserialize_16bit(bytes)
	if #bytes < 2 then
		error(string.format("Expected at least 2 bytes, recvd %d", #bytes))
	end
	local msb = string.byte(table.remove(bytes,1))
	local lsb = string.byte(table.remove(bytes,1))
	local val = ((msb << 8) | lsb) - 0x7fff
	--print(string.format("deserialize_16bit %02x %02x returning %s", msb, lsb, val))
	if val == 0x7fff then
		return nil
	else
		return val
	end
end

local function bytestr_to_byteary(byte_str)
	local byte_ary = {}
	for i=1,#byte_str do
		byte_ary[i] = byte_str:sub(i,i)
	end
	return byte_ary
end



function serialize.serialize_state_for_client(state, player)
	local output = ""

	
	output = output .. serialize_16bit(state.card_height)
	output = output .. serialize_16bit(state.card_width)
	output = output .. serialize_16bit(#state.player_states)
	for _, player_state in ipairs(state.player_states) do
		output = output .. serialize_16bit(player_state.y)
		output = output .. serialize_16bit(player_state.x)
		-- this could be a single byte
		output = output .. serialize_16bit(player_state.card_idx)
		output = output .. serialize_16bit(player_state.card_orig_y)
		output = output .. serialize_16bit(player_state.card_orig_x)
	end

	output = output .. serialize_16bit(#state.cards)
	for _, card_info in ipairs(state.cards) do
		local card_int = nil
		if card_info.revealed_all or card_info.revealed_to_player == player then
			card_int = cards.card_to_int(card_info.card)
		else
			card_int = cards.UNREVEALED_CARD
		end
		output = output .. serialize_16bit(card_int)
		output = output .. serialize_16bit(card_info.y)
		output = output .. serialize_16bit(card_info.x)
	end
	return output
end

function serialize.deserialize_client_state(bytes)
	local state = {}
	bytes = bytestr_to_byteary(bytes)

	state.card_height = deserialize_16bit(bytes)
	state.card_width = deserialize_16bit(bytes)

	local player_count = deserialize_16bit(bytes)
	state.player_states = {}
	for i=1,player_count do
		state.player_states[i] = {}
		state.player_states[i].y           = deserialize_16bit(bytes)
		state.player_states[i].x           = deserialize_16bit(bytes)
		state.player_states[i].card_idx    = deserialize_16bit(bytes)
		state.player_states[i].card_orig_y = deserialize_16bit(bytes)
		state.player_states[i].card_orig_x = deserialize_16bit(bytes)
	end

	local card_count = deserialize_16bit(bytes)
	state.cards = {}
	for i=1,card_count do
		state.cards[i] = {}
		local card_int = deserialize_16bit(bytes)
		state.cards[i].card = cards.int_to_card(card_int)
		state.cards[i].y = deserialize_16bit(bytes)
		state.cards[i].x = deserialize_16bit(bytes)
		state.cards[i].recvd = true
	end

	return state
end

return serialize
core = {}

core.BOARD_HEIGHT = 8
core.BOARD_WIDTH  = 8

core.ROWS_OF_PIECES = 3

core.EMPTY   = 0
core.PLAYER1        = 1
core.PLAYER2        = 2
core.PLAYER1_KING   = 3
core.PLAYER2_KING   = 4

core.RC_SUCCESS       = 0
core.RC_NOT_YOUR_TURN = -1
-- Can not move to this position
core.RC_INVALID_MOVE  = -2
core.RC_OCCUPIED      = -3
core.RC_NOT_YOUR_PIECE = -4
core.RC_NO_PIECE_TO_SELECT = -5
core.RC_MUST_JUMP_SELECTED = -6
core.RC_MUST_JUMP = -7
-- core.RC_UNSELECTED = -6

function core.player_id_to_name(id)
	if id == nil then return nil
	elseif id == core.PLAYER1 then return "red"
	elseif id == core.PLAYER2 then return "black"
	else
		error(string.format("Unexpected player id %q", id))
	end
end

local dirs = {
	{ y = 1, x = 1},
	{ y =-1, x = 1},
	{ y =-1, x =-1},
	{ y = 1, x =-1},
}

function core.rc_to_string(rc)
	local rc_to_str_map = {
		[core.RC_SUCCESS]            = "Success",
		[core.RC_NOT_YOUR_TURN]      = "Not your turn",
		[core.RC_INVALID_MOVE]       = "Can not move to this position",
		[core.RC_OCCUPIED]           = "This position is occupied",
		[core.RC_NOT_YOUR_PIECE]     = "This piece is not controlled by you",
		[core.RC_NO_PIECE_TO_SELECT] = "Must select a piece to move",
		[core.RC_MUST_JUMP_SELECTED] = "Must jump with currently selected piece",
		[core.RC_MUST_JUMP]          = "You have at least one jump available, so you must jump",
	}
	return rc_to_str_map[rc]
end

local function new_2d_array(height, width, default_val)
	local ary = {}
	for y=1,height do
		ary[y] = {}
		for x=1,width do
			ary[y][x] = default_val
		end
	end
	return ary
end

function core.default_game_settings()
	return {
		must_jump_when_able = true,
	}
end

function core.new_state(game_settings)
	if game_settings == nil then
		game_settings = core.default_game_settings()
	end
	local board = new_2d_array(core.BOARD_HEIGHT, core.BOARD_WIDTH, 0)
	for y=1,core.ROWS_OF_PIECES do
		local x_start
		if y % 2 == 1 then
			x_start = 1
		else
			x_start = 2
		end
		for x=x_start,8,2 do
			board[y][x] = core.PLAYER1
		end
	end

	for y=core.BOARD_HEIGHT-core.ROWS_OF_PIECES+1,core.BOARD_HEIGHT do
		local x_start
		if y % 2 == 1 then
			x_start = 1
		else
			x_start = 2
		end
		for x=x_start,8,2 do
			board[y][x] = core.PLAYER2
		end
	end

	return {
		game_settings = game_settings,
		player_turn = core.PLAYER1,
		board = board,
		selected_y = nil,
		selected_x = nil,
		-- for the case where you are partway through a double jump
		must_jump_selected = false,
	}
end

function core.print_state(state)
	io.write("state = {\n")
	io.write(string.format("    player_turn = %s\n", state.player_turn))
	io.write(string.format("    selected_y = %s\n", state.selected_y))
	io.write(string.format("    selected_x = %s\n", state.selected_x))
	io.write(string.format("    must_jump_selected = %s\n", state.must_jump_selected))
	io.write(string.format("    board = {\n", state.selected_x))
	for _,row in ipairs(state.board) do
		io.write("        {")
		for _,cell in ipairs(row) do
			io.write(string.format("%d ", cell))
		end
		io.write("}\n")
	end
	io.write("    }\n")
	io.write("}\n")
end

local val_to_char_map = {
	[core.EMPTY]   = ' ',
	[core.PLAYER1] = 'x',
	[core.PLAYER1] = 'o',
}

function core.print_board(board)
	io.write("+")
	for x=1,#board do
		io.write(string.format("-+"))
	end
	io.write("\n")
	for y=1,#board do
		io.write("|")
		for x=1,#board do
			io.write(string.format("%s|", val_to_char_map[board[y][x]]))
		end
		io.write("\n")
		io.write("+")
		for x=1,#board do
			io.write(string.format("-+"))
		end
		io.write("\n")
	end
end

local function in_range(y,x)
	return (1 <= y and y <= core.BOARD_HEIGHT and
	        1 <= x and x <= core.BOARD_WIDTH)
end

local function is_player(state, y, x, player)
	local piece = state.board[y][x]
	if player == core.PLAYER1 then
		return piece == core.PLAYER1 or piece == core.PLAYER1_KING
	elseif player == core.PLAYER2 then
		return piece == core.PLAYER2 or piece == core.PLAYER2_KING
	else
		error(string.format("Unexpected player %s", player))
		return false
	end
end

function core.piece_to_player(piece)
	if piece == core.EMPTY then
		return core.EMPTY
	elseif piece == core.PLAYER1 or piece == core.PLAYER1_KING then
		return core.PLAYER1
	elseif piece == core.PLAYER2 or piece == core.PLAYER2_KING then
		return core.PLAYER2
	else
		error(string.format("Unexpected piece %s", piece))
		return nil
	end
end

function core.piece_is_king(piece)
	return piece == core.PLAYER1_KING or piece == core.PLAYER2_KING
end

local function other_player(player)
	if player == core.PLAYER1 then return core.PLAYER2
	elseif player == core.PLAYER2 then return core.PLAYER1
	else error(string.format("Unexpected player %s", player)) end
end

local function sign(val)
	if val > 0 then return 1
	elseif val == 0 then return 0
	else return -1 end
end

local function king(player)
	if player == core.PLAYER1 then return core.PLAYER1_KING
	elseif player == core.PLAYER2 then return core.PLAYER2_KING
	else error(string.format("Unexpected player %s", player)) end
end

-- NOTE: does not check if destination is occupied
function core.valid_move(state, src_y, src_x, dst_y, dst_x, jumped_pieces)
	local dy = dst_y - src_y
	local dx = dst_x - src_x

	local piece = state.board[src_y][src_x]
	local player = core.piece_to_player(piece)

	print(string.format("valid_move, player = %s, dy=%s, dx=%s", player, dy, dx))

	if (core.piece_is_king(piece) and math.abs(dy) == 1) or 
	   (player == core.PLAYER1 and dy ==  1) or
	   (player == core.PLAYER2 and dy == -1) then
		print("hit dy == 1 case")
		return dx == 1 or dx == -1
	elseif (core.piece_is_king(piece) and math.abs(dy) == 2) or
	       (player == core.PLAYER1 and dy ==  2) or
	       (player == core.PLAYER2 and dy == -2) then
		print("hit dy == 2 case")
		if math.abs(dx) ~= 2 then
			print("dx ~= 2")
			return false
		end
		local jumped_y = src_y + sign(dy)
		local jumped_x = src_x + sign(dx)
		if is_player(state, jumped_y, jumped_x, other_player(player)) then
			print("should be jumped")
			if jumped_pieces ~= nil then
				table.insert(jumped_pieces, {y= jumped_y, x= jumped_x })
			end
			return core.RC_SUCCESS
		else
			print("jumped player is not other player")
			return false
		end
	else
		print("hit other case")
		return false
	end

end

local function move_piece(state, y, x)
	local piece = state.board[state.selected_y][state.selected_x]
	state.board[state.selected_y][state.selected_x] = core.EMPTY
	state.board[y][x] = piece
end

local function can_jump(state, y, x)
	for _,dir in ipairs(dirs) do
		local y2 = y + 2*dir.y
		local x2 = x + 2*dir.x

		if not in_range(y2, x2) then
			print(string.format("Checking y2=%s, x2=%s, out of range", y2, x2))
			goto next_dir
		end

		if state.board[y2][x2] ~= core.EMPTY then
			print(string.format("Checking y2=%s, x2=%s, occupied", y2, x2))
			goto next_dir
		end

		local dir_valid_move = core.valid_move(state, y, x, y2, x2)
		print(string.format("Checking y2=%s, x2=%s, valid_move=%q", y2, x2, dir_valid_move))
		if dir_valid_move then
			return true
		end
		::next_dir::
	end
	return false
end

function move_is_jump(state, y, x)
	local dy = state.selected_y - y
	local dx = state.selected_x - x

	return math.abs(dy) == 2 and math.abs(dx) == 2
end

function jumps_available_for_player(state, player)
	for y=1,core.BOARD_HEIGHT do
		for x=1,core.BOARD_WIDTH do
			if core.piece_to_player(state.board[y][x]) ~= player then
				goto next_cell
			end
			if can_jump(state, y, x) then
				return true
			end
			::next_cell::
		end
	end

	return false
end

-- Used for both selecting a piece, and choosing where to move it.
-- (Called twice for a single move)
function core.player_move(state, player, y, x)
	if player ~= state.player_turn then
		return core.RC_NOT_YOUR_TURN
	end

	if not in_range(y,x) then
		return core.RC_INVALID_MOVE
	end

	if state.selected_y == nil or state.selected_x == nil then
		if state.board[y][x] == core.EMPTY then
			return core.RC_NO_PIECE_TO_SELECT
		elseif not is_player(state, y, x, player) then
			return core.RC_NOT_YOUR_PIECE
		else
			state.selected_y = y
			state.selected_x = x
			return core.RC_SUCCESS
		end
	else
		if y == state.selected_y and x == state.selected_x then
			if state.must_jump_selected then
				return core.RC_MUST_JUMP_SELECTED
			end
			state.selected_y = nil
			state.selected_x = nil
			-- return core.RC_UNSELECTED
			return core.RC_SUCCESS
		end

		if state.game_settings.must_jump_when_able then
			if jumps_available_for_player(state, player) and not move_is_jump(state, y, x) then
				return core.RC_MUST_JUMP
			end
		end

		-- change selection if selected own pieces
		if is_player(state, y, x, player) then
			state.selected_y = y
			state.selected_x = x
			return core.RC_SUCCESS
		end

		if state.board[y][x] ~= core.EMPTY then
			return core.RC_OCCUPIED
		end


		if state.must_jump_selected then
			if math.abs(state.selected_y - y) ~= 2 and
			   math.abs(state.selected_x - x) ~= 2 then
				return core.RC_MUST_JUMP_SELECTED
			end
		end


		local jumped_pieces = {}
		if core.valid_move(state, state.selected_y, state.selected_x, y, x, jumped_pieces) then
			for _,piece in ipairs(jumped_pieces) do
				state.board[piece.y][piece.x] = core.EMPTY
			end
			move_piece(state, y, x)
		else
			return core.RC_INVALID_MOVE
		end

		if (player == core.PLAYER1 and y == core.BOARD_HEIGHT) or
		   (player == core.PLAYER2 and y == 1) then
			state.board[y][x] = king(player)
		end

		if #jumped_pieces > 0 and can_jump(state, y, x) then
			state.must_jump_selected = true
			-- updated selected indicators to point to this cell
			-- now that the piece moved here
			state.selected_y = y
			state.selected_x = x
		else
			state.must_jump_selected = false
			state.selected_y = nil
			state.selected_x = nil
			state.player_turn = (((state.player_turn-1) + 1 ) % 2) + 1
		end

		return core.RC_SUCCESS
	end
end

function core.get_square_colour(y, x)
	return (y%2 == 1) ~= (x%2 == 1)
end


--local state = core.new_state()
--core.print_board(state.board)

return core
local draw = {}
local core = require("games/checkers/checkers_core")
local alex_c_api = require("alex_c_api")
local draw_more = require("libs/draw/draw_more")

local height = nil
local width  = nil
local square_size = nil
local piece_radius = nil
local square_padding = 1
local square_size_w_padding = nil
local offset_y = nil
local offset_x = nil


local SQUARE_BORDERS = '#aaaa55'
local SQUARE_BLACK   = '#000000'
local SQUARE_RED     = '#882222'
local SQUARE_BLACK_HIGHLIGHTED   = '#555555'
local SQUARE_RED_HIGHLIGHTED     = '#aa4444'

local PIECE_BLACK  = '#444444'
local PIECE_RED    = '#aa2222'
-- local PIECE_OUTLINE = '#333333'
local PIECE_RED_OUTLINE   = '#770000'
local PIECE_BLACK_OUTLINE = '#777777'

if alex_c_api.get_user_colour_pref() == "dark" then
	SQUARE_BORDERS = '#666600'
	SQUARE_BLACK   = '#000000'
	SQUARE_RED     = '#220000'
	SQUARE_BLACK_HIGHLIGHTED   = '#555555'
	SQUARE_RED_HIGHLIGHTED     = '#aa4444'
	
	PIECE_BLACK  = '#333333'
	PIECE_RED    = '#660000'
	PIECE_RED_OUTLINE   = '#770000'
	PIECE_BLACK_OUTLINE = '#777777'
end

function draw.init(height_arg, width_arg)
	height = height_arg
	width  = width_arg
	local board_square_count = math.min(core.BOARD_HEIGHT, core.BOARD_WIDTH)
	square_size = math.floor((math.min(height,width) - (board_square_count+1)*square_padding)*1.0 / board_square_count)
	square_size_w_padding = square_size + square_padding
	piece_radius = math.floor(square_size*0.8/2)

	offset_y = math.floor((height - (core.BOARD_HEIGHT+1)*square_padding - core.BOARD_HEIGHT*square_size)/2)
	offset_x = math.floor((width  - (core.BOARD_WIDTH +1)*square_padding - core.BOARD_WIDTH *square_size)/2)
end

local function get_colour_of_square(state, y, x)
	local is_red = core.get_square_colour(y,x)
	if state.selected_y == y and state.selected_x == x then
		if is_red then
			return SQUARE_RED_HIGHLIGHTED
		else
			return SQUARE_BLACK_HIGHLIGHTED
		end
	end
	if is_red then
		return SQUARE_RED
	else
		return SQUARE_BLACK
	end
end

function draw.draw_board(state)
	--alex_c_api.draw_rect('#000000', 0, 0, height, width)
	alex_c_api.draw_clear()
	-- Why do I need to add another 2 pixels here?? Otherwise the gold edge is cutoff
	alex_c_api.draw_rect(SQUARE_BORDERS, offset_y, offset_x,
	                     math.ceil(core.BOARD_HEIGHT*square_size + (core.BOARD_HEIGHT+2)*square_padding) + 2,
	                     math.ceil(core.BOARD_WIDTH*square_size  + (core.BOARD_WIDTH +2)*square_padding) + 2)
	for y=1,core.BOARD_HEIGHT do
		for x=1,core.BOARD_WIDTH do
			local colour = get_colour_of_square(state, y, x)
			alex_c_api.draw_rect(colour,
			                     offset_y + square_padding + (y-1)*square_size_w_padding,
			                     offset_x + square_padding + (x-1)*square_size_w_padding,
			                     offset_y + (y  )*square_size_w_padding,
                                 offset_x + (x  )*square_size_w_padding)

			local piece = state.board[y][x]
			local piece_colour = nil
			local piece_outline_colour = nil
			if core.piece_to_player(piece) == core.PLAYER1 then
				piece_colour = PIECE_RED
				piece_outline_colour = PIECE_RED_OUTLINE
			elseif core.piece_to_player(piece) == core.PLAYER2 then
				piece_colour = PIECE_BLACK
				piece_outline_colour = PIECE_BLACK_OUTLINE
			end

			if piece_colour ~= nil then
				local coord_y = offset_y + math.floor((y-1+0.5)*square_size_w_padding)
				local coord_x = offset_x + math.floor((x-1+0.5)*square_size_w_padding)
				alex_c_api.draw_circle(piece_colour, piece_outline_colour,
				                       coord_y,
				                       coord_x,
				                       piece_radius)
				if core.piece_is_king(piece) then
					draw_more.draw_graphic_ul("piece_king_icon",
					                       coord_y - piece_radius,
					                       coord_x - piece_radius,
					                       2*piece_radius,
					                       2*piece_radius)
				end
			end
		end
	end
	alex_c_api.draw_refresh()
end

function draw.coords_to_piece_idx(coord_y, coord_x)
	local idx_y = math.floor((coord_y - offset_y - square_padding) / square_size_w_padding) + 1
	local idx_x = math.floor((coord_x - offset_x - square_padding) / square_size_w_padding) + 1
	return { y = idx_y, x = idx_x }
end

return draw
local two_player = require("libs/multiplayer/two_player")
local utils      = require("libs/utils")

local core       = require("games/checkers/checkers_core")
local draw       = require("games/checkers/checkers_draw")
local serialize  = require("games/checkers/checkers_serialize")

local alex_c_api = require("alex_c_api")

local height = 480
local width  = 480

draw.init(height, width)

local local_multiplayer = nil
local player_name_to_id = {}
local player = nil
local g_other_player = nil
local session_id = alex_c_api.get_new_session_id()
local state = core.new_state()

local GAME_OPTION_NEW_GAME = "game_option_new_game"

local BTN_ID_UNDO = "btn_undo"
local BTN_ID_REDO = "btn_redo"

-- Testing double jump logic and with a king
--[[
state.board = {
    {1,0,1,0,1,0,1,0,},
    {0,1,0,1,0,1,0,1,},
    {1,0,0,0,0,0,1,0,},
    {0,0,0,0,0,1,0,0,},
    {2,0,2,0,0,0,0,0,},
    {0,2,0,0,0,2,0,2,},
    {2,0,2,0,2,0,2,0,},
    {0,3,0,0,0,2,0,2,},
}
]]

function draw_board()
	draw.draw_board(state)
	alex_c_api.set_btn_enabled(BTN_ID_UNDO, alex_c_api.has_saved_state_offset(session_id, -1))
	alex_c_api.set_btn_enabled(BTN_ID_REDO, alex_c_api.has_saved_state_offset(session_id,  1))
end

local function get_player()
	if local_multiplayer then
		return state.player_turn
	else
		return player
	end
end

function handle_user_clicked(coord_y, coord_x)
	local piece = draw.coords_to_piece_idx(coord_y, coord_x)
	local rc = core.player_move(state, get_player(), piece.y, piece.x)
	
	if rc ~= core.RC_SUCCESS then
		alex_c_api.set_status_err(core.rc_to_string(rc))
	else
		-- TODO this saves even when the player just selects something... that
		-- shouldn't count as a move.
		save_state()
		alex_c_api.set_status_msg("Waiting for other player to move")
		if not local_multiplayer then
			alex_c_api.send_message("all", string.format("move:%d,%d,%d", player, piece.y, piece.x))
		end
	end

	core.print_state(state)
	print(string.format("serialized state is: %s", utils.binstr_to_hr_str(serialize.serialize_state(state))))
	draw_board()
end


local SELECT_PLAYER_POPUP_ID = "select_player"
local PLAYER_CHOICE_BTNS = {
	"Red",
	"Black",
}
local BTN_MAP = {
	[0] = core.PLAYER1,
	[1] = core.PLAYER2,
}

function handle_popup_btn_clicked(popup_id, btn_idx)
	if two_player.handle_popup_btn_clicked(popup_id, btn_idx) then
		-- handled
	else
		error(string.format("Unhandled popup_id=%s, btn_idx=%s", popup_id, btn_idx))
	end
end

local function broadcast_state(dst)
	alex_c_api.send_message(dst, "state:" .. serialize.serialize_state(state))
end

function handle_msg_received(src, msg)
	print("Recvd msg " .. msg)

	if two_player.handle_msg_received(src, msg) then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	if m == nil then
		print("Unable to parse header from msg " .. msg)
		return
	end
	local header, payload = m()

	if header == "move" then
		local m2 = payload:gmatch("(%d+),(%d+),(%d+)")
		if m2 == nil then
			error("Invalid \"move\" msg from " .. src)
			return
		end
		local player_idx, y, x = m2()
		player_idx = tonumber(player_idx)
		y = tonumber(y)
		x = tonumber(x)
		local rc = core.player_move(state, player_idx, y, x)
		if rc ~= core.RC_SUCCESS then
			alex_c_api.set_status_err("Other player made an invalid move")
		else
			alex_c_api.set_status_msg("Your move")
			draw_board()
			save_state()
		end

	elseif header == "get_state" then
		broadcast_state(src)
	elseif header == "state" then
		local recvd_state = serialize.deserialize_state(payload)
		print("Recieved state:")
		core.print_state(recvd_state)
		state = recvd_state
		draw_board()
		save_state()
	elseif header == "player_left" and src == "ctrl" then
	elseif header == "player_joined" then
	else
		error("Unhandled message: " .. header )
	end
end

function two_player_init()
	local args = {
		supports_local_multiplayer = true,
		title = "Choose piece colour",
		player_choices = PLAYER_CHOICE_BTNS,
		handle_multiplayer_type_choice = function (multiplayer_type)
			if multiplayer_type == two_player.MULTIPLAYER_TYPE_LOCAL then
				local_multiplayer = true
			elseif multiplayer_type == two_player.MULTIPLAYER_TYPE_NETWORK then
				local_multiplayer = false
			end
		end,
		choice_id_to_player_id = function (btn_id)
			return BTN_MAP[btn_id]
		end,
		player_name_to_id = player_name_to_id,
		player_id_to_nice_name = function (player_id)
			local player_colour = core.player_id_to_name(player_id)
			return utils.make_first_char_uppercase(player_colour)
		end,
		get_msg = function ()
			local msg = "Red moves first."
			if utils.table_len(player_name_to_id) == 0 then
				msg = msg .. "\nThe other player has not yet chosen."
			else
				--msg = msg .. string.format("The other player has chosen %s",
				--                           core.player_id_to_name(other_player))
				for player_name, player_id in pairs(player_name_to_id) do
					local player_colour = core.player_id_to_name(player_id)
					msg = msg .. string.format("\n%s is chosen by %s", utils.make_first_char_uppercase(player_colour), player_name)
				end
			end
			return msg
		end,
		handle_player_choice = function (player_name, player_id)
			local choice_str = core.player_id_to_name(player_id)
			print(string.format("handle_player_choice{ player_name=\"%s\", choice=%q (%q) }", player_name, player_id, choice_str))
			if player_name == two_player.LOCAL_PLAYER then
				player = player_id
			else
				g_other_player = player_id
			end
		end,

		need_reselect = function ()
			local this_player  = player
			local other_player = g_other_player

			return this_player == nil or this_player == other_player
		end,

		get_local_player_choice = function ()
			return player
		end
	}

	two_player.init(args)
end

local function load_state_move_offset(move_id_offset)
	local serialized_state = alex_c_api.get_saved_state_offset(session_id, move_id_offset)
	state = serialize.deserialize_state(serialized_state)
	draw_board()
	broadcast_state("all")
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_UNDO then
		load_state_move_offset(-1)
	elseif btn_id == BTN_ID_REDO then
		load_state_move_offset(1)
	end
end

function start_game(session_id_arg, serialized_state)
	local last_sess_id = alex_c_api.get_last_session_id()
	if serialized_state then
		session_id = session_id_arg
		state = serialize.deserialize_state(serialized_state)
	elseif last_sess_id ~= nil then
		serialized_state = alex_c_api.get_saved_state_offset(last_sess_id, 0)
		session_id = last_sess_id
		state = serialize.deserialize_state(serialized_state)
	end
	two_player_init()

	--alex_c_api.send_message("all", "player_joined:")
	alex_c_api.send_message("all", "get_state:")

	alex_c_api.add_game_option(GAME_OPTION_NEW_GAME, { label = "New Game", type = alex_c_api.OPTION_TYPE_BTN })

	alex_c_api.create_btn(BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(BTN_ID_REDO, "Redo", 1)
end

function handle_game_option_evt(option_id)
	if option_id == GAME_OPTION_NEW_GAME then
		session_id = alex_c_api.get_new_session_id()
		state = core.new_state()
		save_state()
		draw_board()
		broadcast_state("all")
	end
end

function save_state()
	local serialized_state = serialize.serialize_state(state)
	alex_c_api.save_state(session_id, serialized_state)
end

function get_state()
	local serialized_state = serialize.serialize_state(state)
	print(string.format("lua: returning %d bytes of state", #serialized_state))
	return serialized_state
end

local serialize = {}

function serialize_byte(val)
	if val == nil then val = 128 end
	return string.char(val)
end

function deserialize_byte(bytes)
	local val = string.byte(table.remove(bytes,1))
	if val == 128 then val = nil end
	return val
end

function bool_to_byte(val)
	if val then return 1
	else return 0 end
end

function byte_to_bool(val)
	if val == 1 then return true
	elseif val == 0 then return false
	else error(string.format("Expected 1 or 0 for bool, recvd %s", val)) end
end

function serialize_bool(val)
	return serialize_byte(bool_to_byte(val))
end

function deserialize_bool(bytes)
	return byte_to_bool(deserialize_byte(bytes))
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_bool(state.game_settings.must_jump_when_able)
	output = output .. serialize_byte(state.player_turn)
	output = output .. serialize_byte(state.selected_y)
	output = output .. serialize_byte(state.selected_x)
	output = output .. serialize_bool(state.must_jump_selected)
	local board_height = #state.board
	local board_width  = #state.board[1]
	output = output .. serialize_byte(board_height)
	output = output .. serialize_byte(board_width)
	for y=1,board_height do
		for x=1,board_width do
			output = output .. serialize_byte(state.board[y][x])
		end
	end

	return output
end

function serialize.deserialize_state(byte_str)
	local bytes = {}
	for i=1,#byte_str do
		bytes[i] = byte_str:sub(i,i)
	end

	if #bytes ~= 7 + 64 then
		error(string.format("Expected to recieve %d bytes, recvd %d", 7 + 64, #bytes))
	end

	local state = {}
	state.game_settings = {}

	state.game_settings.must_jump_when_able = deserialize_bool(bytes)
	state.player_turn         = deserialize_byte(bytes)
	state.selected_y          = deserialize_byte(bytes)
	state.selected_x          = deserialize_byte(bytes)
	state.must_jump_selected  = deserialize_bool(bytes)

	local board_height = deserialize_byte(bytes)
	local board_width = deserialize_byte(bytes)
	state.board = {}
	for y=1,board_height do
		state.board[y] = {}
		for x=1,board_width do
			state.board[y][x] = deserialize_byte(bytes)
		end
	end
	return state
end

return serialize
-- Game:   Chess
-- Author: Alex Barry (github.com/alexbarry)

local core = {}

core.BOARD_SIZE = 8

core.PLAYER_WHITE = 1
core.PLAYER_BLACK = 2
core.PIECE_COUNT  = 2

core.PIECE_PAWN   = 1
core.PIECE_ROOK   = 2
core.PIECE_KNIGHT = 3
core.PIECE_BISHOP = 4
core.PIECE_QUEEN  = 5
core.PIECE_KING   = 6
core.PIECE_TYPE_COUNT = core.PIECE_KING

core.EMPTY_PIECE_ID = 0

core.GAME_STATUS_NORMAL    = 1
core.GAME_STATUS_CHECK     = 2
core.GAME_STATUS_CHECKMATE = 3

core.SUCCESS        = 0
core.NOT_YOUR_PIECE = 1
core.NOT_YOUR_TURN  = 2
core.RC_CANT_MOVE_INTO_CHECK = 3
core.RC_MUST_RESOLVE_CHECK   = 4
core.RC_GAME_OVER            = 5
--core.INVALID_MOVE   = 2

local ERROR_CODE_MAP = {
	[core.SUCCESS]        = "Success",
	[core.NOT_YOUR_PIECE] = "Not your piece",
	[core.NOT_YOUR_TURN]  = "Not your turn",
	[core.RC_CANT_MOVE_INTO_CHECK]  = "Can not move into check",
	[core.RC_MUST_RESOLVE_CHECK]    = "Must move out of check",
	[core.RC_GAME_OVER]             = "Game over!",
}

function core.get_err_msg(rc)
	return ERROR_CODE_MAP[rc]
end

function core.get_piece_id(player, piece_type)
	return ((player - 1) * core.PIECE_TYPE_COUNT + (piece_type - 1)) + 1
end



function core.get_player(piece_id)
	if piece_id == nil then error(string.format("core.get_player called with nil arg"), 2) end

	if piece_id == core.EMPTY_PIECE_ID then return nil end
	return math.floor((piece_id-1)/core.PIECE_TYPE_COUNT) + 1
end

local function get_other_player(player)
	if     player == core.PLAYER_BLACK then return core.PLAYER_WHITE
	elseif player == core.PLAYER_WHITE then return core.PLAYER_BLACK
	else
		error(string.format("unexpected player %s", player))
	end
end

local function coords_eq(a, b)
	return a.y == b.y and a.x == b.x
end


function core.get_piece_type(piece_id)
	return ((piece_id-1) % core.PIECE_TYPE_COUNT) + 1
end

local function get_player_pawn_row(player)
	if player == core.PLAYER_WHITE then return 7
	elseif player == core.PLAYER_BLACK then return 2 end
end

function core.new_game()
	local state = {
		player_turn = core.PLAYER_WHITE,
		board = {},
		selected = nil
	}

	for y=1,core.BOARD_SIZE do
		state.board[y] = {}
		for x=1,core.BOARD_SIZE do
			state.board[y][x] = core.EMPTY_PIECE_ID
		end
	end

	for x=1,core.BOARD_SIZE do
		state.board[7][x] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_PAWN)
	end
	state.board[8][1] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_ROOK)
	state.board[8][2] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_KNIGHT)
	state.board[8][3] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_BISHOP)
	state.board[8][4] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_QUEEN)
	state.board[8][5] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_KING)
	state.board[8][6] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_BISHOP)
	state.board[8][7] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_KNIGHT)
	state.board[8][8] = core.get_piece_id(core.PLAYER_WHITE, core.PIECE_ROOK)

	for x=1,core.BOARD_SIZE do
		state.board[2][x] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_PAWN)
	end
	state.board[1][1] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_ROOK)
	state.board[1][2] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_KNIGHT)
	state.board[1][3] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_BISHOP)
	state.board[1][4] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_QUEEN)
	state.board[1][5] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_KING)
	state.board[1][6] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_BISHOP)
	state.board[1][7] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_KNIGHT)
	state.board[1][8] = core.get_piece_id(core.PLAYER_BLACK, core.PIECE_ROOK)

	return state
end

local function copy_coords(pos)
	if pos == nil then return nil end
	return { y = pos.y, x = pos.x }
end

local function copy_state(state)
	local new_state = {
		player_turn = state.player_turn,
		board       = {},
		selected    = copy_coords(state.selected),
		game_status = nil,
	}

	for y=1,core.BOARD_SIZE do
		new_state.board[y] = {}
		for x=1,core.BOARD_SIZE do
			new_state.board[y][x] = state.board[y][x]
		end
	end

	return new_state
end

function core.get_player_name(player)
	if     player == core.PLAYER_BLACK then return "Black"
	elseif player == core.PLAYER_WHITE then return "White" end
end

function core.get_status_msg(state)
	local player_name = core.get_player_name(state.player_turn)
	local game_status_str = ""
	if state.game_status == nil then
		state.game_status = core.get_game_status(state)
	end
	if state.game_status == core.GAME_STATUS_NORMAL then
		-- do nothing
	elseif state.game_status == core.GAME_STATUS_CHECK then
		game_status_str = string.format("%s is in check!", player_name)
	elseif state.game_status == core.GAME_STATUS_CHECKMATE then
		return string.format("%s is in checkmate! Game over, %s wins.", player_name, core.get_player_name(get_other_player(state.player_turn)))
	else
		error(string.format("Unhandled game_status %s", state.game_status))
	end
	if #game_status_str > 0 then
		game_status_str = game_status_str .. ' '
	end

	local action
	if state.selected == nil then
		action = "select a piece to move"
	else
		action = "select a destination"
	end
	return string.format("%s%s, %s", game_status_str, player_name, action)
end

local function get_player_letter(player)
	if player == core.PLAYER_BLACK then return 'B'
	elseif player == core.PLAYER_WHITE then return 'W'
	else
		error(string.format("Unhandled player %s", player))
	end
end

local function get_piece_letter(piece_type)
	if     piece_type == core.PIECE_KING     then return "K"
	elseif piece_type == core.PIECE_QUEEN    then return "Q"
	elseif piece_type == core.PIECE_BISHOP   then return "B"
	elseif piece_type == core.PIECE_KNIGHT   then return "N"
	elseif piece_type == core.PIECE_ROOK     then return "R"
	elseif piece_type == core.PIECE_PAWN     then return "P"
	else
		error(string.format("Unhandled piece type %s", piece_type))
	end
end

local function piece_id_to_hr_str(piece_id)
	local player     = core.get_player(piece_id)
	local piece_type = core.get_piece_type(piece_id)
	return get_player_letter(player) .. get_piece_letter(piece_type)
end

function core.print_state(state)
	--          1  2  3  4  5  6  7  8
	row_sep = '+--+--+--+--+--+--+--+--+'
	io.write(row_sep .. '\n')
	for y=1,core.BOARD_SIZE do
		io.write('|')
		for x=1,core.BOARD_SIZE do
			local piece_id   = state.board[y][x]
			if piece_id == core.EMPTY_PIECE_ID then
				io.write('  ')
			else
				io.write(piece_id_to_hr_str(piece_id))
			end
			io.write('|')
		end
		io.write('\n' .. row_sep .. '\n')
	end
end

local function get_piece_move_cells(piece_type, dy, dx)
	if piece_type == core.PIECE_KNIGHT then
		return ((math.abs(dy) == 2 and math.abs(dx) == 1) or
		        (math.abs(dy) == 1 and math.abs(dx) == 2))
	elseif piece_type == core.PIECE_KING then
		return math.abs(dx) <= 1 and math.abs(dy) <= 1 and
		       (math.abs(dy) > 0 or math.abs(dx) > 0)
	end
end

local function get_piece_move_vecs(piece_type)
	if piece_type == core.PIECE_ROOK then
		return { { y=1, x=0 }, {y=-1, x=0}, {y=0, x=1}, {y=0, x=-1} }
	elseif piece_type == core.PIECE_BISHOP then
		return { { y=1, x=1 }, {y=-1, x=1}, {y=1, x=-1}, {y=-1, x=-1} }
	elseif piece_type == core.PIECE_QUEEN then
		return { { y=1, x=0 }, {y=-1, x=0}, {y=0, x=1},  {y= 0, x=-1},
		         { y=1, x=1 }, {y=-1, x=1}, {y=1, x=-1}, {y=-1, x=-1} }
	else
		return {}
	end
end


local function out_of_range(pos)
	return not (1 <= pos.x and pos.x <= core.BOARD_SIZE and
	            1 <= pos.y and pos.y <= core.BOARD_SIZE)
end

local function get_player_move_dir(player)
	if player == core.PLAYER_WHITE then return -1
	elseif player == core.PLAYER_BLACK then return 1 end
end

local function get_player_rel_delta_pos(player, src, dst)
	local dy = dst.y - src.y
	local dx = dst.x - src.x

	dy = get_player_move_dir(player) * dy

	return { dy = dy, dx = dx }
end

-- Checks if a move can be made by that kind of piece, and that
-- no pieces are in the way.
-- Does not check if the move results in check or checkmate. (i.e.
-- this can return true for moves that would put your own king in check)
-- Also doesn't check for castling or en passant
local function is_valid_move_pos(state, src, dst)
	local src_piece_id = state.board[src.y][src.x]
	local dst_piece_id = state.board[dst.y][dst.x]

	local src_player = core.get_player(src_piece_id)
	local src_piece_type = core.get_piece_type(src_piece_id)

	local dst_player = core.get_player(dst_piece_id)

	local delta_pos = get_player_rel_delta_pos(src_player, src, dst)
	local dy = delta_pos.dy
	local dx = delta_pos.dx

	if src_piece_type == core.PIECE_PAWN then
		if dx == 0 then
			if dy == 1 and dst_piece_id == core.EMPTY_PIECE_ID then
				return true
			elseif dy == 2 and src.y == get_player_pawn_row(src_player) then
				return (state.board[src.y+1*get_player_move_dir(src_player)][src.x] == core.EMPTY_PIECE_ID and
				        state.board[src.y+2*get_player_move_dir(src_player)][src.x] == core.EMPTY_PIECE_ID)
			end
		elseif math.abs(dx) == 1 and dy == 1 then
			return core.get_player(dst_piece_id) == get_other_player(src_player)
		else
			return false
		end
	elseif get_piece_move_cells(src_piece_type, dy, dx) then
		return dst_piece_id == core.EMPTY_PIECE_ID or dst_player ~= src_player
	else
		for _, move_vec in ipairs(get_piece_move_vecs(src_piece_type)) do
			for i=1,core.BOARD_SIZE do
				local dst2 = { y = src.y + move_vec.y*i,
				               x = src.x + move_vec.x*i}
				if out_of_range(dst2) then
					goto next_move_vec
				end
				local dst2_piece_id = state.board[dst2.y][dst2.x]
				if core.get_player(dst2_piece_id) == src_player then
					goto next_move_vec
				elseif core.get_player(dst2_piece_id) == get_other_player(src_player) then
					if coords_eq(dst, dst2) then
						return true
					end
					goto next_move_vec
				else
					if coords_eq(dst, dst2) then
						return true
					end
				end
			end
			::next_move_vec::
		end
	end
end

function core.get_possib_dsts(state, src)
	local piece_id = state.board[src.y][src.x]
	if piece_id == core.EMPTY_PIECE_ID then return {} end
	local piece_type = core.get_piece_type(piece_id)
	local player = core.get_player(piece_id)

	local possib_dsts = {}

	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
			local dst_piece_id = state.board[y][x]

			if is_valid_move_pos(state, src, {y=y, x=x}) then
				table.insert(possib_dsts, {y=y, x=x})
			end

			::next_dst::
		end
	end

	return possib_dsts
end

function core.in_check(state, player)
	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
			local src = { y = y, x = x }
			local src_piece_id = state.board[y][x]
			-- Only check other player's pieces
			if src_piece_id == core.EMPTY_PIECE_ID or
			   core.get_player(src_piece_id) == player then
				goto next_square
			end

			local dsts = core.get_possib_dsts(state, src)
			for _, dst in ipairs(dsts) do
				local dst_piece_id = state.board[dst.y][dst.x]
				-- See if any of them could capture the king on their next move
				if core.get_piece_type(dst_piece_id) == core.PIECE_KING and
				   core.get_player(dst_piece_id) == player then
					return true
				end
				
			end

			::next_square::
		end
	end
	return false
end

local function move_piece(state, src, dst)
	local piece_id = state.board[src.y][src.x]
	local this_player = core.get_player(piece_id)
	if piece_id == core.EMPTY_PIECE_ID then
		return core.SUCCESS
	end

	local state_copy = copy_state(state)
	state_copy.board[src.y][src.x] = core.EMPTY_PIECE_ID
	state_copy.board[dst.y][dst.x] = piece_id
	state_copy.selected = nil
	state_copy.player_turn = get_other_player(state.player_turn)
	if core.in_check(state_copy, this_player) then
		return core.RC_CANT_MOVE_INTO_CHECK
	end

	state.board[src.y][src.x] = core.EMPTY_PIECE_ID
	state.board[dst.y][dst.x] = piece_id
	state.selected = nil
	state.player_turn = get_other_player(state.player_turn)
	state.game_status = core.get_game_status(state)
	if state.game_status == core.GAME_STATUS_CHECKMATE then
		return core.RC_GAME_OVER
	end
	return core.SUCCESS
end

local function get_player_pieces(state, player)
	local pieces_pos = {}
	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
			local piece_id = state.board[y][x]
			if piece_id ~= core.EMPTY_PIECE_ID and
			   core.get_player(piece_id) == player then
				table.insert(pieces_pos, {y=y, x=x})
			end
		end
	end
	return pieces_pos
end

function core.get_game_status(state)
	local in_check = core.in_check(state, state.player_turn)

	if not in_check then
		return core.GAME_STATUS_NORMAL
	else
		for _, src_pos in ipairs(get_player_pieces(state, state.player_turn)) do
			for _, dst_pos in ipairs(core.get_possib_dsts(state, src_pos)) do
				local state_copy = copy_state(state)
				local rc = move_piece(state_copy, src_pos, dst_pos)
				if rc == core.SUCCESS then
					return core.GAME_STATUS_CHECK
				end
			end
		end
		return core.GAME_STATUS_CHECKMATE
	end
end

function core.player_touch(state, player, coords)
	if player ~= state.player_turn then
		return core.NOT_YOUR_TURN
	end

	if state.selected == nil then
		if coords == nil then return core.SUCCESS end
		local dst_piece_id = state.board[coords.y][coords.x]
		if core.get_player(dst_piece_id) ~= player then
			return core.NOT_YOUR_PIECE
		else
			state.selected = coords
			return core.SUCCESS
		end
	else
		if coords == nil or coords_eq(coords, state.selected) then
			state.selected = nil
			return core.SUCCESS
		else
			if not is_valid_move_pos(state, state.selected, coords) then
				local dst_piece_id = state.board[coords.y][coords.x]
				-- If the player clicks on one of their own pieces, select that one instead
				if core.get_player(dst_piece_id) == player then
					print("player selected a different piece")
					state.selected = coords
				-- If the player clicks on an empty piece or enemy piece that can't be captured,
				-- unselect
				else
					print("player selected an empty or other player piece")
					state.selected = nil
				end
				return core.SUCCESS
			else
				local rc = move_piece(state, state.selected, coords)
				if rc == core.RC_CANT_MOVE_INTO_CHECK then
					if core.in_check(state, state.player_turn) then
						return core.RC_MUST_RESOLVE_CHECK
					end
				end
				return rc
			end
		end
	end
end

return core
-- Game:   Chess
-- Author: Alex Barry (github.com/alexbarry)

local draw = {}

local alex_c_api   = require("alex_c_api")
local draw_more    = require("libs/draw/draw_more")
local draw_shapes  = require("libs/draw/draw_shapes")
local draw_colours = require("libs/draw/draw_colours")

local core = require("games/chess/chess_core")


local board_height = nil
local board_width  = nil
local show_labels  = nil

local OUTLINE_WIDTH = 4
local cell_size    = nil
local piece_padding = 0
local border_padding = 20

local LABEL_COLOUR = '#000000'
local LABEL_FONT_SIZE = 12
-- the number of pixels taken up by the parts of a letter that are drawn below the line, like the "tail" of the letter "g"
local text_y_buffer = 4

--local CELL_COLOUR_WHITE = '#ffffff'
--local CELL_COLOUR_WHITE = '#dc802f'
--local CELL_COLOUR_BLACK = '#000000'
local CELL_COLOUR_WHITE = '#ffce9e'
local CELL_COLOUR_BLACK = '#d18b47'
local PIECE_SEL_HIGHLIGHT_OUTLINE = draw_colours.ALT_HIGHLIGHT_OUTLINE
local PIECE_SEL_HIGHLIGHT_COLOUR = draw_colours.ALT_HIGHLIGHT_FILL

local PIECE_SEL_HIGHLIGHT_OUTLINE_REMOTE = draw_colours.ALT_HIGHLIGHT_OUTLINE_REMOTE
local PIECE_SEL_HIGHLIGHT_COLOUR_REMOTE = draw_colours.ALT_HIGHLIGHT_FILL_REMOTE

local function get_cell_colour_white()
	if alex_c_api.get_user_colour_pref() == "very_dark" then
		return '#352215cc'
	elseif alex_c_api.get_user_colour_pref() == "dark" then
		return '#453225'
	else
		return CELL_COLOUR_WHITE
	end
end

local function get_cell_colour_black()
	if alex_c_api.get_user_colour_pref() == "very_dark" then
		return '#201000cc'
	elseif alex_c_api.get_user_colour_pref() == "dark" then
		return '#302005'
	else
		return CELL_COLOUR_BLACK
	end
end
local DST_HIGHLIGHT_OUTLINE        = draw_colours.HIGHLIGHT_OUTLINE
local DST_HIGHLIGHT_COLOUR         = draw_colours.HIGHLIGHT_FILL
local DST_HIGHLIGHT_OUTLINE_REMOTE = draw_colours.HIGHLIGHT_OUTLINE_REMOTE
local DST_HIGHLIGHT_COLOUR_REMOTE  = draw_colours.HIGHLIGHT_FILL_REMOTE

function draw.init(height, width, show_labels_arg)
	board_height = height
	board_width  = width

	show_labels = show_labels_arg
	if not show_labels then
		border_padding = 0
	end

	cell_size = math.floor((math.min(board_height, board_width) - 2*border_padding) / core.BOARD_SIZE)
end

local function is_cell_white(y, x)
	return (y*(core.BOARD_SIZE+1) + x) % 2 ~= 0
end

local function get_piece_graphic_id(player, piece_type, params)
	if params == nil then params = {} end

	if player == core.PLAYER_BLACK then
		if params.is_dark then
			if     piece_type == core.PIECE_ROOK   then return 'chess_rook_black_dark'
			elseif piece_type == core.PIECE_KNIGHT then return 'chess_knight_black_dark'
			elseif piece_type == core.PIECE_BISHOP then return 'chess_bishop_black_dark'
			elseif piece_type == core.PIECE_QUEEN  then return 'chess_queen_black_dark'
			elseif piece_type == core.PIECE_KING   then return 'chess_king_black_dark'
			elseif piece_type == core.PIECE_PAWN   then return 'chess_pawn_black_dark'
			else
				error(string.format("Unexpected piece_type: %s", piece_type))
			end
		else
			if     piece_type == core.PIECE_ROOK   then return 'chess_rook_black'
			elseif piece_type == core.PIECE_KNIGHT then return 'chess_knight_black'
			elseif piece_type == core.PIECE_BISHOP then return 'chess_bishop_black'
			elseif piece_type == core.PIECE_QUEEN  then return 'chess_queen_black'
			elseif piece_type == core.PIECE_KING   then return 'chess_king_black'
			elseif piece_type == core.PIECE_PAWN   then return 'chess_pawn_black'
			else
				error(string.format("Unexpected piece_type: %s", piece_type))
			end
		end
	elseif player == core.PLAYER_WHITE then
		if     piece_type == core.PIECE_ROOK   then return 'chess_rook_white'
		elseif piece_type == core.PIECE_KNIGHT then return 'chess_knight_white'
		elseif piece_type == core.PIECE_BISHOP then return 'chess_bishop_white'
		elseif piece_type == core.PIECE_QUEEN  then return 'chess_queen_white'
		elseif piece_type == core.PIECE_KING   then return 'chess_king_white'
		elseif piece_type == core.PIECE_PAWN   then return 'chess_pawn_white'
		else
			error(string.format("Unexpected piece_type: %s", piece_type))
		end
	else
		error(string.format("Unexpected player: %s", player))
	end
end

function draw.draw_coords_to_cell(y, x)
	y = y - border_padding
	x = x - border_padding
	local y_idx = math.floor(y/cell_size)+1
	local x_idx = math.floor(x/cell_size)+1

	if 1 <= x_idx and x_idx <= core.BOARD_SIZE and
	   1 <= y_idx and y_idx <= core.BOARD_SIZE then
		return { y=y_idx, x=x_idx }
	else
		return nil
	end
end

function draw_rect_at_pos(colour, outline_colour, y, x)
	cell_start_y = border_padding + (y-1)*cell_size
	cell_start_x = border_padding + (x-1)*cell_size

	cell_end_y   = border_padding + (y  )*cell_size
	cell_end_x   = border_padding + (x  )*cell_size
	alex_c_api.draw_rect(colour,
	                     cell_start_y, cell_start_x,
	                     cell_end_y  , cell_end_x)
	if outline_colour then
		draw_shapes.draw_rect_outline(outline_colour, OUTLINE_WIDTH,
		                     cell_start_y, cell_start_x,
		                     cell_end_y  , cell_end_x)
	end
end

local function get_col_label(col)
	return string.char(string.byte('a') + col-1)
end

local function get_row_label(row)
	return string.format('%d', row)
end

local function get_piece_brightness(player)
	if alex_c_api.get_user_colour_pref() == "very_dark" then
		return 35
	elseif alex_c_api.get_user_colour_pref() == "dark" then
		return 50
	else
		return 100
	end
end

local function draw_piece_graphic(player, piece_type, pos_y, pos_x, size_y, size_x)
	local img_id = get_piece_graphic_id(player, piece_type)
	local brightness = get_piece_brightness(player)
	local invert = false
	
	local brightness = get_piece_brightness(player)
	local user_colour_pref = alex_c_api.get_user_colour_pref()
	if user_colour_pref == "very_dark" or user_colour_pref == "dark" then
		if player == core.PLAYER_BLACK then
			img_id = get_piece_graphic_id(core.PLAYER_BLACK, piece_type, {is_dark = true})
			--img_id = get_piece_graphic_id(core.PLAYER_WHITE, piece_type)
			-- invert = true -- originally I just inverted the white piece, but safari doesn't support that
			brightness = 50
		end
	end
	draw_more.draw_graphic_ul(img_id, 
	                          pos_y, pos_x,
	                          size_y, size_x,
	                          { invert = invert, brightness_percent = brightness } )
end


function draw.draw_state(state, params)
	alex_c_api.draw_clear()
	alex_c_api.draw_rect('#000000', 0, 0, board_height, board_width)
	-- Draw checkerboard
	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
			local cell_colour
			if is_cell_white(y,x) then
				cell_colour = get_cell_colour_white()
			else
				cell_colour = get_cell_colour_black()
			end
			draw_rect_at_pos(cell_colour, nil, y, x)
		end
	end

	-- Add labels to rows and columns
	if show_labels then
		for _, y_pos in ipairs({border_padding-text_y_buffer, border_padding + core.BOARD_SIZE*cell_size+LABEL_FONT_SIZE}) do
			for x=1,core.BOARD_SIZE do
				local label = get_col_label(x)
				alex_c_api.draw_text(label, LABEL_COLOUR,
				                     y_pos,  border_padding + math.floor(cell_size*(x-0.5)),
				                     LABEL_FONT_SIZE, 0)
			end
		end
	
		for _, x_pos_info in ipairs({{pos = border_padding, align=-1}, {pos = board_width-border_padding, align=1}}) do
			for y=1,core.BOARD_SIZE do
				local label = get_row_label(y)
				alex_c_api.draw_text(label, LABEL_COLOUR,
				                     border_padding + math.floor(cell_size*(y-0.5)), x_pos_info.pos,
				                     LABEL_FONT_SIZE, x_pos_info.align)
			end
		end
	end

	local highlight_colour = PIECE_SEL_HIGHLIGHT_COLOUR
	local highlight_outline = PIECE_SEL_HIGHLIGHT_OUTLINE
	local dst_highlight = DST_HIGHLIGHT_COLOUR
	local dst_outline = DST_HIGHLIGHT_OUTLINE

	if not params.local_multiplayer and params.player ~= state.player_turn then
		highlight_colour = PIECE_SEL_HIGHLIGHT_COLOUR_REMOTE
		highlight_outline = PIECE_SEL_HIGHLIGHT_OUTLINE_REMOTE
		dst_highlight = DST_HIGHLIGHT_COLOUR_REMOTE
		dst_outline = DST_HIGHLIGHT_OUTLINE_REMOTE
	end

	-- If a cell is selected, highlight it
	if state.selected ~= nil then
		draw_rect_at_pos(highlight_colour, highlight_outline, state.selected.y, state.selected.x)
	
		-- Also highlight the possible moves that could be made by the selected piece
		local possib_dsts = core.get_possib_dsts(state, state.selected)
		for _, possib_dst in ipairs(possib_dsts) do
			draw_rect_at_pos(dst_highlight, dst_outline, possib_dst.y, possib_dst.x)
		end
	end

	-- Finally, draw the pieces (on top of the highlights)
	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
		local piece_id = state.board[y][x]
		local player = core.get_player(piece_id)
			if piece_id ~= core.EMPTY_PIECE_ID then
				local piece_type  = core.get_piece_type(piece_id)

				local piece_pos_y = border_padding + (y-1)*cell_size + piece_padding
				local piece_pos_x = border_padding + (x-1)*cell_size + piece_padding
				local piece_size_y = cell_size - 2*piece_padding
				local piece_size_x = cell_size - 2*piece_padding

				draw_piece_graphic(player, piece_type,
				                   piece_pos_y, piece_pos_x,
				                   piece_size_y, piece_size_x)
			end
		end
	end

	alex_c_api.draw_refresh()
end

return draw
-- Game:   Chess
-- Author: Alex Barry (github.com/alexbarry)
--[[
TODO:
* implement logic for check and checkmate
* prevent player from moving into check
* implement serializing state so state can be saved or network games can be played
* implement castling
* implement pawn en-passant capturing?? (I didn't even know about this rule)
* implement history (undo/redo)
--]]
local alex_c_api = require("alex_c_api")

local core = require("games/chess/chess_core")
local draw = require("games/chess/chess_draw")
local serialize = require("games/chess/chess_serialize")

local utils = require("libs/utils")
local two_player = require("libs/multiplayer/two_player")

local g_session_id = alex_c_api.get_new_session_id()
local g_state = core.new_game()
--local player = core.PLAYER_WHITE
local player = nil
local local_multiplayer = nil
local player_name_to_id = {}
local g_other_player = nil
local session_id = alex_c_api.get_new_session_id()

local SELECT_PLAYER_POPUP_ID = "select_player"
local PLAYER_CHOICE_BTNS = {
	"White",
	"Black",
}
local BTN_MAP = {
    [0] = core.PLAYER_WHITE,
    [1] = core.PLAYER_BLACK,
}


local BTN_ID_UNDO = "btn_undo"
local BTN_ID_REDO = "btn_redo"

local POPUP_ID_NEW_GAME          = "game_over"
local POPUP_ITEM_ID_NEW_GAME_BTN = 1

local OPTION_ID_NEW_GAME = "new_game"

function get_player()
	if local_multiplayer then
		return g_state.player_turn
	else
		return player
	end
end

function get_other_player(player)
	if player == core.PLAYER_WHITE then
		return core.PLAYER_BLACK
	elseif player == core.PLAYER_BLACK then
		return core.PLAYER_WHITE
	else
		error(string.format("unexpected player: %s", player), 2)
	end
end

local function get_draw_state_params()
	return {
		local_multiplayer = local_multiplayer,
		player            = player,
	}
end

draw.init(480,480, false)
local function draw_board_internal()
	--core.print_state(g_state)
	draw.draw_state(g_state, get_draw_state_params())
	alex_c_api.set_btn_enabled(BTN_ID_UNDO, alex_c_api.has_saved_state_offset(g_session_id, -1))
	alex_c_api.set_btn_enabled(BTN_ID_REDO, alex_c_api.has_saved_state_offset(g_session_id,  1))
end

function draw_board()
	draw_board_internal()
end

function handle_rc(rc, is_other_player)
	if rc == core.SUCCESS then
		-- TODO need to come up with a way to only save real moves
		save_state()
		alex_c_api.set_status_msg(core.get_status_msg(g_state))
		local state_serialized = serialize.serialize_state(g_state)
		print(string.format("State is now: %s", utils.binstr_to_hr_str(state_serialized)))
	elseif rc == core.RC_GAME_OVER then
		local msg = core.get_status_msg(g_state)
		alex_c_api.set_status_msg(msg)
		alex_c_api.show_popup(POPUP_ID_NEW_GAME, { title = "Game Over", items = {
			{ item_type = alex_c_api.POPUP_ITEM_TYPE_MSG, msg = msg },
			{ id = POPUP_ITEM_ID_NEW_GAME_BTN, item_type = alex_c_api.POPUP_ITEM_TYPE_BTN, text = "New Game" },
		} })
	else
		local msg = core.get_err_msg(rc)
		if is_other_player then
			msg = "Other player invalid move: " .. msg
		end
		alex_c_api.set_status_err(msg)
	end
end

function handle_user_clicked(pos_y, pos_x)
	local coords = draw.draw_coords_to_cell(pos_y, pos_x)
	local rc = core.player_touch(g_state, get_player(), coords)
	if not local_multiplayer and rc == core.SUCCESS then
		alex_c_api.send_message("all", string.format("move:%d,%d,%d", get_player(), coords.y, coords.x))
	end
	handle_rc(rc)
	--core.print_state(g_state)
	draw_board_internal()
end

function handle_popup_btn_clicked(popup_id, btn_id, popup_state)
	 if two_player.handle_popup_btn_clicked(popup_id, btn_id) then
        -- handled
	elseif popup_id == POPUP_ID_NEW_GAME then
		if btn_id == POPUP_ITEM_ID_NEW_GAME_BTN then
			start_game()
			alex_c_api.hide_popup()
		else	
			error(string.format("Unhandled btn_id=\"%s\"", btn_id))
		end
	else
		error(string.format("Unhandled popup_id=\"%s\"", popup_id))
	end
end

local function broadcast_state(dst)
	alex_c_api.send_message(dst, "state:" .. serialize.serialize_state(g_state))
end

function handle_msg_received(src, msg)
    print("Recvd msg " .. msg)

    if two_player.handle_msg_received(src, msg) then
        return
    end

    local m = msg:gmatch("([^:]+):(.*)")
    if m == nil then
        print("Unable to parse header from msg " .. msg)
        return
    end
    local header, payload = m()

    if header == "move" then
        local m2 = payload:gmatch("(%d+),(%d+),(%d+)")
        if m2 == nil then
            error("Invalid \"move\" msg from " .. src)
            return
        end
        local player_idx, y, x = m2()
        player_idx = tonumber(player_idx)
        y = tonumber(y)
        x = tonumber(x)
		local coords = { y = y, x = x }
        local rc = core.player_touch(g_state, player_idx, coords)
        handle_rc(rc, --[[is_other_player=]] true)

        if rc ~= core.SUCCESS then
            alex_c_api.set_status_err("Other player made an invalid move")
        else
            alex_c_api.set_status_msg("Your move")
            draw_board_internal()
            save_state()
        end

    elseif header == "get_state" then
		broadcast_state(src)
    elseif header == "state" then
        local recvd_state = serialize.deserialize_state(payload)
        print("Recieved state:")
        --core.print_state(recvd_state)
        g_state = recvd_state
        draw_board_internal()
        save_state()
    elseif header == "player_left" and src == "ctrl" then
    elseif header == "player_joined" then
    else
        error("Unhandled message: " .. header )
    end
end

function two_player_init()
    local args = {
        supports_local_multiplayer = true,
        title = "Choose piece colour",
        player_choices = PLAYER_CHOICE_BTNS,
        handle_multiplayer_type_choice = function (multiplayer_type)
            if multiplayer_type == two_player.MULTIPLAYER_TYPE_LOCAL then
                local_multiplayer = true
				player = g_state.player_turn
            elseif multiplayer_type == two_player.MULTIPLAYER_TYPE_NETWORK then
                local_multiplayer = false
            end
        end,
        choice_id_to_player_id = function (btn_id)
            return BTN_MAP[btn_id]
        end,
        player_name_to_id = player_name_to_id,
        player_id_to_nice_name = function (player_id)
            local player_colour = core.get_player_name(player_id)
            return utils.make_first_char_uppercase(player_colour)
        end,
        get_msg = function ()
            local msg = "White moves first."
            if utils.table_len(player_name_to_id) == 0 then
                msg = msg .. "\nThe other player has not yet chosen."
            else
                --msg = msg .. string.format("The other player has chosen %s",
                --                           core.player_id_to_name(other_player))
                for player_name, player_id in pairs(player_name_to_id) do
                    local player_colour = core.get_player_name(player_id)
                    msg = msg .. string.format("\n%s is chosen by %s", utils.make_first_char_uppercase(player_colour), player_name)
                end
            end
            return msg
        end,
        handle_player_choice = function (player_name, player_id)
            local choice_str = core.get_player_name(player_id)
            print(string.format("handle_player_choice{ player_name=\"%s\", choice=%q (%q) }", player_name, player_id, choice_str))
            if player_name == two_player.LOCAL_PLAYER then
                player = player_id
            else
                g_other_player = player_id
            end
        end,

        need_reselect = function ()
            local this_player  = player
            local other_player = g_other_player

            return this_player == nil or this_player == other_player
        end,

        get_local_player_choice = function ()
            return player
        end
    }

	two_player.init(args)
end

local function load_state(session_id_arg, state_serialized)
	g_session_id = session_id_arg
	g_state = serialize.deserialize_state(state_serialized)
end

local function load_state_offset(session_id_arg, move_offset)
	local state_serialized = alex_c_api.get_saved_state_offset(session_id_arg, move_offset)
	if state_serialized == nil then
		error(string.format("state_serialized is nil"))
	end
	load_state(session_id_arg, state_serialized)
	broadcast_state("all")
end

function save_state()
	local serialized_state = serialize.serialize_state(g_state)
	alex_c_api.save_state(g_session_id, serialized_state)
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_UNDO then
		load_state_offset(g_session_id, -1)
		draw_board_internal()
	elseif btn_id == BTN_ID_REDO then
		load_state_offset(g_session_id, 1)
		draw_board_internal()
	else
		error(string.format("Unhandled btn_id %s", btn_id)) 
	end
end

function handle_game_option_evt(option_id)
	if option_id == OPTION_ID_NEW_GAME then
		g_session_id = alex_c_api.get_new_session_id()
		g_state = core.new_game()
		save_state()
		draw_board_internal()
	end
end

function get_state()
	return serialize.serialize_state(g_state)
end

function start_game(session_id_arg, state_serialized)
	local state_loaded = false
	if state_serialized ~= nil then
		load_state(session_id_arg, state_serialized)
		state_loaded = true
	else
		local saved_session_id = alex_c_api.get_last_session_id()
		if saved_session_id ~= nil and alex_c_api.has_saved_state_offset(saved_session_id, 0) then
			alex_c_api.set_status_msg(string.format("Loading saved state session %d", saved_session_id))
			load_state_offset(saved_session_id, 0)
			state_loaded = true
		end
	end

	two_player_init()

	alex_c_api.send_message("all", "get_state:")

	alex_c_api.add_game_option(OPTION_ID_NEW_GAME, { type = alex_c_api.OPTION_TYPE_BTN, label = "New Game" })

	alex_c_api.create_btn(BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(BTN_ID_REDO, "Redo", 1)
	--[[
	g_session_id = alex_c_api.get_new_session_id()
	g_state = core.new_game()
	player = core.PLAYER_WHITE
	local_multiplayer = true
	draw_board()
	--]]
end
local serialize = {}

local core = require("games/chess/chess_core")
local serialize_lib = require("libs/serialize/serialize")

function serialize.deserialize_state(byte_str)
	local bytes = serialize_lib.bytestr_to_byteary(byte_str)
	local state = {}
	state.player_turn = serialize_lib.deserialize_byte(bytes)
	state.board = {}
	state.selected = nil
	for y=1,core.BOARD_SIZE do
		state.board[y] = {}
		for x=1,core.BOARD_SIZE do
			state.board[y][x] = serialize_lib.deserialize_byte(bytes)
		end
	end

	if #bytes ~= 0 then
		error(string.format("%d bytes remaining after deserializing", #bytes))
	end

	return state
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(state.player_turn)
	for y=1,core.BOARD_SIZE do
		for x=1,core.BOARD_SIZE do
			output = output .. serialize_lib.serialize_byte(state.board[y][x])
		end
	end

	return output
end

return serialize
local core = {}
-- Notes from what I remember Sabrina telling me:
-- state.PICK_DISCARD
--     players are given enough cards that they can discard 0 to 2 and end up with 4 cards in their hand,
--     and total of 4 discarded cards that form the "crib" of one player.
-- state.PLAY
--     A card might be drawn from the deck at this point
--     Players then take turns playing one of the cards from their hand.
--     They are awarded points if the running total is 15, 31, there is a run (cards in order (or reverse order?)),
--     or four of a suit(?), and last card
--     At the end, the player whose crib it is gets awarded points for the cards in their crib.

local cards = require("libs/cards/cards")

-- TODO implement last card:
--    * still need to award a point for last card once all cards are played
--      (should add an acknowledgemepoint phase for that where all players must press "next"
--    * use this stage once 31 is reached normally
--    maybe just add a boolean like "wait_for_next_btn" which is set to true
--    only when a sum of 31 is reached, or when all players' hands are empty?
--    Need to figure out how to make this co-exist with the "can't move" button.
--    Maybe rename that one to "next"

-- TODO should implement winner, make sure points are awarded in the right order

-- TODO if a card is played resulting in a sum of 31 , clear the play thing?

-- TODO the last card played in PLAY state isn't visible to the other player(s), it
-- immediately jumps to showing your old hand. Should add a "next" button to let people acknowledge,
-- then transition to this state

-- TODO on a new hand, make sure its the player's turn who is to the left of the crib

-- TODO add an array of "last_points_reasons" in state, send to other players?
-- indicating player, points reason, and amount?
-- set it to true only for events like jack of suit on cut deck card, playing points, last card?
-- use this to show status messages, so players notice when points are added

core.states = {
	-- Players start with some number of cards and must discard to the "crib" until they have 4 left
	-- Can only exit this state once all players have discarded.
	PICK_DISCARD = 1,
	-- Players play a card, and are awarded points if they get 15/run/4 of the same suit/31
	PLAY         = 2,

	-- After the above "PLAY" state, players also get awarded points based on the 4 cards they played, plus
	-- a card from the deck that is shared by everyone.
	-- Reveal the cards to the player in this state, and proceed back to PICK_DISCARD once all players
	-- have acknowledged
	ACKNOWLEDGE_POINTS = 3,

	-- Similar to the above state, but only the player whose crib it is gets points
	ACKNOWLEDGE_CRIB = 4,
}

core.actions = {
	HAND = 1,
	DISCARD_CONFIRM = 2,
	CANT_MOVE_ACCEPT = 3,
	NEXT = 4,
}

core.point_types = {
	FIFTEEN    = 1,
	RUN        = 2,
	PAIR       = 3,
	THIRTY_ONE = 4,
	FLUSH      = 5,
	JACK_OF_SUIT = 6,
}

core.CARDS_PER_HAND = 4
core.MAX_PLAYING_SUM = 31

core.RC_SUCCESS                    = 0
core.RC_ERROR                      = -1
core.RC_WAIT_FOR_OTHERS_TO_DISCARD = -2
core.RC_NOT_YOUR_TURN              = -3
core.RC_INVALID_PARAM              = -4
core.RC_PLAY_HIGHER_THAN_31        = -5
core.RC_MUST_MOVE                  = -6

local rc_to_str_map = {
	[core.RC_SUCCESS]                    = "Success",
	[core.RC_ERROR]                      = "Error",
	[core.RC_WAIT_FOR_OTHERS_TO_DISCARD] = "Wait for other players to discard",
	[core.RC_NOT_YOUR_TURN]              = "Not your turn",
	-- I don't think the user should be able to hit this unless there's a UI error or state mismatch
	[core.RC_INVALID_PARAM]              = "Invalid parameters",
	[core.RC_PLAY_HIGHER_THAN_31]        = "Must play a card which results in a sum less than 31",
	[core.RC_MUST_MOVE]                  = "Can only skip turn if no cards can be played",
}

local JACK_OF_SUIT_CUT_DECK_POINTS  = 2
local JACK_OF_SUIT_HAND_CRIB_POINTS = 1
local LAST_CARD_POINTS              = 1

function core.rc_to_str(rc)
	return rc_to_str_map[rc]
end

function core.point_type_to_str(reason)
	local map = {
		[core.point_types.FIFTEEN]    = 'Fifteen',
		[core.point_types.RUN]        = 'Run',
		[core.point_types.PAIR]       = 'Pair',
		[core.point_types.THIRTY_ONE] = 'Thirty-one',
		[core.point_types.FLUSH]      = 'Flush',
		[core.point_types.JACK_OF_SUIT] = 'Jack of suit',
	}
	return map[reason]
end

local function deal_new_hand(state, do_shuffle)
	state.cut_deck_card = nil
	state.crib = {}
	state.playing_sequence = {}
	state.playing_sum = 0

	if do_shuffle then
		state.deck = cards.new_deck()
		cards.shuffle(state.deck)
	end

	-- each player gets at least 4 cards, 
	-- and then an extra 4 cards are distributed among the players evenly (if possible)
	-- The player must discard cards (into the crib) until they have 4 left.
	-- If the crib does not have 4 cards right now, add deck cards until it is 4
	local player_cards_to_discard = math.floor(core.CARDS_PER_HAND/state.player_count)
	local cards_per_hand = core.CARDS_PER_HAND + player_cards_to_discard
	local deck_cards_to_crib = core.CARDS_PER_HAND - player_cards_to_discard * state.player_count
	for player_idx=1,state.player_count do
		state.hands[player_idx] = {}
		state.tentative_discards[player_idx] = {}
		state.playing[player_idx] = {}
		state.played[player_idx] = {}
		for _=1,cards_per_hand do
			table.insert(state.hands[player_idx], table.remove(state.deck, 1))
			table.insert(state.tentative_discards[player_idx], false)
		end
	end
	for _=1,deck_cards_to_crib do
		table.insert(state.crib, table.remove(state.deck))
	end
end


-- deck is optional, if nil or not provided then will generate and shuffle a deck
function core.new_game(player_count, deck)
	if deck == nil then
		deck = cards.new_deck()
		cards.shuffle(deck)
	end
	local state = {
		state = core.states.PICK_DISCARD,
		player_count = player_count,
		deck = deck,
		score = {},
		hands = {},

		-- extra card that is drawn after the discard is done, but before players start playing/pegging
		cut_deck_card = nil, -- is this name good?

		-- these are cards that count towards the current total of 31
		playing = {},

		-- these are cards that at one point counted towards the
		-- total of 31, but the limit was reached and now
		-- they are put aside until everyone has played all the cards
		-- in their hands, so that later all the played cards can be looked
		-- at to determine points
		played = {},

		-- these are copies of cards that have been played in the `playing` array
		-- Used to calculate runs/flush/etc
		playing_sequence = {},

		-- these are cards that the user has selected to discard for the crib, but they haven't yet
		-- pressed the "confirm discard" button
		tentative_discards = {},

		crib = {},

		-- array of booleans for if the player has pressed "next" when seeing the points from their hand
		-- once all have played their cards.
		-- Once all players press "next", move on to the crib
		acknowledged_points = {},

		player_crib = 1,
		player_turn = 1,
		playing_sum  = 0,

		-- set this to the player index when a player can't move.
		--    * if another player can move, clear it.
		--    * if another player can not move, leave it set.
		--      If it is still set when we return to the player who 
		--      set it originally, and that player can not move, then
		--      end that round of play
		--      (put `playing` cards in `played`, reset `playing_sum`)
		first_player_cant_move = 0,
	}
	for player_idx=1,state.player_count do
		state.score[player_idx] = 0
	end

	deal_new_hand(state, false)

	return state
end


function core.print_state(state)
	if state == nil then
		io.write("state = nil\n")
		return
	end
	io.write("state = {\n")
	io.write(string.format("    state = %s\n", state.state))
	io.write(string.format("    player_turn = %s\n", state.player_turn))
	io.write(string.format("    player_crib = %s\n", state.player_crib))
	io.write(string.format("    playing_sum  = %s\n", state.playing_sum))
	if state.deck ~= nil then
		io.write(string.format("    deck len = %d\n", #state.deck))
	else
		io.write(string.format("    deck = nil\n"))
	end

	io.write(string.format("    first_player_cant_move = %d\n", state.first_player_cant_move ))

	io.write(string.format("    playing_sequence = %s\n", cards.card_array_to_string(state.playing_sequence)))

	io.write(string.format("    hands[%d] = {\n", #state.hands))
	for player_idx, hand in pairs(state.hands) do
		io.write(string.format("      [%d] = ", player_idx))
		io.write(cards.card_array_to_string(hand))
		io.write(",\n")
	end
	io.write(string.format("    },\n"))

	io.write(string.format("    playing[%d] = {\n", #state.playing))
	for player_idx, playing in pairs(state.playing) do
		io.write(string.format("       [%d] = ", player_idx))
		io.write(cards.card_array_to_string(playing))
		io.write(",\n")
	end
	io.write(string.format("    },\n"))

	io.write(string.format("    played[%d] = {\n", #state.played))
	for player_idx, played in pairs(state.played) do
		io.write(string.format("       [%d] = ", player_idx))
		io.write(cards.card_array_to_string(played))
		io.write(",\n")
	end
	io.write(string.format("    },\n"))


	io.write(string.format("    tentative_discards[%d] = {\n", #state.tentative_discards))
	for i=1,#state.tentative_discards do
		io.write("      ")
		-- io.write("{")
		io.write(string.format("[%d] = {", i))
		for j=1,#state.tentative_discards[i] do
			io.write(string.format("%s, ", state.tentative_discards[i][j]))
		end
		io.write("},\n")
	end
	io.write(string.format("    },\n"))

	io.write(string.format("    crib = "))
	if state.crib ~= nil then
		io.write(cards.card_array_to_string(state.crib))
	else
		io.write("nil")
	end
	io.write(string.format("\n"))

	io.write(string.format("    score[%d] = {\n", #state.score))
	for i=1,#state.score do
		io.write(string.format("      [%d] = %d,\n", i, state.score[i]))
	end
	io.write("    }\n")
	io.write("}\n")
end

local function handle_discard_confirm(state, player)
	if state.state ~= core.states.PICK_DISCARD then
		error(string.format("Unexpected handle_discard_confirm from state %s", state.state))
	end

	if #state.hands[player] == core.CARDS_PER_HAND then
		error(string.format("Unexpected handle_discard_confirm when player has 4 cards"))
	end

	for i=1,#state.tentative_discards[player] do
		local i2 = #state.tentative_discards[player] - i + 1
		if state.tentative_discards[player][i2] then
			state.crib[#state.crib+1] = table.remove(state.hands[player], i2)
		end
	end

	state.tentative_discards[player] = {}

	local discard_done = true
	for player_idx=1, #state.hands do
		if #state.hands[player_idx] ~= core.CARDS_PER_HAND then
			discard_done = false
			goto done_checking_players
		end
	end
	::done_checking_players::

	if discard_done then
		state.state = core.states.PLAY
		state.cut_deck_card = table.remove(state.deck)
		if state.cut_deck_card.val == cards.JACK then
			-- TODO notify player that they were awarded points due to this
			state.score[state.player_crib] = state.score[state.player_crib] + JACK_OF_SUIT_CUT_DECK_POINTS
		end
	end 

	return core.RC_SUCCESS
end

-- TODO put in a utility library or something
local function copy_ary(ary)
	local ary_copied = {}
	for i=1,#ary do
		ary_copied[i] = ary[i]
	end
	return ary_copied
end


local function get_card_value(card)
	if card.val <= 10 then return card.val
	else return 10 end
end

local function card_order(a,b)
	return a.val < b.val
end

-- runs can be out of order,
-- so the way to check is if the sorted 
-- list of cards is sequential
local function check_is_run_add_card(sequence, card, len)
	local new_sequence = {}
	-- get the last (len-1) cards from sequence
	local start_i = #sequence - (len-1) + 1
	if start_i < 1 then
		return false
	end
	if card == nil then
		error("card is nil")
	end

	for i=start_i,#sequence do
		new_sequence[#new_sequence+1] = sequence[i]
	end
	new_sequence[#new_sequence+1] = card

	--print("new_sequence = ", cards.card_array_to_string(new_sequence))
	--for i=1,#new_sequence-1 do
	--	print("card_order(...) = ", card_order(new_sequence[i], new_sequence[i+1]))
	--end
	table.sort(new_sequence, card_order)
	--print("new_sequence = ", cards.card_array_to_string(new_sequence))

	if #new_sequence < 3 then
		error(string.format("new_sequence len is %d?", #new_sequence))
	end

	local is_run = true
	local last_elem = new_sequence[1]
	for i=2,#new_sequence do
		if new_sequence[i].val ~= last_elem.val + 1 then
			is_run = false
			goto done_run_len_check
		end
		last_elem = new_sequence[i]
	end
	::done_run_len_check::
	return is_run
	
end

local function is_run_sequence_enabled(sequence, cards_enabled)
	local enabled_seq = {}
	for i=1,#cards_enabled do
		if cards_enabled[i] then
			table.insert(enabled_seq, sequence[i])
		end
	end

	if #enabled_seq < 3 then
		return false
	end

	table.sort(enabled_seq, card_order)

	for i=1,#enabled_seq-1 do
		if enabled_seq[i+1].val ~= enabled_seq[i].val + 1 then
			return false
		end
	end

	return true
end

local function cards_enabled_to_card_idx(cards_enabled)
	local card_idxes = {}
	for i=1,#cards_enabled do
		if cards_enabled[i] then
			table.insert(card_idxes, i)
		end
	end
	return card_idxes
end

local function run_is_subsequence(run, run_ary)
	for _, run2 in ipairs(run_ary) do
		local i=1
		for j=1,#run2 do
			if run2[j] < run[i] then
				-- pass
			elseif run2[j] == run[i] then
				if i == #run then
					return true
				end
				i = i + 1
			else
				goto next_run
			end
		end
		::next_run::
	end
end

-- Only handle sequences of 5 cards,
-- and only check for runs of length 5, 4, or 3
-- Return array of array of indicies of cards that are enabled to make up a run
-- A run of 4 {2,3,4,5} must only count as one run, but
-- Two runs of 3 must be counted if they don't make a run of 4, e.g. {2, 2, 3, 4} is two runs of 3
local function check_points_sequence_run(sequence)

	if #sequence ~= 5 then
		error(string.format("checked for run on sequences of len %d", #sequence))
	end

	local cards_enabled = {}
	for i=1,#sequence do
		cards_enabled[i] = true
	end

	if is_run_sequence_enabled(sequence, cards_enabled) then
		return {cards_enabled_to_card_idx(cards_enabled)}
	end

	local runs4 = {}
	for card_disabled_idx=1,#cards_enabled do
		cards_enabled[card_disabled_idx] = false
		if is_run_sequence_enabled(sequence, cards_enabled) then
			table.insert(runs4, cards_enabled_to_card_idx(cards_enabled))
		end
		cards_enabled[card_disabled_idx] = true
	end

	-- TODO need to check for runs of length 3 that are not
	-- contained within a run of 4
	local runs3 = {}
	for card_disabled_idx1=1, #cards_enabled do
		cards_enabled[card_disabled_idx1] = false
		for card_disabled_idx2=card_disabled_idx1+1, #cards_enabled do
			cards_enabled[card_disabled_idx2] = false
			if is_run_sequence_enabled(sequence, cards_enabled) then
				local run_seq = cards_enabled_to_card_idx(cards_enabled)
				if not run_is_subsequence(run_seq, runs4) then
					table.insert(runs3, run_seq)
				end
			end
			cards_enabled[card_disabled_idx2] = true
		end
		cards_enabled[card_disabled_idx1] = true
	end

	local runs = {}
	for i=1,#runs4 do
		runs[#runs+1] = runs4[i]
	end
	for i=1,#runs3 do
		runs[#runs+1] = runs3[i]
	end

	return runs
end

local function check_points_sequence_15(sequence)
	local fifteen_count = 0
	local combinations = {}
	
	local cards_enabled = {}
	for i=1,#sequence do
		cards_enabled[i] = false
	end


	-- loop through all combinations of cards, like counting in binary:
	-- 0 0 0 0
	-- 0 0 0 1
	-- 0 0 1 0
	-- 0 0 1 1
	-- 0 1 0 0
	-- ...
	-- io.write(string.format("starting loop... %d %d\n", #sequence, #cards_enabled))
	while true do
		local sum = 0
		local debug_str = ""
		for i=1,#sequence do
			-- debug_str = debug_str .. string.format("%d ", cards_enabled[i] and 1 or 0)
			if cards_enabled[i] then
				sum = sum + get_card_value(sequence[i])
			end
		end
		--debug_str = debug_str .. string.format("; sum=%d\n", sum)
		--io.write(debug_str)
		if sum == 15 then
			fifteen_count = fifteen_count + 1
			local cards_enabled_copy = {}
			for idx,val in ipairs(cards_enabled) do
				cards_enabled_copy[idx] = val
			end
			table.insert(combinations, cards_enabled_copy)
		end

		local j = 1
		while j <= #sequence and cards_enabled[j] do
			cards_enabled[j] = false
			j = j + 1
		end
		if j > #sequence then
			goto end_loop
		else
			cards_enabled[j] = true
		end
	end
	::end_loop::
	return {
		count = fifteen_count,
		combinations = combinations,
	}
end

local function pair_count_to_points(pair_count)
	local pair_points = 0
	if pair_count == 2 then
		pair_points = 2
	elseif pair_count == 3 then
		pair_points = 6
	elseif pair_count == 4 then
		pair_points = 12
	end
	return pair_points
end



local function check_points_seqeuence_pair(sequence)
	local card_pairs = {}
	for val=cards.MIN_VAL,cards.MAX_VAL do
		local possible_pair = {}
		for j=1,#sequence do
			if sequence[j].val == val then
				table.insert(possible_pair, j)
			end
		end
		if #possible_pair > 1 then
			table.insert(card_pairs, possible_pair)
		end
	end
	return card_pairs
end

local function check_points_sequence_flush(sequence, cut_deck_card)
	local card_flushes = {}
	for _, suit in ipairs(cards.suits) do
		local possible_flush = {}
		for i=1,#sequence do
			if sequence[i].suit == suit then
				table.insert(possible_flush, i)
			end
		end

		if #possible_flush >= 4 and suit == cut_deck_card.suit then
			table.insert(possible_flush, #sequence + 1)
		end

		if #possible_flush >= 4 then
			table.insert(card_flushes, possible_flush)
		end
	end
	return card_flushes
end

function core.check_points_sequence(sequence, cut_deck_card)
	local info = {
		points_reasons = {},
		points = 0,
	}

	local sequence2 = copy_ary(sequence)
	table.insert(sequence2, cut_deck_card)

	local info_15 = check_points_sequence_15(sequence2)

	for _,combination in ipairs(info_15.combinations) do
		local card_idxs = {}
		for j=1,#combination do
			if combination[j] then
				table.insert(card_idxs, j)
			end
		end
		info.points_reasons[#info.points_reasons+1] = {
			reason = core.point_types.FIFTEEN,
			points = 2,
			card_idxs = card_idxs,
		}
	end

	info.points = info.points + info_15.count * 2

	local runs = check_points_sequence_run(sequence2)
	for _,run in ipairs(runs) do
		info.points = info.points + #run
		info.points_reasons[#info.points_reasons+1] = {
			reason = core.point_types.RUN,
			points = #run,
			card_idxs = run,
		}
	end

	local card_pairs = check_points_seqeuence_pair(sequence2)
	for _,card_pair in ipairs(card_pairs) do
		local pair_points = pair_count_to_points(#card_pair) info.points = info.points + pair_points
		info.points_reasons[#info.points_reasons+1] = {
			reason = core.point_types.PAIR,
			points = pair_points,
			card_idxs = card_pair,
		}
	end

	local card_flushes = check_points_sequence_flush(sequence, cut_deck_card)
	for _, card_flush in ipairs(card_flushes) do
		local flush_points = #card_flush
		info.points = info.points + flush_points
		info.points_reasons[#info.points_reasons+1] = {
			reason = core.point_types.FLUSH,
			points = flush_points,
			card_idxs = card_flush,
		}
	end

	for card_idx, card in ipairs(sequence) do
		if card.val == cards.JACK and card.suit == cut_deck_card.suit then
			info.points_reasons[#info.points_reasons+1] = {
				reason = core.point_types.JACK_OF_SUIT,
				points = JACK_OF_SUIT_HAND_CRIB_POINTS,
				card_idxs = {card_idx},
			}
		end
	end

	return info
end

local function check_points_add_card(playing_sequence, card)
	local info = {
		points_reasons = {},
		points = 0,
	}
	if #playing_sequence == 0 then
		return info
	end

	-- check for runs
	local run_len = 0
	local diff = playing_sequence[#playing_sequence].val - card.val
	local last_card = playing_sequence[#playing_sequence]
	for possible_run_len=#playing_sequence+1,3,-1 do
		if check_is_run_add_card(playing_sequence, card, possible_run_len) then
			run_len = possible_run_len
			goto done_run_check
		end
	end
	::done_run_check::

	info.points = info.points + run_len
	info.points_reasons[#info.points_reasons] = { reason = core.point_types.RUN, points = run_len }

	-- check for pairs of two or more of cards with the same value
	local pair_count = 1
	for i=#playing_sequence,1,-1 do
		if playing_sequence[i].val == card.val then
			pair_count = pair_count + 1
		else
			goto done_pair_check
		end
	end
	::done_pair_check::

	local pair_points = pair_count_to_points(pair_count)

	if pair_points > 0 then
		info.points = info.points + pair_points
		info.points_reasons[#info.points_reasons] = { reason = core.point_types.PAIR, points = pair_points }
	end

	return info
end

local function cards_in_hand_remaining(state)
	for _,hand in ipairs(state.hands) do
		if #hand > 0 then
			return true
		end
	end
	return false
end



local function handle_play(state, player, idx, points_reasons)
	if state.player_turn ~= player then
		return core.RC_NOT_YOUR_TURN
	end

	if not (1 <= idx and idx <= #state.hands[player]) then
		error(string.format("Invalid move card %d of hand with only %d cards", idx, #state.hands[player]))
	end

	local tentative_card_played = state.hands[player][idx]

	local tentative_card_value = get_card_value(tentative_card_played)

	if state.playing_sum + tentative_card_value > core.MAX_PLAYING_SUM then
		return core.RC_PLAY_HIGHER_THAN_31
	end

	state.playing_sum = state.playing_sum + tentative_card_value
	state.first_player_cant_move = 0

	if state.playing_sum == 15 then
		state.score[player] = state.score[player] + 2
		points_reasons[#points_reasons+1] = { reason = core.point_types.FIFTEEN, points = 2}
	elseif state.playing_sum == 31 then
		state.score[player] = state.score[player] + 2
		points_reasons[#points_reasons+1] = { reason = core.point_types.THIRTY_ONE, points = 2}
	end

	local card = table.remove(state.hands[player], idx)
	
	local points_info = check_points_add_card(state.playing_sequence, card)
	for _,points_info_elem in ipairs(points_info.points_reasons) do
		points_reasons[#points_reasons+1] = points_info_elem
	end
	state.score[player] = state.score[player] + points_info.points

	-- TODO what oher cases result in points?
	--    * a run of 3 or more?
	--    * pairs?
	--    * getting 30?
	--    * last card
	--    * multiple cards of the same suit?

	-- TODO do something if score is 31?

	table.insert(state.playing[player],  card)
	table.insert(state.playing_sequence, card)


	if not cards_in_hand_remaining(state) then

		-- move all cards from playing to played
		for i=1,state.player_count do
			while #state.playing[i] > 0 do
				table.insert(state.played[i], table.remove(state.playing[i], 1))
				
			end

		end

		state.state = core.states.ACKNOWLEDGE_POINTS
	else
		state.player_turn = ((state.player_turn) % state.player_count) + 1
	end

	-- check if player just played their last card and award a point?
	-- No, it's last card of the run, I think
	--if #state.hands[player] == 0 then
	--	state.score[player] = state.score[player] + 1
	--end

	return core.RC_SUCCESS
end

function core.cant_move(state)
	local player = state.player_turn
	for _,card in ipairs(state.hands[player]) do
		if state.playing_sum + get_card_value(card) <= core.MAX_PLAYING_SUM then
			return false
		end
	end
	return true
end

local function handle_cant_move_accept(state, player)
	if player ~= state.player_turn then
		return core.RC_NOT_YOUR_TURN
	end

	if not core.cant_move(state) then
		return core.RC_MUST_MOVE
	end

	state.player_turn = ((state.player_turn) % state.player_count) + 1
	if state.first_player_cant_move == state.player_turn then
		local last_player_played = (state.first_player_cant_move-2) % state.player_count + 1
		-- one point for last card
		-- TODO make sure this happens when no player has any cards remaining, too
		-- TODO do not do this if each player pressed "can't move" after 31 was reached.
		-- Maybe transition to "next" for that case
		state.score[last_player_played] = state.score[last_player_played] + LAST_CARD_POINTS
		state.first_player_cant_move = 0
		state.playing_sum = 0
		for player_idx=1,state.player_count do
			while #state.playing[player_idx] > 0 do
				table.insert(state.played[player_idx], table.remove(state.playing[player_idx], 1))
			end
		end
		-- TODO if "can't move" goes around the whole table and no one can move,
		-- then must set playing_sum to zero and put the "playing" cards to the "played" tables.
		-- Also record points that people get during this whole thing
		-- Also last card gets a point, I think
	else
		if state.first_player_cant_move == 0 then
			state.first_player_cant_move = player
		end
	end


	return core.RC_SUCCESS
end

function core.has_acknowledged_points(state, player)
	return state.acknowledged_points[player]
end

local function handle_acknowledged_points(state, player)
	local rc = core.RC_SUCCESS
	state.acknowledged_points[player] = true

	local all_acknowledged = true
	for i=1,state.player_count do
		if not state.acknowledged_points[i] then
			all_acknowledged = false
			goto done
		end
	end
	::done::

	if all_acknowledged then
		state.state = core.states.ACKNOWLEDGE_CRIB

		-- reset acknowledged_points array
		for i=1,state.player_count do
			state.acknowledged_points[i] = false
		end

		-- add points
		for i=1,state.player_count do
			local points_info = core.check_points_sequence(state.played[i], state.cut_deck_card)

			state.score[i] = state.score[i] + points_info.points
		end
	end

	return rc
end

local function handle_acknowledged_crib(state, player)
	local rc = core.RC_SUCCESS
	state.acknowledged_points[player] = true

	local all_acknowledged = true
	for i=1,state.player_count do
		if not state.acknowledged_points[i] then
			all_acknowledged = false
			goto done
		end
	end
	::done::

	if all_acknowledged then
		for i=1,state.player_count do
			state.acknowledged_points[i] = false
		end

		local points_info = core.check_points_sequence(state.crib, state.cut_deck_card)

		state.score[state.player_crib] = state.score[state.player_crib] + points_info.points


		state.state = core.states.PICK_DISCARD
		state.player_crib = ((state.player_crib) % state.player_count) + 1
		deal_new_hand(state, true)
	end

	return rc

end

function core.handle_move(state, player, action)
	if state.state == core.states.PICK_DISCARD then
		if #state.hands[player] == core.CARDS_PER_HAND then
			return core.RC_WAIT_FOR_OTHERS_TO_DISCARD
		end
		if action.action == core.actions.HAND then
			state.tentative_discards[player][action.idx] = not(state.tentative_discards[player][action.idx])
			return core.RC_SUCCESS
		elseif action.action == core.actions.DISCARD_CONFIRM then
			return handle_discard_confirm(state, player)
		end
	elseif state.state == core.states.PLAY then
		if action.action == core.actions.HAND then
			-- TODO get this to the user somehow
			local points_reasons = {}
			local rc = handle_play(state, player, action.idx, points_reasons)
			return rc
		elseif action.action == core.actions.CANT_MOVE_ACCEPT then
			return handle_cant_move_accept(state, player)
		end
	elseif state.state == core.states.ACKNOWLEDGE_POINTS then
		if action.action == core.actions.NEXT then
			return handle_acknowledged_points(state, player)
		end
	elseif state.state == core.states.ACKNOWLEDGE_CRIB then
		if action.action == core.actions.NEXT then
			return handle_acknowledged_crib(state, player)
		end
	end
	error(string.format("Unhandled action %s from state %s", action.action, state.state))
	return core.RC_ERROR
end

-- get number of cards needed to select for discard before we can continue
function core.get_tentative_remaining_cards(state, player)
	local tentative_discard_count = 0
	for i=1,#state.tentative_discards[player] do
		if state.tentative_discards[player][i] then
			tentative_discard_count = tentative_discard_count + 1
		end
	end

	local tentative_remaining_cards = #state.hands[player] - tentative_discard_count
	return tentative_remaining_cards 
end

-- Check what cards should be highlighted in the discard state
function core.get_highlight_ary(state, player)

	local highlight_ary = {}
	if state.state == core.states.PICK_DISCARD then
		local tentative_remaining_cards = core.get_tentative_remaining_cards(state, player)
	
		for i=1,#state.hands[player] do
			local highlight = nil
			if tentative_remaining_cards == core.CARDS_PER_HAND then
				highlight = false
			elseif tentative_remaining_cards > core.CARDS_PER_HAND then
				highlight = not state.tentative_discards[player][i]
			else
				highlight = state.tentative_discards[player][i]
			end
			highlight_ary[i] = highlight
		end
	elseif state.state == core.states.PLAY then
		for i=1,#state.hands[player] do
			local card = state.hands[player][i]
			local can_play = nil
			if state.player_turn ~= player then
				can_play = false
			else
				can_play = (get_card_value(card) + state.playing_sum) <= core.MAX_PLAYING_SUM
			end
			highlight_ary[i] = can_play
		end
	elseif state.state == core.states.ACKNOWLEDGE_POINTS or
	       state.state == core.states.ACKNOWLEDGE_CRIB then
		-- no highlights
	else
		error(string.format("Unhandled state %s", state.state))
	end
	return highlight_ary
end

function core.get_discard_status_str(state, player)
	if state.state ~= core.states.PICK_DISCARD then
		error("Not waiting for discard but called get_discard_status_str")
		return "Not waiting for discard..."
	end
	
	if #state.hands[player] == core.CARDS_PER_HAND then
		return "Waiting for other players to discard"
	end

	local tentative_remaining_cards = core.get_tentative_remaining_cards(state, player)

	local diff = tentative_remaining_cards - core.CARDS_PER_HAND

	if diff > 0 then
		return string.format("Please select %d more cards for discard", diff)
	elseif diff < 0 then
		return string.format("Please select %d fewer cards for discard", -diff)
	else
		return "Press \"discard\" button to discard selected cards"
	end
end

tests = {
	{ actual = check_is_run_add_card({{val=9}, {val=11}}, {val=10}, 3), expected = true },
	{ actual = check_is_run_add_card({{val=9}, {val=12}}, {val=10}, 3), expected = false },
	{ actual = check_is_run_add_card({{val=2}, {val=5}}, {val=4}, 3), expected = false },
	{ actual = check_is_run_add_card({{val=3}, {val=5}, {val=4}}, {val=2}, 3), expected = false },
	{ actual = check_is_run_add_card({{val=2}, {val=5}, {val=4}}, {val=3}, 3), expected = true },
	{ actual = check_is_run_add_card({{val=2}, {val=5}, {val=4}}, {val=3}, 4), expected = true },

	{ actual = check_points_sequence_15({{val=10}, {val=4}, {val= 1}}).count, expected = 1},
	{ actual = check_points_sequence_15({{val= 9}, {val=4}, {val= 1}}).count, expected = 0},
	{ actual = check_points_sequence_15({{val= 9}, {val=4}, {val= 2}}).count, expected = 1},
	{ actual = check_points_sequence_15({{val=10}, {val=5}, {val= 3}}).count, expected = 1},
	{ actual = check_points_sequence_15({{val=10}, {val=5}, {val= 5}}).count, expected = 2},
	{ actual = check_points_sequence_15({{val=10}, {val=5}, {val=10}}).count, expected = 2},
	{ actual = check_points_sequence_15({{val= 5}, {val=6}, {val= 4}}).count, expected = 1},
	{ actual = check_points_sequence_15({{val= 5}, {val=5}, {val= 5}}).count, expected = 1},
	{ actual = check_points_sequence_15({{val= 5}, {val=5}, {val= 5}, {val=5}}).count, expected = 4},

	-- { actual = check_points_sequence_15({{val= 13}, {val=7}, {val= 5}, {val=7}, {val=9}, {val=6}}).count, expected = 2},
	{ actual = check_points_sequence_15({{val= 8}, {val=5}, {val= 9}, {val=11}, {val=6}, {val=2}}).count, expected = 3},
}

for test_idx, test in ipairs(tests) do
	if test.actual ~= test.expected then
		error(string.format("Test %d failed, expected %s, received %s", test_idx, test.expected, test.actual))
	end
end

local run_tests = {
	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=4}, {val=6}, {val=11}}), runs = 1, run_len = 3},
	{ actual = check_points_sequence_run({{val=3}, {val=4}, {val=2}, {val=6}, {val=11}}), runs = 1, run_len = 3},
	{ actual = check_points_sequence_run({{val=4}, {val=2}, {val=6}, {val=3}, {val=11}}), runs = 1, run_len = 3},
	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=5}, {val=6}, {val=11}}), runs = 0, run_len = nil},
	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=4}, {val=5}, {val=11}}), runs = 1, run_len = 4},
	{ actual = check_points_sequence_run({{val=5}, {val=2}, {val=3}, {val=4}, {val=11}}), runs = 1, run_len = 4},
	{ actual = check_points_sequence_run({{val=5}, {val=3}, {val=4}, {val=4}, {val=11}}), runs = 2, run_len = 3},
	{ actual = check_points_sequence_run({{val=5}, {val=3}, {val=4}, {val=4}, {val=2}}), runs = 2, run_len = 4},
	{ actual = check_points_sequence_run({{val=5}, {val=3}, {val=4}, {val=6}, {val=2}}), runs = 1, run_len = 5},

	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=4}, {val=3}, {val=4}}), runs = 4, run_len = 3},
	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=4}, {val=3}, {val=4}}), runs = 4, run_len = 3},
	{ actual = check_points_sequence_run({{val=4}, {val=2}, {val=4}, {val=2}, {val=3}}), runs = 4, run_len = 3},

	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=5}, {val=6}, {val=7}}), runs = 1, run_len = 3},
	{ actual = check_points_sequence_run({{val=2}, {val=3}, {val=5}, {val=6}, {val=8}}), runs = 0, run_len = nil},
	{ actual = check_points_sequence_run({{val=11}, {val=12}, {val=13}, {val=1}, {val=2}}), runs = 1, run_len = 3},
	{ actual = check_points_sequence_run({{val=11}, {val=12}, {val=13}, {val=10}, {val=2}}), runs = 1, run_len = 4},
	{ actual = check_points_sequence_run({{val=11}, {val=12}, {val=13}, {val=10}, {val=9}}), runs = 1, run_len = 5},

}

for test_idx, test in ipairs(run_tests) do
	if #test.actual ~= test.runs then
		error(string.format("Run test %d failed, expected %d runs, actual %d", test_idx, test.runs, #test.actual ))
	end
	for i=1,#test.actual do
		if #test.actual[i] ~= test.run_len then
			error(string.format("Run test %d failed, run %d had len %d, expected %d",
			      test_idx, i, #test.actual[i], test.run_len))
		end
	end
end

local pair_tests = {
	{ actual = check_points_seqeuence_pair({{val= 5}, {val=13}, {val=13}, {val= 4}}), pair_lens = {2}    },
	{ actual = check_points_seqeuence_pair({{val=13}, {val=13}, {val=13}, {val= 4}}), pair_lens = {3}    },
	{ actual = check_points_seqeuence_pair({{val=13}, {val= 4}, {val=13}, {val= 5}}), pair_lens = {2}    },
	{ actual = check_points_seqeuence_pair({{val=13}, {val= 4}, {val=13}, {val= 4}}), pair_lens = {2, 2} },
	{ actual = check_points_seqeuence_pair({{val=13}, {val=13}, {val=13}, {val=13}}), pair_lens = {4}    },
	{ actual = check_points_seqeuence_pair({{val= 2}, {val= 2}, {val= 3}, {val= 4}}), pair_lens = {2}    },
	{ actual = check_points_seqeuence_pair({{val= 2}, {val= 2}, {val= 3}, {val= 3}}), pair_lens = {2, 2} },
}

for test_idx, test in ipairs(pair_tests) do
	if #test.actual ~= #test.pair_lens then
		error(string.format("Pair test %d failed, expected %d pairs, actual %d", test_idx, #test.pair_lens, #test.actual ))
	end
	for i=1,#test.actual do
		if #test.actual[i] ~= test.pair_lens[i] then
			error(string.format("Pair test %d failed, pair %d had len %d, expected %d",
			      test_idx, i, #test.actual[i], test.pair_lens[i]))
		end
	end
end

local A = cards.DIAMONDS
local B = cards.SPADES

local flush_tests = {
	{ actual = check_points_sequence_flush({{suit=A}, {suit=A}, {suit=A}, {suit=B}}, {suit=A}), expected={} },
	{ actual = check_points_sequence_flush({{suit=A}, {suit=A}, {suit=A}, {suit=A}}, {suit=B}), expected={4} },
	{ actual = check_points_sequence_flush({{suit=A}, {suit=A}, {suit=A}, {suit=A}}, {suit=A}), expected={5} },
	{ actual = check_points_sequence_flush({{suit=B}, {suit=A}, {suit=A}, {suit=A}}, {suit=A}), expected={} },
}

for test_idx, test in ipairs(flush_tests) do
	if #test.actual ~= #test.expected then
		error(string.format("Flush Test %d failed, expected %d flushes, actual %d", test_idx, #test.expected, #test.actual))
	end

	for i=1,#test.expected do
		if #test.actual[i] ~= test.expected[i] then
			error(string.format("Flush test %d failed, elem %d has len %d, expected %d",
			      test_idx, i, #test.actual[i], test.expected[i]))
		end
	end
end

return core
local core = require("games/crib/crib_core")
local cards_draw = require("libs/cards/cards_draw")
local alex_c_api = require("alex_c_api")
local draw_more = require("libs/draw/draw_more")

local draw = {}

draw.ACTION_TYPE_GAME = 'game'
draw.ACTION_TYPE_UI   = 'ui'

draw.ACTION_UI_SHOW_POINTS_POPUP = "show_points"
draw.ACTION_UI_HIDE_POINTS_POPUP = "hide_points"

local TEXT_COLOUR = '#000000'
local TEXT_SIZE = 24
local text_height = 20

local CARD_POINTS_POPUP_BACKGROUND_COLOUR = '#aaaaaaf0'
local CARD_POINTS_POPUP_OUTLINE_COLOUR = '#000000'
local popup_padding = 40

draw.BTN_ID_DISCARD = "discard"
draw.BTN_ID_PASS = "pass"
draw.BTN_ID_NEXT = "next"

local width = nil
local height = nil
local card_height = 105
local card_width  = 60
local card_font_size  = 28
local card_padding = 15
local card_discard_offset = 40
-- when drawing a pile of cards, this is the y and x offset
-- that should be drawn to subsequent cards on the pile so
-- they appear to form a stack.
local card_pile_offset = 3

local more_info_btn_width  = 50
local more_info_btn_height = 50

local player_hand_y_centre = nil
local player_hand_x_centre = nil


local small_card_width = 35
local small_card_height = 50
local small_card_font_size = 12
local small_card_padding = 3

local hand_width = nil

function draw.init(height_arg, width_arg)
	height = height_arg
	width  = width_arg

	player_hand_y_centre = math.floor(height - card_height/2 - card_padding)
	player_hand_x_centre = math.floor(width/2)

	hand_width = core.CARDS_PER_HAND * card_width + (core.CARDS_PER_HAND - 1) * card_padding

	alex_c_api.create_btn(draw.BTN_ID_DISCARD, "Discard", 1)
	alex_c_api.create_btn(draw.BTN_ID_PASS,    "Can't move", 1)
	alex_c_api.create_btn(draw.BTN_ID_NEXT,    "Next", 1)
	alex_c_api.set_btn_enabled(draw.BTN_ID_DISCARD, false)
	alex_c_api.set_btn_enabled(draw.BTN_ID_PASS,    false)
	alex_c_api.set_btn_enabled(draw.BTN_ID_NEXT,    false)

	local ui_state = {
		points_popup_shown   = false,
		points_popup_player  = nil,
	}
	return ui_state
end

local function get_offset_ary(state, player)
	if state.state ~= core.states.PICK_DISCARD then
		return nil
	end
	local offset_ary = {}
	for i=1,#state.hands[player] do
		local offset = nil
		if state.tentative_discards[player][i] then
			offset = -card_discard_offset
		else
			offset = 0
		end
		offset_ary[i] = offset
	end
	return offset_ary
end

local function get_hand_pos(state, this_player, player)
	local pos = {}
	local adjusted_player_pos = ((player - this_player) % state.player_count)
	if adjusted_player_pos == 0 then
		pos.y = player_hand_y_centre
		pos.x = player_hand_x_centre
	elseif adjusted_player_pos == 1 then
		pos.y = math.floor(card_height/2 + card_padding)
		pos.x = math.floor(width/2)
	else
		error(string.format("Unhandled this_player=%s, player=%s, adjusted=%s", this_player, player, adjusted_player_pos))
	end

	return pos
end

local function get_more_info_btn_pos(this_player, player)
	if this_player == player then
		return {
			y = math.floor(height - card_height - 2*card_padding - more_info_btn_height),
			x = math.floor(width/2 + hand_width/2 - more_info_btn_width),
		}
	else
		return {
			y = math.floor(card_height + 2*card_padding),
			x = math.floor(width/2 - hand_width/2),
		}
	end
end

local function get_hand_score_pos(this_player, player)
	if this_player == player then
		return {
			y = math.floor(height - card_height - 2*card_padding),
			x = math.floor(width/2),
		}
	else
		return {
			y = math.floor(card_height + 2*card_padding + text_height),
			x = math.floor(width/2),
		}
	end
end

local function get_played_pos(state, this_player, player)
	local pos = {}
	--local adjusted_player_pos = ((player - this_player) % state.player_count)
	local adjusted_player_pos = nil
	if (this_player == player) then
		adjusted_player_pos = 0
	else
		adjusted_player_pos = 1
	end

	local offset_frac_y = 0.6
	local offset_card_widths_x = 2.0
		
	if adjusted_player_pos == 0 then
		pos.y = math.floor(offset_frac_y*height - card_height/2)
		pos.x = math.floor(width/2 - card_width/2 + offset_card_widths_x*card_width)
	elseif adjusted_player_pos == 1 then
		pos.y = math.floor((1-offset_frac_y)*height - card_height/2)
		pos.x = math.floor(width/2 - card_width/2 - offset_card_widths_x*card_width)
	else
		error(string.format("Unhandled this_player=%s, player=%s, adjusted=%s", this_player, player, adjusted_player_pos))
	end
	return pos
end

local function get_other_player(state, player)
	if player == 1 then return 2
	else return 1 end
end

local function player_pos_to_idx(state, player, pos)
	if pos == 1 then return player
	else return get_other_player(state, player) end
end

local function draw_points_popup(state, points_info, player)
		alex_c_api.draw_rect(CARD_POINTS_POPUP_BACKGROUND_COLOUR,
		                     popup_padding, popup_padding,
		                     width - popup_padding, height - popup_padding)

		alex_c_api.draw_text(string.format("Player %d points: %d", player, points_info.points), TEXT_COLOUR,
		                     popup_padding + 2*card_padding,
		                     popup_padding + card_padding,
		                     TEXT_SIZE, 1, 0)

		for i,points_reason in ipairs(points_info.points_reasons) do
			--local text_height = 16*2
			local text_height = small_card_height + small_card_padding
			local text_pos_y = popup_padding + 4*card_padding + (i-1)*text_height
			local reason_str = core.point_type_to_str(points_reason.reason)
			alex_c_api.draw_text(string.format("+%2d %s", points_reason.points, reason_str), TEXT_COLOUR,
			                     text_pos_y, popup_padding + 3*card_padding, 16, 1, 0)
			for j,card_idx in ipairs(points_reason.card_idxs) do
				local card_pos_x = width - popup_padding - j*(small_card_width + small_card_padding)
				local card = nil
				local hand = nil
				if state.state == core.states.ACKNOWLEDGE_POINTS then
					hand = state.played[player]
				elseif state.state == core.states.ACKNOWLEDGE_CRIB then
					hand = state.crib
				end

				if card_idx <= #hand then
					card = hand[card_idx]
				elseif card_idx == #state.played[player] + 1 then
					card = state.cut_deck_card
				else
					error(string.format("Unexpected card_idx %s, #hand = %s", card_idx, #hand))
				end
				cards_draw.draw_card(card,
				                math.floor(text_pos_y - small_card_height/2),
				                card_pos_x,
								small_card_width,
								small_card_height,
				                small_card_font_size,
				                false,
				                0)
			end
		end

		local btn_pos_y = height - popup_padding - more_info_btn_height - card_padding
		local btn_pos_x = popup_padding + card_padding
		alex_c_api.draw_rect('#dddddd',
		                        btn_pos_y, btn_pos_x,
		                        (width - popup_padding - card_padding), --  - btn_pos_x,
		                        (height - popup_padding - card_padding)) --  - btn_pos_y)
		alex_c_api.draw_text("Close", TEXT_COLOUR,
		                     math.floor(btn_pos_y + more_info_btn_height/2),
		                     math.floor(width/2),
		                     TEXT_SIZE, 0, 0)
end

local function get_hand_to_draw(state, this_player, player)
	if state.state == core.states.ACKNOWLEDGE_POINTS then
		return state.played[player]
	elseif state.state == core.states.ACKNOWLEDGE_CRIB then
		if player == state.player_crib then
			return state.crib
		else
			return {}
		end
	else
		if this_player == player then
			return state.hands[player]
		else
			local len = #state.hands[player]
			local hand = {}
			for i=1,len do
				table.insert(hand, cards.UNREVEALED_CARD)
			end
			return hand
		end
	end
end

local function get_crib_label_pos(player_crib, player)
	if player == player_crib then
		return {
			y = math.floor(height - card_height - 4*card_padding),
			x = math.floor(width - 2*card_padding),
			align = -1,
		}
	else
		return {
			y = math.floor(card_height + 5*card_padding),
			x = math.floor(2*card_padding),
			align = 1,
		}
	end
end

local function get_score(state, player)
	--if state == nil then return "" end
	--if player == nil then return "" end
	return string.format("%d", state.score[player])
end

function draw.draw(state, ui_state, player)
	alex_c_api.draw_clear()


	if state == nil then
		return
	end

	local offset_ary = nil 
	local highlight_ary = core.get_highlight_ary(state, player)

	if state.state == core.states.PICK_DISCARD then
		offset_ary = get_offset_ary(state, player)
	elseif state.state == core.states.PLAY then
	end

	if state.state == core.states.PLAY then
		alex_c_api.draw_text(tostring(state.playing_sum), TEXT_COLOUR,
			math.floor(height/2),
			math.floor(width/2 + card_padding),
			TEXT_SIZE,
			1, 0)
	end

	if state.cut_deck_card ~= nil then
		cards_draw.draw_card(state.cut_deck_card,
			math.floor(height/2 - card_height/2),
			math.floor(width/2 - card_width),
			card_width,
			card_height,
			card_font_size,
			false, 0)
	end

	alex_c_api.draw_text(get_score(state, player), TEXT_COLOUR,
		math.floor(height - card_height - 2*card_padding),
		math.floor(width - 2*card_padding),
		TEXT_SIZE,
		-1,
		0)

	local crib_label_pos = get_crib_label_pos(state.player_crib, player)
	alex_c_api.draw_text("crib", TEXT_COLOUR,
		crib_label_pos.y,
		crib_label_pos.x,
		TEXT_SIZE,
		crib_label_pos.aign,
		0)

	local my_hand = get_hand_pos(state, player, player)
	cards_draw.draw_card_array(get_hand_to_draw(state, player, player),
		my_hand.y,
		my_hand.x,
		card_width,
		card_height,
		card_font_size,
		highlight_ary,
		card_padding,
		offset_ary)

	if #state.playing[player] > 0 then
		local pos = get_played_pos(state, player, player)
		--local card = state.playing[player][#state.playing[player]]
		-- .draw_card(card, y, x, width, height, font_size, highlight, angle)
		for card_idx, card in ipairs(state.playing[player]) do
		cards_draw.draw_card(
			card,
			pos.y + card_idx*card_pile_offset,
			pos.x + card_idx*card_pile_offset,
			card_width,
			card_height,
			card_font_size,
			false,
			0)
		end
	end

	-- TODO loop through all other players and draw their cards
	-- TODO should draw offset array for other players too
	local other_player = get_other_player(state, player)
	alex_c_api.draw_text(get_score(state, other_player), TEXT_COLOUR,
		math.floor(card_height + 3*card_padding), -- TODO the other one is 2*padding. Ensure vertical centre?
		math.floor(2*card_padding),
		TEXT_SIZE,
		1,
		0)
	local hand_pos = get_hand_pos(state, player, other_player)

	cards_draw.draw_card_array(get_hand_to_draw(state, player, other_player),
		hand_pos.y,
		hand_pos.x,
		card_width,
		card_height,
		card_font_size,
		nil,
		card_padding,
		get_offset_ary(state, other_player))

	if #state.playing[other_player] > 0 then
		local pos = get_played_pos(state, player, other_player)
		local card = state.playing[other_player][#state.playing[other_player]]
		-- .draw_card(card, y, x, width, height, font_size, highlight, angle)
		for card_idx,card in ipairs(state.playing[other_player]) do
		cards_draw.draw_card(
			card,
			pos.y + card_idx*card_pile_offset,
			pos.x + card_idx*card_pile_offset,
			card_width,
			card_height,
			card_font_size,
			false,
			0)
		end
	end


	for player_idx=1,state.player_count do

		local hand = nil
		if state.state == core.states.ACKNOWLEDGE_POINTS then
			hand = state.played[player_idx]
		elseif state.state == core.states.ACKNOWLEDGE_CRIB and
		       state.player_crib == player_idx then
			hand = state.crib
		else
			goto next_player
		end

		local btn_pos = get_more_info_btn_pos(player, player)
		draw_more.draw_graphic_ul("more_info_btn", 
		                        btn_pos.y, btn_pos.x, 
		                        more_info_btn_width, more_info_btn_height)

		local points_info = core.check_points_sequence(hand, state.cut_deck_card)

		local hand_score_pos = get_hand_score_pos(player, player_idx)

		alex_c_api.draw_text(string.format("+%d", points_info.points),
			TEXT_COLOUR,
			hand_score_pos.y, hand_score_pos.x,
			TEXT_SIZE, 0, 0)

		if ui_state.points_popup_shown and player_idx == ui_state.points_popup_player then
			draw_points_popup(state, points_info, player_idx)
		end

		::next_player::
	end

	alex_c_api.draw_refresh()

	local visible_btn_discard = (state.state == core.states.PICK_DISCARD)
	local visible_btn_pass    = (state.state == core.states.PLAY)
	local visible_btn_next    = (state.state == core.states.ACKNOWLEDGE_POINTS or
	                             state.state == core.states.ACKNOWLEDGE_CRIB)
	alex_c_api.set_btn_visible(draw.BTN_ID_DISCARD, visible_btn_discard)
	alex_c_api.set_btn_visible(draw.BTN_ID_PASS,    visible_btn_pass)
	alex_c_api.set_btn_visible(draw.BTN_ID_NEXT,    visible_btn_next)

	local enable_discard_btn = (state.state == core.states.PICK_DISCARD and 
	                            #state.hands[player] > core.CARDS_PER_HAND and
	                            core.get_tentative_remaining_cards(state, player) == core.CARDS_PER_HAND)
	local enable_pass_btn = (state.state == core.states.PLAY and 
	                            state.player_turn == player and
	                            core.cant_move(state))
	local enable_btn_next = ((state.state == core.states.ACKNOWLEDGE_POINTS or
	                          state.state == core.states.ACKNOWLEDGE_CRIB) and
	                         not core.has_acknowledged_points(state, player))
	alex_c_api.set_btn_enabled(draw.BTN_ID_DISCARD, enable_discard_btn)
	alex_c_api.set_btn_enabled(draw.BTN_ID_PASS, enable_pass_btn)
	alex_c_api.set_btn_enabled(draw.BTN_ID_NEXT, enable_btn_next)
end

function draw.coords_to_action(state, ui_state, player, coord_y, coord_x)
	local action = {
		action_type = nil, 
		action = nil,
		idx = nil
	}

	-- If clicked anywhere while the popup is shown, hide it
	if ui_state.points_popup_shown then
		action.action_type = draw.ACTION_TYPE_UI
		action.action      = draw.ACTION_UI_HIDE_POINTS_POPUP
		return action
	end

	for other_player=1,state.player_count do
		local btn_pos = get_more_info_btn_pos(player, other_player)
		if btn_pos.y <= coord_y and coord_y <= btn_pos.y + more_info_btn_height and
		   btn_pos.x <= coord_x and coord_x <= btn_pos.x + more_info_btn_width then
			action.action_type = draw.ACTION_TYPE_UI
			action.action      = draw.ACTION_UI_SHOW_POINTS_POPUP
			action.idx = other_player
			return action
		end
	end
	

	local offset_ary = get_offset_ary(state, player)

	local hand_idx = cards_draw.card_array_coords_to_idx(
		#state.hands[player],
		player_hand_y_centre,
		player_hand_x_centre,
		card_width,
		card_height,
		card_padding,
		offset_ary,
		coord_y,
		coord_x)
	if hand_idx ~= nil then
		action.action_type = draw.ACTION_TYPE_GAME
		action.action = core.actions.HAND
		action.idx = hand_idx
	end

	return action
end

function draw.handle_ui_action(ui_state, ui_action)
	if ui_action.action == draw.ACTION_UI_SHOW_POINTS_POPUP then
		ui_state.points_popup_shown  = true
		ui_state.points_popup_player = ui_action.idx
	elseif ui_action.action == draw.ACTION_UI_HIDE_POINTS_POPUP then
		ui_state.points_popup_shown  = false
		ui_state.points_popup_player = nil
	end
end

return draw
local core = require("games/crib/crib_core")
local draw = require("games/crib/crib_draw")
local crib_serialize = require("games/crib/crib_serialize")
local alex_c_api = require("alex_c_api")

local wait_for_players = require("libs/multiplayer/wait_for_players")


-- TODO next steps:
--  end game when first player reaches 121?
--
--
--  bug fixes:
--      * award a point for last card?
--      * jack of suit? See what other points are missing
--      * check wikipedia page for any behaviour that I missed
--      * for hand {K K 5 5} with {J} as cut_deck_card, there are 8 matches (6 fifteens and 2 pairs).
--        Need to add a separate page or something. 5 can be displayed comfortably


local g_session_id = nil
local state = nil
local players = {
	[1] = "You",
}
local player = 1
local is_client = false
local player_name_to_idx = {}

core.print_state(state)

local ui_state = draw.init(480, 480)

function new_game(player_count)
	g_session_id = alex_c_api.get_new_session_id()
	state = core.new_game(player_count)
end

function send_state_updates_if_host()
	if is_client then
		return
	end

	if state == nil then
		return
	end

	print("sending state to other players")

	for dst_player, player_name in pairs(players) do
		if dst_player == player then
			goto next_player
		end
		local state_msg = "state:" .. crib_serialize.serialize_client_state(state, dst_player)
		alex_c_api.send_message(player_name, state_msg)
		::next_player::
	end
end

function draw_board()
	if state == nil then
		return
	end
	if state.state == core.states.PICK_DISCARD and #state.hands[player] ~= core.CARDS_PER_HAND then
		local msg = core.get_discard_status_str(state, player)
		alex_c_api.set_status_msg(msg)
	else
		-- TODO why is this here?
		print(string.format("Unhandled state %s", state.state))
	end
	draw.draw(state, ui_state, player)
end

function handle_move(action)
	if not is_client then
		local rc = core.handle_move(state, player, action)
		if rc ~= core.RC_SUCCESS then
			alex_c_api.set_status_err(core.rc_to_str(rc))
		end
	else
		send_move_msg(action)
	end
end

function send_move_msg(action)
	local msg = "move:"..string.format("%d",action.action)
	if action.action == core.actions.HAND then
		msg = msg .. string.format(",%d", action.idx)
	end
	print("Sending message: " .. msg)
	alex_c_api.send_message("all", msg) -- TODO maybe only message the host
end

function handle_recv_move(src, payload)
	local src_player = player_name_to_idx[src]

	if src_player == nil then
		error(string.format("Unexpected move from non player %s", src_player))
	end

	local m = payload:gmatch("(%d+)(.*)")
	if m == nil then
		error("Expected move message to start with ascii base 10 int")
	end
	local action = {}
	local action_type, data = m()
	action_type = tonumber(action_type)

	action.action = action_type

	if action_type == core.actions.HAND then
		m = data:gmatch(",(%d+)")
		if m == nil then
			error("invalid data" .. data)
		end
		local idx = m()
		action.idx = tonumber(idx)
	elseif action_type == core.actions.DISCARD_CONFIRM then
		-- pass
	elseif action_type == core.actions.CANT_MOVE_ACCEPT then
		-- pass
	elseif action_type == core.actions.NEXT then
		-- pass
	else
		error(string.format("Unhandled action_type %s", action_type))
	end
	core.handle_move(state, src_player, action)
end

function handle_btn_clicked(btn_id)
	local rc = nil
	if btn_id == draw.BTN_ID_DISCARD then
		handle_move({ action = core.actions.DISCARD_CONFIRM })
		alex_c_api.set_status_msg("Waiting for other players to discard")
	elseif btn_id == draw.BTN_ID_PASS then
		handle_move({ action = core.actions.CANT_MOVE_ACCEPT})
	elseif btn_id == draw.BTN_ID_NEXT then
		handle_move({ action = core.actions.NEXT})
	else
		error(string.format("Unhandled btn_id %s", btn_id))
	end
	draw_board()
	save_state()
	core.print_state(state)
	send_state_updates_if_host()
end

function handle_user_clicked(coord_y, coord_x)
	if state == nil then
		return
	end
	local action = draw.coords_to_action(state, ui_state, player, coord_y, coord_x)
	local rc = nil
	if action.action_type == draw.ACTION_TYPE_GAME then
		if action.action == nil then
			print("No action")
			-- do nothing
		else
			handle_move(action)
		end
	elseif action.action_type == draw.ACTION_TYPE_UI then
		draw.handle_ui_action(ui_state, action)
	end
	draw_board()
	save_state()
	core.print_state(state)
	send_state_updates_if_host()
end

local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false
	if state == nil then
		new_game(#players)
	end
	send_state_updates_if_host()
	draw_board()
	core.print_state(state)
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- no need to draw board here, a state update should soon follow
end

function handle_msg_received(src, msg)
	print("handle_msg_received (from src:" .. src .. "): " .. msg);

	local handled = wait_for_players.handle_msg_received(src, msg)
	if handled then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "state" then
		if not is_client then
			error("Received state as host")
		end
		print("Received state")
		state = crib_serialize.deserialize_client_state(payload)
		core.print_state(state)
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	elseif header == "move" then
		handle_recv_move(src, payload)
	else
		error(string.format("Unhandled message %s", header))
	end

	send_state_updates_if_host()
	draw_board()
	core.print_state(state)
	save_state()
end 

function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end
end

function save_state()
	if state == nil then return end
	-- Only the host can save the state
	if not is_client then
		local serialized_state = crib_serialize.serialize_state(state)
		alex_c_api.save_state(g_session_id, serialized_state)
	end
end


function start_game(session_id, serialized_state)
	-- TODO need to implement load state
	-- which needs proper state serialization for all players (not one client)
	if serialized_state then
		g_session_id = session_id
		state = crib_serialize.deserialize_state(serialized_state, true)
	end
	wait_for_players.init(players, player, start_host_game, start_client_game)
end
local serialize = {}
local core = require("games/crib/crib_core")

local cards = require("libs/cards/cards")

local function serialize_byte(val)
	if val == nil then error("nil arg", 2) end
	return string.char(val)
end

local function deserialize_byte(bytes)
	return string.byte(table.remove(bytes, 1))
end

local function bool_to_int(bool)
	if bool then return 1
	else return 0 end
end

local function int_to_bool(val)
	if val == 0 then return false
	elseif val == 1 then return true
	else error(string.format("Unexpected value for bool: %s", val)) end
end

local function serialize_255bool_ary(ary)
	local chars = {}
	chars[#chars+1] = string.char(#ary)
	for i=1,#ary do
		chars[#chars+1] = string.char(bool_to_int(ary[i]))
	end
	return table.concat(chars, "")
end

local function deserialize_255bool_ary(bytes)
	local ary = {}
	local ary_len = string.byte(table.remove(bytes,1))
	if ary_len > #bytes then
		error(string.format("Read ary_len %d, only %d bytes left", ary_len, #bytes))
	end
	for i=1,ary_len do
		ary[i] = int_to_bool(string.byte(table.remove(bytes,1)))
	end
	return ary
end

function serialize.serialize_state(state)
	return serialize.serialize_client_state(state, nil)
end

-- If player is nil, then store all players' hands
-- Otherwise, only serialize the hand for `player`.
function serialize.serialize_client_state(state, player)
	if state == nil then return nil end
	local output = ""
	output = output .. serialize_byte(state.state)
	output = output .. serialize_byte(state.player_turn)
	output = output .. serialize_byte(state.player_crib)
	output = output .. serialize_byte(state.player_count)
	output = output .. serialize_byte(state.playing_sum)
	output = output .. serialize_byte(state.first_player_cant_move)
	output = output .. cards.serialize_card(state.cut_deck_card)
	output = output .. cards.serialize_card_array(state.playing_sequence)

	local show_all_players = (player == nil)

	for player_idx, hand in ipairs(state.hands) do
		if show_all_players or player == player_idx then
			output = output .. serialize_byte(player_idx)
			output = output .. serialize_byte(1)
			for _, card in ipairs(state.hands[player_idx]) do
				assert(card ~= cards.UNREVEALED_CARD and type(card) == 'table')
			end
			output = output .. cards.serialize_card_array(state.hands[player_idx])
		else
			output = output .. serialize_byte(player_idx)
			output = output .. serialize_byte(0)
			output = output .. serialize_byte(#hand)
		end
	end

	for player_idx,playing in ipairs(state.playing) do
		output = output .. cards.serialize_card_array(playing)
	end
	for player_idx,played in ipairs(state.played) do
		output = output .. cards.serialize_card_array(played)
	end

	for player_idx,_ in ipairs(state.tentative_discards) do
		output = output .. serialize_255bool_ary(state.tentative_discards[player_idx])
	end

	for player_idx=1,state.player_count do
		output = output .. serialize_byte(state.score[player_idx])
	end

	if show_all_players or state.state == core.states.ACKNOWLEDGE_CRIB then
		output = output .. cards.serialize_card_array(state.crib)
	else
		output = output .. cards.serialize_card_array({})
	end
	output = output .. serialize_255bool_ary(state.acknowledged_points)
	return output
end

local function bytestr_to_byteary(bytestr)
	local byteary = {}
	for i=1,#bytestr do
		byteary[i] = bytestr:sub(i,i)
	end
	return byteary
end

-- TODO remove this
function serialize.deserialize_client_state(bytes)
	return serialize.deserialize_state(bytes)
end

function serialize.deserialize_state(bytes, is_host)
	if bytes == nil then error("deserialize_state arg is nil", 2) end
	bytes = bytestr_to_byteary(bytes)
	local state = {}
	state.state        = deserialize_byte(bytes)
	state.player_turn  = deserialize_byte(bytes)
	state.player_crib  = deserialize_byte(bytes)
	state.player_count = deserialize_byte(bytes)
	state.playing_sum   = deserialize_byte(bytes)
	state.first_player_cant_move = deserialize_byte(bytes)
	state.cut_deck_card   = cards.deserialize_card(bytes)
	state.playing_sequence = cards.deserialize_card_array(bytes)

	state.playing = {}
	state.played  = {}
	state.hands = {}

	for _=1,state.player_count do
		local other_player_idx = deserialize_byte(bytes)
		local cards_visible = deserialize_byte(bytes)
		if is_host then
			if cards_visible ~= 1 then
				error(string.format("as host, deserialized state with cards_visible = %s", cards_visible))
			end
		end
		if cards_visible == 0 then
			local count = deserialize_byte(bytes)
			state.hands[other_player_idx] = {}
			for _=1,count do
				table.insert(state.hands[other_player_idx], cards.UNREVEALED_CARD)
			end
		elseif cards_visible == 1 then
			state.hands[other_player_idx] = cards.deserialize_card_array(bytes)
			for _, card in ipairs(state.hands[other_player_idx]) do
				if card == cards.UNREVEALED_CARD then
					error(string.format("Unexpected card value: %d", card))
				end
				if type(card) ~= 'table' then
					error(string.format("Unexpected card value: %s", type(card)))
				end
			end
		else
			-- TODO unhandled
			error(string.format("unhandled cards_visible val=%d", cards_visible))
		end
	end

	for other_player_idx=1,state.player_count do
		state.playing[other_player_idx] = cards.deserialize_card_array(bytes)
	end
	for other_player_idx=1,state.player_count do
		state.played[other_player_idx] = cards.deserialize_card_array(bytes)
	end

	state.tentative_discards = {}
	for player_idx=1,state.player_count do
		state.tentative_discards[player_idx] = deserialize_255bool_ary(bytes)
	end

	state.score = {}
	for player_idx=1,state.player_count do
		state.score[player_idx] = deserialize_byte(bytes)
	end

	state.crib = cards.deserialize_card_array(bytes)

	state.acknowledged_points = deserialize_255bool_ary(bytes)


	if #bytes ~= 0 then
		error(string.format("%d bytes remaining after deserializing", #bytes))
	end

	return state
end

return serialize
-- Run this script by the standalone lua interpeter, from either repo root or src/lua_scripts
package.path = 'src/lua_scripts/?.lua;?.lua'

local core = require("games/crib/crib_core")
local cards = require("libs/cards/cards")

local print_test_passes = false

local test_passes = 0
local test_failures = 0
local error_on_failure = false

-- TODO extract all this boilerplate test stuff into a generic module that accepts
-- running a function or something
local function test_hand(msg, hand, extra_card, expected_points)
	local actual_points = core.check_points_sequence(hand, extra_card).points
	if expected_points ~= actual_points then
		test_failures = test_failures + 1
		local msg_to_print = string.format("Expected hand=%s, extra_card=%s to be worth " ..
		                                   "%d points, was worth %d. Msg=%s",
		                                   cards.card_array_to_string(hand),
		                                   cards.card_to_string(extra_card),
		                                   expected_points, actual_points, msg)
		if error_on_failure then
			error(msg_to_print)
		else
			print(msg_to_print)
		end
	else
		test_passes = test_passes + 1
		if print_test_passes then
			print(string.format("Hand=%s, extra_card=%s was correctly worth %d points. Msg=%s",
			cards.card_array_to_string(hand), cards.card_to_string(extra_card), actual_points, msg))
		end
	end
end

test_hand("nothing", {
		{ suit = cards.DIAMONDS, val = 2 },
		{ suit = cards.CLUBS,    val = 4 },
		{ suit = cards.DIAMONDS, val = 6 },
		{ suit = cards.DIAMONDS, val = 8 },
	},
	{ suit = cards.CLUBS, val = cards.KING},
	0
)

test_hand("4 of suit", {
		{ suit = cards.DIAMONDS, val = 2 },
		{ suit = cards.DIAMONDS, val = 4 },
		{ suit = cards.DIAMONDS, val = 6 },
		{ suit = cards.DIAMONDS, val = 8 },
	},
	{ suit = cards.CLUBS, val = cards.KING},
4)

test_hand("run of 4 + one 15", {
		{ suit = cards.DIAMONDS, val =  7 },
		{ suit = cards.CLUBS,    val =  8 },
		{ suit = cards.DIAMONDS, val =  9 },
		{ suit = cards.DIAMONDS, val = 10 },
	},
	{ suit = cards.CLUBS, val = 2},
	4 + 2
)

test_hand("two runs of 4 + pair + fifteen", {
		{ suit = cards.DIAMONDS, val =  7 },
		{ suit = cards.CLUBS,    val =  8 },
		{ suit = cards.DIAMONDS, val =  9 },
		{ suit = cards.DIAMONDS, val = 10 },
	},
	{ suit = cards.CLUBS, val = 10},
	2*4 + 2 + 2
)

test_hand("run of 5 + two fifteen (6+9, 8+7)", {
		{ suit = cards.DIAMONDS, val =  6 },
		{ suit = cards.CLUBS,    val =  7 },
		{ suit = cards.DIAMONDS, val =  8 },
		{ suit = cards.DIAMONDS, val =  9 },
	},
	{ suit = cards.CLUBS, val = 10},
	5 + 2*2
)

test_hand("run of 5 + two fifteen (6+9, 8+7) + flush", {
		{ suit = cards.DIAMONDS, val =  6 },
		{ suit = cards.DIAMONDS, val =  7 },
		{ suit = cards.DIAMONDS, val =  8 },
		{ suit = cards.DIAMONDS, val =  9 },
	},
	{ suit = cards.CLUBS, val = 10},
	5 + 2*2 + 4
)

-- TODO why is this one failing?
test_hand("three 10s + two 5s = 6 fifteens + 1 pair of two + 1 pair of three", {
		{ suit = cards.DIAMONDS, val =  10 },
		{ suit = cards.CLUBS,    val =  cards.KING },
		{ suit = cards.DIAMONDS, val =  5 },
		{ suit = cards.HEARTS,   val =  5 },
	},
	{ suit = cards.SPADES, val = 10},
	6*2 + 2 + 6
)

test_hand("pair of three", {
		{ suit = cards.DIAMONDS, val =  10 },
		{ suit = cards.CLUBS,    val =  10 },
		{ suit = cards.SPADES,   val =  10 },
		{ suit = cards.HEARTS,   val =  9 },
	},
	{ suit = cards.SPADES, val = 2},
	6
)

test_hand("pair of four", {
		{ suit = cards.DIAMONDS, val =  10 },
		{ suit = cards.CLUBS,    val =  10 },
		{ suit = cards.SPADES,   val =  10 },
		{ suit = cards.HEARTS,   val =  10 },
	},
	{ suit = cards.SPADES, val = 2},
	12
)

print(string.format("Tests passed: %d", test_passes))
print(string.format("Tests failed: %d", test_failures))

if test_failures > 0 or test_passes == 0 then
	return -1
end
local core = {}

local words_lib = require("libs/words")
local shuffle   = require("libs/shuffle")

local letter_tiles = require("libs/letter_tiles")

local LANGUAGE = "en"

core.LETTER_EMPTY = letter_tiles.LETTER_EMPTY

core.RC_SUCCESS = 0
core.RC_LETTERS_NOT_IN_A_LINE   = -1
core.RC_LETTERS_NOT_CONTINUOUS  = -2
core.RC_WORD_NOT_IN_DICTIONARY  = -3

local RC_TO_STR_MAP = {
	[core.RC_LETTERS_NOT_IN_A_LINE]  = "Letters not in a horizontal or vertical line",
	[core.RC_LETTERS_NOT_CONTINUOUS] = "Letters not continuous",
	[core.RC_WORD_NOT_IN_DICTIONARY] = "Word not in dictionary",
}


local LETTERS_PER_PLAYER = 8

local LETTER_AMOUNTS = {
	{ letter = "E", count = 14, points = 1 },
	{ letter = "A", count = 10, points = 1 },
	{ letter = "I", count =  8, points = 1 },
	{ letter = "O", count =  7, points = 1 },
	{ letter = "N", count =  8, points = 1 },
	{ letter = "R", count =  8, points = 1 },
	{ letter = "T", count =  6, points = 1 },
	{ letter = "L", count =  5, points = 1 },
	{ letter = "S", count =  4, points = 1 },
	{ letter = "U", count =  4, points = 1 },

	{ letter = "D", count =  4, points = 2 },
	{ letter = "G", count =  3, points = 2 },

	{ letter = "B", count =  2, points = 2 },
	{ letter = "C", count =  2, points = 2 },
	{ letter = "M", count =  2, points = 3 },
	{ letter = "P", count =  2, points = 3 },

	{ letter = "F", count =  2, points = 5 },
	{ letter = "H", count =  2, points = 5 },
	{ letter = "V", count =  2, points = 5 },
	{ letter = "W", count =  2, points = 5 },
	{ letter = "Y", count =  2, points = 5 },

	{ letter = "K", count =  1, points = 6 },

	{ letter = "J", count =  1, points = 8 },
	{ letter = "X", count =  1, points = 9 },

	{ letter = "Q", count =  1, points = 10 },
	{ letter = "Z", count =  1, points = 10 },
}

local LETTERS_TO_POINTS = {}

for _, info in ipairs(LETTER_AMOUNTS) do
	LETTERS_TO_POINTS[info.letter] = info.points
end

function core.get_letter_points(letter)
	return LETTERS_TO_POINTS[letter]
end

function core.rc_to_str(rc)
	local s = RC_TO_STR_MAP[rc]

	if s == nil then
		error(string.format("Could not convert rc %s to string", rc))
	end

	return s
end

function core.submit_info_to_msg(submit_info)
	if submit_info.rc == core.RC_WORD_NOT_IN_DICTIONARY then
		return string.format("Word '%s' (pos y=%d,x=%d) not in dictionary", submit_info.word, submit_info.pos.y, submit_info.pos.x)
	else
		return core.rc_to_str(submit_info.rc)
	end
end

function core.new_state(player_count)
	words_lib.init(LANGUAGE)
	local state = {
		letters = {},
		players = {},
		grid_size_y = 12,
		grid_size_x = 12,

		grid = {},
	}

	for _, info in ipairs(LETTER_AMOUNTS) do
		for _=1,info.count do
			table.insert(state.letters, info.letter)
		end
	end

	shuffle.shuffle(state.letters)

	for _=1,player_count do
		local player_letters = {}
		for _=1,LETTERS_PER_PLAYER do
			local letter = table.remove(state.letters)
			table.insert(player_letters, letter)
		end
		table.insert(state.players, {
			letters = player_letters
		})
	end

	for y=1,state.grid_size_y do
		local row = {}
		for x = 1,state.grid_size_y do
			table.insert(row, core.LETTER_EMPTY)
		end
		table.insert(state.grid, row)
	end

	return state
end

local function sign(x)
	if x == 0 then return 0
	elseif x < 0 then return -1
	else return 1 end
end

local function letters_in_a_line(placed_letters)
	local dy = nil
	local dx = nil

	local prev_tile_info = nil
	for _, tile_info in ipairs(placed_letters) do
		if prev_tile_info ~= nil then
			local dy2 = prev_tile_info.y - tile_info.y
			local dx2 = prev_tile_info.x - tile_info.x

			if dy ~= nil then
				print(string.format("{y=%d, x=%d}, dy=%s, dx=%s, dy2=%s, dx2=%s", tile_info.y, tile_info.x, dy, dx, dy2, dx2))
				if dy == 0 and dy2 ~= 0 then return false end
				if dx == 0 and dx2 ~= 0 then return false end
	
				if dy == 0 and dx ~= 0 then
					--if sign(dx) ~= sign(dx2) then return false end
				elseif dx == 0 and dy ~= 0 then
					--if sign(dy) ~= sign(dy2) then return false end
				else
					return false
				end
			else
				dy = dy2
				dx = dx2
			end


		end
		prev_tile_info = tile_info
	end
	return true
end

local function get_letters_bounds(state, placed_letters)
	if #placed_letters == 0 then error("get_letters_bounds called with no placed_letters", 2) end
	local letters_start = nil
	local letters_end   = nil

	for _, letter_info in ipairs(placed_letters) do
		if letters_start == nil or
			(letter_info.y <= letters_start.y and
			 letter_info.x <= letters_start.x) then
			letters_start = letter_info
		end

		if letters_end == nil or
			(letter_info.y >= letters_end.y and
			 letter_info.x >= letters_end.x) then
			letters_end = letter_info
		end
	end

	-- TODO check if there are already letters before or after start/end?

	if letters_start == nil or letters_end == nil then
		error("could not find start or end of letters?")
	end
	return { start_pos = letters_start, end_pos = letters_end }
end

local function get_placed_letters_map(state, placed_letters)
	local placed_letters_map = {}
	for y=1,state.grid_size_y do
		placed_letters_map[y] = {}
	end
	for _, placed_letter_info in ipairs(placed_letters) do
		if placed_letters_map[placed_letter_info.y][placed_letter_info.x] ~= nil then
			error(string.format("already found letter at pos %d %d", placed_letter_info.y, placed_letter_info.x))
		end
		placed_letters_map[placed_letter_info.y][placed_letter_info.x] = placed_letter_info.letter
	end
	return placed_letters_map
end

local function get_letter(state, placed_letters, pt)
	local placed_letters_map = get_placed_letters_map(state, placed_letters)
	if placed_letters_map[pt.y][pt.x] then
		return placed_letters_map[pt.y][pt.x]
	else
		return state.grid[pt.y][pt.x]
	end
end


local function get_points_between_letters(state, bounds)
	local dy = sign(bounds.end_pos.y - bounds.start_pos.y)
	local dx = sign(bounds.end_pos.x - bounds.start_pos.x)
	print(string.format('get_points_between_letters, dy=%d, dx=%d', dy, dx))

	local pts = {}
	if dy ~= 0 then
		local x = bounds.start_pos.x
		for y=bounds.start_pos.y,bounds.end_pos.y,dy do
			table.insert(pts, { y = y, x = x })
		end
	elseif dx ~= 0 then
		local y = bounds.start_pos.y
		for x=bounds.start_pos.x,bounds.end_pos.x,dx do
			table.insert(pts, { y = y, x = x })
		end
	else
		table.insert(pts, { y = bounds.start_pos.y, x = bounds.start_pos.x })
	end
	return pts
end

local function letters_continuous(state, placed_letters)
	local bounds = get_letters_bounds(state, placed_letters)

	local placed_letters_map = get_placed_letters_map(state, placed_letters)

	for _, pos in ipairs(get_points_between_letters(state, bounds)) do
		if placed_letters_map[pos.y][pos.x] == nil and
		   state.grid[pos.y][pos.x] == core.LETTER_EMPTY then
			return false
		end
	end

	return true
end

local function get_word_formed(state, placed_letters)
	-- TODO need to get letters before and after if present
	local word = ""

	local bounds = get_letters_bounds(state, placed_letters)
	local placed_letters_map = get_placed_letters_map(state, placed_letters)
	for _, pt in ipairs(get_points_between_letters(state, bounds)) do
		local letter = nil
		if placed_letters_map[pt.y][pt.x] then
			letter = placed_letters_map[pt.y][pt.x]
		elseif state.grid[pt.y][pt.x] then
			letter = state.grid[pt.y][pt.x]
		else
			error(string.format("no letter at pos %d %d", pt.y, pt.x))
		end

		print(string.format("getting letter from pt %d %d: %s", pt.y, pt.x, letter))
		word = word .. letter
	end

	return word
end

local function in_range(state, y, x)
	return (1 <= y and y <= state.grid_size_y and
	        1 <= x and x <= state.grid_size_x)
end

local function find_end_pt(state, placed_letters, start_pt, dy, dx)
	print(string.format("find_end_pt called with pt %d %d, dy=%d, dx=%d", start_pt.y, start_pt.x, dy, dx))
	if dy == 0 and dx == 0 then return { y = start_pt.y, x = start_pt.x } end
	local y = start_pt.y
	local x = start_pt.x

	while true do
		if not in_range(state, y - dy, x - dx) then
			break
		end
		local letter = get_letter(state, placed_letters, { y = y - dy, x = x - dx })
		print(string.format("checking pt %d %d, %s", y, x, letter))
		if letter == core.LETTER_EMPTY then
			break
		end
		y = y - dy
		x = x - dx
	end

	print(string.format("find_end_pt returning with %d %d", y, x))
	return { y = y, x = x }
end

local function get_parallel_word_info(state, placed_letters, dy, dx)
	print(string.format("get_parallel_word_info"))
	local bounds = get_letters_bounds(state, placed_letters)
	local placed_letters_map = get_placed_letters_map(state, placed_letters)

	if dy ~= 0 and dx ~= 0 then
		error(string.format("expected horizontal or vertical line, received diagonal"))
	elseif dy == 0 and dx == 0 then
		-- for the case of a single letter (resulting in dy = 0 and dx = 0), just
		-- arbitrarily pick one to be 1, and the other to be 0.
		-- then this function (get_parallel_word_info) and the perpendicular one
		-- will work, even for this special case.
		error("expected non zero dy or dx.")
	end

	local start_pt = find_end_pt(state, placed_letters, bounds.start_pos, dy, dx)
	local end_pt   = find_end_pt(state, placed_letters, bounds.start_pos, -dy, -dx)

	local word = ""
	
	print(string.format("parallel word start %d %d, end %d %d", start_pt.y, start_pt.x, end_pt.y, end_pt.x))
	for offset=0,math.max(end_pt.y - start_pt.y, end_pt.x - start_pt.x) do
		local pt = {
			y = start_pt.y + offset*dy,
			x = start_pt.x + offset*dx
		}
		print(string.format("parallel word checking %d %d", pt.y, pt.x))

		local letter
		if placed_letters_map[pt.y][pt.x] then
			letter = placed_letters_map[pt.y][pt.x]
		elseif state.grid[pt.y][pt.x] then
			letter = state.grid[pt.y][pt.x]
		else
			error(string.format("could not find letter at %d %d", pt.y, pt.x))
		end

		word = word .. letter
	end

	return {
		start_pt = start_pt,
		end_pt   = end_pt,
		word     = word,
	}
end

local function between_pts(start_pt, end_pt)
	local dy = sign(end_pt.y - start_pt.y)
	local dx = sign(end_pt.x - start_pt.x)

	local pts = {}
	local y = start_pt.y
	local x = start_pt.x
	while y <= end_pt.y and x <= end_pt.x do
		table.insert(pts, { y = y, x = x })
		y = y + dy
		x = x + dx
	end

	return pts
end

local function find_perpendicular_word(state, placed_letters, pt, dy_arg, dx_arg)
	-- swap dy and dx: we're looking for perpendicular words
	local dy = dx_arg
	local dx = dy_arg

	local start_pt = find_end_pt(state, placed_letters, pt,  dy,  dx)
	local end_pt   = find_end_pt(state, placed_letters, pt, -dy, -dx)

	if start_pt.y == end_pt.y and
	   start_pt.x == end_pt.x then
		return nil
	else
		local word = ""
		for _, pt in ipairs(between_pts(start_pt, end_pt)) do
			local letter = get_letter(state, placed_letters, pt)
			word = word .. letter
		end
		return {
			start_pt = start_pt,
			end_pt   = end_pt,
			word     = word,
		}
	end
end

local function get_all_new_words_formed(state, placed_letters)
	local word_infos = {}
	local bounds = get_letters_bounds(state, placed_letters)

	local dy = sign(bounds.end_pos.y - bounds.start_pos.y)
	local dx = sign(bounds.end_pos.x - bounds.start_pos.x)

	local skip_parallel = false
	local skip_parallel = false
	if #placed_letters == 1 then
		assert(dy == 0)
		assert(dx == 0)

		-- Arbitrarily choosing horizontal as the "parallel" direction with one letter
		dx = 1

		-- Since I chose horizontal as "parallel", check if we need to actually
		-- look for "perpendicular" letters ( y-1 and y+1)
		local pt1 = { y = bounds.start_pos.y, x = bounds.start_pos.x - 1 }
		local pt2 = { y = bounds.start_pos.y, x = bounds.start_pos.x + 1 }

		local l1 = get_letter(state, placed_letters, pt1)
		local l2 = get_letter(state, placed_letters, pt2)
		print(string.format("l1=%s, l2=%s", l1, l2))
		if get_letter(state, placed_letters, pt1) == core.LETTER_EMPTY and
		   get_letter(state, placed_letters, pt2) == core.LETTER_EMPTY then
			skip_parallel = true
		end
	end
		
	if not skip_parallel then
		local parallel_word_info = get_parallel_word_info(state, placed_letters, dy, dx)
		print(string.format("Found parallel word: %s", parallel_word_info.word))
		table.insert(word_infos, parallel_word_info)
	end

	for _, pt in ipairs(get_points_between_letters(state, bounds)) do
		local perp_info = find_perpendicular_word(state, placed_letters, pt, dy, dx)
		if perp_info then
			print(string.format("Found perpendicular word: %s", perp_info.word))
			table.insert(word_infos, perp_info)
		end
	end

	return word_infos

end

local function get_idx_of_letter(letter_list, letter_val)
	for idx, val in ipairs(letter_list) do
		if letter_val == val then
			return idx
		end
	end
end

local function commit_placed_letters(state, player_idx, placed_letters)
	for _, placed_letter_info in ipairs(placed_letters) do
		state.grid[placed_letter_info.y][placed_letter_info.x] = placed_letter_info.letter
	end

	for _, placed_letter_info in ipairs(placed_letters) do
		local player_letters = state.players[player_idx].letters
		table.remove(player_letters, get_idx_of_letter(player_letters, placed_letter_info.letter))
	end
end

local function deal_more_tiles(state, player_idx)
	local player = state.players[player_idx]
	while #player.letters < LETTERS_PER_PLAYER do
		print("dealing player a new tile")
		local letter = table.remove(state.letters)
		table.insert(player.letters, letter)
	end
end
	

function core.submit(state, player_idx, placed_letters)
	print(string.format("core.submit... placed_letters len: %d", #placed_letters))

	print("checking if letters are in a line...")
	if not letters_in_a_line(placed_letters) then
		print("letters not in a line!")
		return { rc = core.RC_LETTERS_NOT_IN_A_LINE }
	end

	print("checking if letters are continuous...")
	if not letters_continuous(state, placed_letters) then
		print("letters not continuous!")
		return { rc = core.RC_LETTERS_NOT_CONTINUOUS }
	end

	local word_infos = get_all_new_words_formed(state, placed_letters)
	print(string.format("found %d words", #word_infos))
	for i, info in ipairs(word_infos) do
		print(string.format("%2d: %3d %3d %s", i, info.start_pt.y, info.start_pt.x, info.word))

		if not words_lib.is_valid_word(LANGUAGE, info.word) then
			return { rc = core.RC_WORD_NOT_IN_DICTIONARY, word = info.word, pos=info.start_pt }
		end
		
	end

	commit_placed_letters(state, player_idx, placed_letters)

	deal_more_tiles(state, player_idx)

	print(string.format("player tile count %d", #state.players[player_idx].letters))

	return { rc = core.RC_SUCCESS, word_infos = word_infos }
end

-- words_lib.get_words_made_from_letters

return core
local draw = {}

local alex_c_api = require("alex_c_api")

local core = require("games/crossword_builder/crossword_builder_core")

local letter_tiles = require("libs/letter_tiles")

draw.ACTION_SUBMIT = 1

local BTN_ID_SUBMIT = "submit"

local board_height = 480
local board_width  = 480

local GRID_BG_COLOUR = '#000000'
local GRID_LINE_COLOUR = '#888888'
local KEY_BACKGROUND_COLOUR = '#333388'
local COLOUR = '#888888'
local TEXT_SIZE = 18
local TEXT_SIZE_SCORE = 8

if false then
	GRID_BG_COLOUR = '#bb6644'
	GRID_LINE_COLOUR = '#000000'
	KEY_BACKGROUND_COLOUR = '#ee8800'
	COLOUR = '#000000'
else
	GRID_BG_COLOUR = '#bb6644'
	GRID_LINE_COLOUR = '#000000'
	KEY_BACKGROUND_COLOUR = '#ff8800'
	COLOUR = '#000000'
end


local padding = 5


local function get_large_piece_params()
	return {
		size            = 45,
		main_text_size  = 20,

		text_colour     = COLOUR,
		outline_colour  = COLOUR,
		background_colour = KEY_BACKGROUND_COLOUR,
		line_width      = 1,

		score_text_size =  8,
		padding_small   =  2,
		padding         = 5,

		show_score      = true,
		get_letter_points = core.get_letter_points,
	}
end

local function get_board_piece_params()
	return {
		size            = 23,
		main_text_size  = 18,

		outline_colour  = COLOUR,
		text_colour     = COLOUR,
		background_colour = KEY_BACKGROUND_COLOUR,

		highlight_colour = '#ffff00',
		highlight_width  = 2,

		score_text_size =  8,
		padding_small   =  2,
		padding         = 5,

		line_width      = 2,

		show_score      = false,
		--get_letter_points = core.get_letter_points,
	}
end


local KEY_WIDTH = 50
local KEY_HEIGHT = KEY_WIDTH

local KEY_POS_Y = board_height - get_large_piece_params().size + padding

function draw.init(game_state)
	local draw_state = {
		tiles = nil,
	}

	draw_state.tiles = letter_tiles.new_state({
		--touch_cursor_offset_y = -50,
		--touch_cursor_offset_x = 50,
		touch_cursor_offset_y = -65,
		--touch_cursor_offset_y = -45,
		touch_cursor_offset_x = 0,
	})
	letter_tiles.add_letter_row(draw_state.tiles, game_state.players[1].letters, { y = KEY_POS_Y, x = 480/2 }, get_large_piece_params())
	local y_count = game_state.grid_size_y
	local x_count = game_state.grid_size_x
	letter_tiles.add_grid(draw_state.tiles, {
		y_pos   = padding,
		x_pos   = math.floor(board_width - letter_tiles.get_grid_y_size(y_count, get_board_piece_params()))/2,
		y_count = y_count,
		x_count = x_count,
		bg_colour   = GRID_BG_COLOUR,
		line_colour = GRID_LINE_COLOUR,
		tile_params = get_board_piece_params(),
	})

	alex_c_api.create_btn(BTN_ID_SUBMIT, "Submit", 1)
	print("hello world")
	alex_c_api.set_btn_enabled(BTN_ID_SUBMIT, false)

	--draw_state.tiles.grids[1].tiles[2][1] = "F"
	--draw_state.tiles.grids[1].tiles[2][2] = "A"
	--draw_state.tiles.grids[1].tiles[2][3] = "C"
	--draw_state.tiles.grids[1].tiles[2][4] = "E"
	--draw_state.tiles.grids[1].tiles[2][5] = "D"
	return draw_state
end


function draw.draw(draw_state)
	alex_c_api.draw_clear()

	local params = get_large_piece_params()

	letter_tiles.draw(draw_state.tiles)

--[[
	local words = words_lib.get_words_made_from_letters(LANGUAGE, letters, 3, -1)

	for _, word in ipairs(words) do
		local freq = words_lib.get_word_freq(LANGUAGE, word)
		print(string.format("%-8s, %e", word, freq))
	end
--]]


	alex_c_api.set_btn_enabled(BTN_ID_SUBMIT, #draw_state.tiles.placed_tiles > 0)
	alex_c_api.draw_refresh()

end

function draw.handle_mouse_evt(draw_state, evt_id, pos_y, pos_x, params)
	letter_tiles.handle_mouse_evt(draw_state.tiles, evt_id, pos_y, pos_x, params)
end

function draw.handle_mousemove(draw_state, pos_y, pos_x, params)
	letter_tiles.handle_mousemove(draw_state.tiles, pos_y, pos_x, params)
end

function draw.handle_touch_evt(draw_state, evt_id, changed_touches)
	touch_to_mouse_evts.handle_touch_evt(draw_state.touch_to_mouse_evts, evt_id, changed_touches)
end

function draw.handle_btn_clicked(draw_state, btn_id)
	if btn_id == BTN_ID_SUBMIT then
		return draw.ACTION_SUBMIT
	end
end

function draw.get_placed_tiles(draw_state)
	return letter_tiles.get_placed_tiles(draw_state.tiles)
end


function draw.update_state(draw_state, game_state)
	letter_tiles.clear_placed_tiles(draw_state.tiles)
	letter_tiles.set_grid(draw_state.tiles, 1, game_state.grid)
	letter_tiles.set_row(draw_state.tiles, 1, game_state.players[1].letters)
end

return draw
local alex_c_api = require("alex_c_api")

local core = require("games/crossword_builder/crossword_builder_core")
local draw = require("games/crossword_builder/crossword_builder_draw")

local touch_to_mouse_evts = require("libs/touch_to_mouse_evts")

local words_lib = require("libs/words")


local state = {
	game = core.new_state(1),
	touch_to_mouse_evts = nil,
	draw = nil,
}

local player_idx = 1


state.draw = draw.init(state.game)

--[[
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 5, x_idx = 6 }, letter = "T" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 6, x_idx = 6 }, letter = "R" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 7, x_idx = 6 }, letter = "A" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 8, x_idx = 6 }, letter = "I" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 9, x_idx = 6 }, letter = "N" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx =10, x_idx = 6 }, letter = "E" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx =11, x_idx = 6 }, letter = "E" } )

local placed_tiles = draw.get_placed_tiles(state.draw)
local submit_info = core.submit(state.game, placed_tiles)
draw.update_state(state.draw, state.game)

table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 3, x_idx = 7 }, letter = "T" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 4, x_idx = 7 }, letter = "O" } )
table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 5, x_idx = 7 }, letter = "E" } )

local placed_tiles = draw.get_placed_tiles(state.draw)
local submit_info = core.submit(state.game, placed_tiles)
draw.update_state(state.draw, state.game)

table.insert(state.draw.tiles.placed_tiles, { pos = { grid_idx = 1, y_idx = 6, x_idx = 7 }, letter = "S" } )
--]]

function draw_board()
	draw.draw(state.draw)
end

function handle_mouse_evt(evt_id, pos_y, pos_x, params)
	--print(string.format("handle_mouse_evt(evt_id=%s, pos_y=%d, pos_x=%d)", evt_id, pos_y, pos_x))
	draw.handle_mouse_evt(state.draw, evt_id, pos_y, pos_x, params)
	draw_board()
end

function handle_mousemove(pos_y, pos_x, params)
	--print(string.format("handle_mousemove(pos_y=%d, pos_x=%d)", pos_y, pos_x))
	draw.handle_mousemove(state.draw, pos_y, pos_x, params)
	draw_board()
end

function handle_touch_evt(evt_id, changed_touches)
	touch_to_mouse_evts.handle_touch_evt(state.touch_to_mouse_evts, evt_id, changed_touches)
end

function handle_btn_clicked(btn_id)
	print(string.format("handle_btn_clicked(id=%s)", btn_id))
	local action = draw.handle_btn_clicked(state.draw, btn_id)

	if action == draw.ACTION_SUBMIT then
		local placed_tiles = draw.get_placed_tiles(state.draw)
		local submit_info = core.submit(state.game, player_idx, placed_tiles)
		print(string.format("submit returned: %s, %d", submit_info, submit_info.rc))
		if submit_info.rc == core.RC_SUCCESS then
			alex_c_api.set_status_msg(string.format("Successfully formed words: %s", submit_info.word))
			draw.update_state(state.draw, state.game)
			draw.draw(state.draw)
		else
			local msg = core.submit_info_to_msg(submit_info)
			print("rc is not success... " .. msg)
			alex_c_api.set_status_err(msg)
		end
	end
end

function start_game()
	alex_c_api.enable_evt("mouse_updown")
	alex_c_api.enable_evt("mouse_move")
	state.touch_to_mouse_evts = touch_to_mouse_evts.init({
		handle_mouse_evt  = handle_mouse_evt,
		handle_mousemove  = handle_mousemove,
	})
end
-- Author: Alex Barry (github.com/alexbarry)
local core = {}


local LANGUAGE = "en"

core.VERTICAL   = 1
core.HORIZONTAL = 2

core.EMPTY = " "

core.RC_SUCCESS              =  0
core.RC_NOT_IN_DICTIONARY    = -1
core.RC_NOT_IN_CROSSWORD     = -2
core.RC_WORD_ALREADY_FOUND   = -3
core.RC_LETTER_NOT_AVAILABLE = -4


local ORIENTATIONS = {
	core.VERTICAL,
	core.HORIZONTAL,
}

local ERR_MSGS = {
	[core.RC_NOT_IN_DICTIONARY]  = "Not in dictionary",
	[core.RC_NOT_IN_CROSSWORD]   = "Not in crossword",
	[core.RC_WORD_ALREADY_FOUND] = "Word already found",
	[core.RC_LETTER_NOT_AVAILABLE] = "Letter not available",
}

local ALPHABET = {}
for i=0,25 do
	table.insert(ALPHABET, string.char(string.byte('a') + i))
end

function core.rc_to_msg(rc)
	return ERR_MSGS[rc]
end

local g_get_words_func = nil

function core.set_get_words_func(get_words_func)
	g_get_words_func = get_words_func
end

local function sqlite_query(query)
	return g_get_words_func(query)
end


local function get_words_made_from_letters(letters, min_length, min_freq)
	local letters_count = {}
	for _, letter in ipairs(letters) do
		if letters_count[letter] == nil then
			letters_count[letter] = 0
		end
		letters_count[letter] = letters_count[letter] + 1
	end
	local query = "SELECT word FROM words WHERE\n"
	query = query .. string.format(" LENGTH(word) <= %d \n", #letters)
	query = query .. string.format(" AND LENGTH(word) >= %d \n", min_length)
	query = query .. string.format(" AND freq >= %e \n", min_freq)
	query = query .. string.format(" AND NOT words.is_vulgar_or_weird \n")
	local first = true
	for _, letter in pairs(ALPHABET) do
		local count = 1
		if letters_count[letter] ~= nil then
			count = letters_count[letter] + 1
		end
		query = query .. " AND word NOT LIKE '%"
		for _=1,count do
			query = query .. letter .. "%"
		end
		query = query .. "'\n"
	end
	query = query .. "ORDER BY LENGTH(word) DESC, freq DESC \n"
	query = query .. "LIMIT 20 \n"

	--print(query)
	return sqlite_query(query)
end

local function copy_list_except_idx(list, except_idx)
	local new_list = {}
	for idx, val in ipairs(list) do
		if idx ~= except_idx then
			table.insert(new_list, val)
		end
	end
	return new_list
end

function core.generate_empty_crossword(height, width)
	local rows = {}
	for y=1,height do
		local row = {}
		for x=1,width do
			table.insert(row, core.EMPTY)
		end
		table.insert(rows, row)
	end
	local crossword = {
		grid  = rows,

		word_count = 0,
		-- elements in words should be: {
		--     word = "crane",
		--     pos = { y = 1, x = 1},
		--     orientation = core.VERTICAL,
		-- }
		words = {},
	}
	return crossword
end

local function get_word_positions(word, start_pos, orientation)
	if word == nil then error("word is nil", 2) end
	if start_pos == nil then error("start_pos is nil", 2) end
	if type(word) ~= "string" then error("word is not str", 2) end
	local positions = {}
	for i=1,#word do
		local letter = word:sub(i,i)
		local letter_pos = { y = start_pos.y, x = start_pos.x , letter = letter, idx = i }
		if orientation == core.HORIZONTAL then
			letter_pos.x = letter_pos.x + (i-1)
		elseif orientation == core.VERTICAL then
			letter_pos.y = letter_pos.y + (i-1)
		else
			error(string.format("Unexpected orientation %s", orientation), 2)
		end

		table.insert(positions, letter_pos)
	end

	return positions
end

-- Only meant to be called by serialize functions.
-- Not meant to be called outside this file for any other purpose.
function core.add_word_to_crossword_modify(crossword, pos, orientation, word)
	for _, p in ipairs(get_word_positions(word, pos, orientation)) do
		crossword.grid[p.y][p.x] = p.letter
	end

	crossword.word_count = crossword.word_count + 1
	crossword.words[word] = {
		word        = word,
		pos         = pos,
		orientation = orientation,
	}
end

local function get_letters_revealed_for_word(state, word)
	local crossword = core.get_filled_crossword_grid(state)
	local word_info = state.finished_crossword.words[word]
	local letters_revealed = 0
	for _, pos in ipairs(get_word_positions(word, word_info.pos, word_info.orientation)) do
		if crossword[pos.y][pos.x] ~= "?" then
			letters_revealed = letters_revealed + 1
		end
	end

	return letters_revealed
end

local function copy_crossword(crossword)
	local new_crossword = core.generate_empty_crossword(#crossword.grid, #crossword.grid[1])
	
	for _, word in pairs(crossword.words) do
		core.add_word_to_crossword_modify(new_crossword, word.pos, word.orientation, word.word)
	end

	return new_crossword
end

local function add_word_to_crossword(crossword, pos, orientation, word)
	local crossword = copy_crossword(crossword)
	core.add_word_to_crossword_modify(crossword, pos, orientation, word)
	return crossword
end


local function pos_in_range(crossword, pos)
	return ((1 <= pos.y and pos.y <= #crossword.grid) and
	        (1 <= pos.x and pos.x <= #crossword.grid[1]))
end

local function other_orientation(orientation)
	if orientation == core.VERTICAL then return core.HORIZONTAL
	elseif orientation == core.HORIZONTAL then return core.VERTICAL
	else error(string.format("unexpected orientation %s", orientation), 2) end
end

local function get_adjacent_positions(pos, orientation)
	local adjacent_positions = {}

	if orientation == core.HORIZONTAL then
		table.insert(adjacent_positions, { y = pos.y    , x = pos.x + 1 })
		table.insert(adjacent_positions, { y = pos.y    , x = pos.x - 1 })
	elseif orientation == core.VERTICAL then
		table.insert(adjacent_positions, { y = pos.y + 1, x = pos.x     })
		table.insert(adjacent_positions, { y = pos.y - 1, x = pos.x     })
	end
	return adjacent_positions
end

function core.crossword_to_string(crossword)
	if crossword == nil then
		return "crossword is nil"
	end

	local output = ""
	output = output .. ("+")
	for x=1,#crossword.grid[1] do
		output = output .. ("-")
	end
	output = output .. ("+\n")
	for y=1,#crossword.grid do
		output = output .. ("|")
		for x=1,#crossword.grid[1] do
			local c = crossword.grid[y][x]
			--if c == nil then
			--	c = ' '
			--end
			output = output .. (c)
		end
		output = output .. ("|\n")
	end
	output = output .. ("+")
	for x=1,#crossword.grid[1] do
		output = output .. ("-")
	end
	output = output .. ("+\n")

	return output
end

function core.print_crossword(crossword)
	print(core.crossword_to_string(crossword))
end

local function get_all_possible_positions(crossword)
	local positions = {}
	for y=1,#crossword.grid do
		for x=1,#crossword.grid[1] do
			for _, orientation in ipairs(ORIENTATIONS) do
				table.insert(positions, {y=y, x=x, orientation=orientation})
			end
		end
	end
	return positions
end

local function get_edge_positions(word, pos, orientation)
	local positions = {}
	if orientation == core.VERTICAL then
		table.insert(positions, { y = pos.y - 1    , x = pos.x })
		table.insert(positions, { y = pos.y + #word, x = pos.x })
	elseif orientation == core.HORIZONTAL then
		table.insert(positions, { y = pos.y, x = pos.x - 1     })
		table.insert(positions, { y = pos.y, x = pos.x + #word })
	else
		error(string.format("unexpected orientation %s", orientation), 2)
	end

	return positions
end

-- Checks if the word fits in the crossword at the specified pos and oritentation.
local function word_fits_in_crossword(crossword, word, pos, orientation, empty_ok)

	local edge_positions = get_edge_positions(word, pos, orientation)
	for _, edge_pos in ipairs(edge_positions) do
		if not pos_in_range(crossword, edge_pos) then
			goto next_edge_pos
		end

		if crossword.grid[edge_pos.y][edge_pos.x] ~= core.EMPTY then
			return false
		end
		::next_edge_pos::
	end

	local found_letter = false
	local positions = get_word_positions(word, pos, orientation)


	for _, pos in ipairs(positions) do
		if not pos_in_range(crossword, pos) then
			return false
		end

		-- ensure destination cell is the same as what we're
		-- placing over it, or that it's empty
		if crossword.grid[pos.y][pos.x] ~= pos.letter and
		   crossword.grid[pos.y][pos.x] ~= core.EMPTY then
			return false
		end

		if crossword.grid[pos.y][pos.x] == pos.letter then
			found_letter = true
		else
			-- If this cell isn't already occupied, then make sure that
			-- it's not adjacent to any existing letters
			for _, adjacent_pos in ipairs(get_adjacent_positions(pos, other_orientation(orientation))) do
				if pos_in_range(crossword, adjacent_pos) and
				   crossword.grid[adjacent_pos.y][adjacent_pos.x] ~= core.EMPTY then
					return false
				end
			end
		end
		
	end


	if empty_ok then
		return true
	else
		return found_letter
	end
end

local function get_possible_positions(crossword, word, empty_ok)
	local positions = {}
	for y=1,#crossword.grid do
		for x=1,#crossword.grid[1] do
			for _, orientation in ipairs(ORIENTATIONS) do
				local pos = { y = y, x = x }
				if word_fits_in_crossword(crossword, word, pos, orientation, empty_ok) then
					table.insert(positions, { pos = pos, orientation = orientation })
				end
			end
		end
	end
	return positions
end

local function generate_crossword_from_words(words, crossword)

	-- instead of finding the best, find first
	local FIND_FIRST = true

	--core.print_crossword(crossword)
	local max_score             = nil
	local best_crossword        = nil
	local best_next_word        = nil
	local best_next_pos         = nil
	local best_next_orientation = nil
	--print(string.format("generate_crossword from %d words...", #words))
	for word_idx, word in ipairs(words) do
		local empty_ok = (crossword.word_count == 0)
		if type(word) ~= "string" then error("word is not string") end
		local positions = get_possible_positions(crossword, word, empty_ok)
		--print(string.format("trying word: %-12s, positions %d", word, #positions))
		for _, pos in ipairs(positions) do
			local crossword2 = add_word_to_crossword(crossword, pos.pos, pos.orientation, word)

			local words2 = copy_list_except_idx(words, word_idx)

			local finished_crossword
			if #words2 == 0 then
				finished_crossword = crossword2
				--core.print_crossword(crossword2)
				--print("-------")
			else
				--print(string.format("Selected word \"%s\", generating crossword with %d other words", word, #words2))
				finished_crossword = generate_crossword_from_words(words2, crossword2)
			end
			--print(string.format("Successfully generated crossword"))

			if finished_crossword ~= nil and (max_score == nil or #finished_crossword.word_count >= max_score) then
				max_score             = finished_crossword.word_count
				best_crossword        = finished_crossword
				best_next_word        = word
				best_next_pos         = pos
				best_next_orientation = orientation
			end

			if FIND_FIRST and finished_crossword ~= nil then
				return finished_crossword
			end
		end
	end

	return best_crossword
end


function core.generate_crossword(words, height, width)
	return generate_crossword_from_words(words, core.generate_empty_crossword(height, width))
end

local function take_first_x_vals(vals, x)
	local new_vals = {}
	for i=1,#vals do
		if i > x then return new_vals end
		table.insert(new_vals, vals[i])
	end 
	return new_vals
end

function core.generate_crossword_from_letters(letters, params)
	--print("called generate_crossword_from_letters")

	local words = get_words_made_from_letters(letters, params.min_word_len, params.min_word_freq)
	--print(string.format("found %d words that can be made from letters", #words))

	for _, word in ipairs(words) do
		--print(word)
	end

	if #words <= 4 then
		local letters_str = "{"
		local first = true
		for _, letter in ipairs(letters) do
			if not first then letters_str = letters_str .. ", " end
			first = false
			letters_str = letters_str .. letter
		end
		letters_str = letters_str .. "}"
		error(string.format("Could not find at least 4 words made from letters: %s", letters_str))
	end

	local crossword = nil
	--for i=4,#words do
	if true then
		i = #words
		local words2 = take_first_x_vals(words, 18)
		
		--print(string.format("Generating crossword with first %d words...", #words2))
		crossword = core.generate_crossword(words2, params.crossword_height, params.crossword_width)
		--print(i)
		--core.print_crossword(crossword)
	end

	return crossword
	
end

local function orientation_to_lua_str(orientation)
	if orientation == core.HORIZONTAL then
		return 'core.HORIZONTAL'
	elseif orientation == core.VERTICAL then
		return 'core.VERTICAL'
	else
		error(string.format("Unhandled orientation %s", orientation), 2)
	end
end

local function str_list_to_hr_str(str_list)
	local output = "{"
	local first = true
	for _, str in ipairs(str_list) do
		if not first then
			output = output .. ", "
		end
		first = false
		output = output .. string.format("%q", str)
	end
	output = output .. "}"

	return output
end

-- Rather than run the computationally expensive act of crossword generation
-- on the user's browser/PC before they can play anything, this function is
-- used to convert the generated crossword into a string of Lua code
-- that can be hardcoded in with the game, to "preload" some pre-generated
-- puzzles.
function core.crossword_words_to_lua_code(letters, crossword)
	local output = "{\n"
	output = output .. string.format("\tletters = %s,\n", str_list_to_hr_str(letters))
	output = output .. "\tword_positions = {\n"
	for _, word in pairs(crossword.words) do
		output = output .. string.format("\t\t{ word = %-20s, pos = { y = %2d, x = %2d }, orientation = %-17s},\n",
		                                 string.format("%q", word.word),
		                                 word.pos.y, word.pos.x,
		                                 orientation_to_lua_str(word.orientation))
	end
	output = output .. "\t},\n"
	output = output .. "},\n"
	return output
end

--function core.new_game(letters, params)
--end

function core.new_game_from_crossword(puzzle_id, crossword, letters)
	local state = {
		puzzle_id          = puzzle_id,
		letters            = letters,
		finished_crossword = crossword,

		finished           = false,
		
		-- key is found word
		found_words        = {},

		-- each hint is simply { y = y, x = x}
		hint_letters       = {},
		hint_word          = nil,
	}
	return state
end

local function crossword_from_word_list(word_positions, params)
	local crossword = core.generate_empty_crossword(params.crossword_height, params.crossword_width)
	for _, word in pairs(word_positions) do
		core.add_word_to_crossword_modify(crossword, word.pos, word.orientation, word.word)
	end
	return crossword
end


function core.new_game_from_pregen_puzzle(puzzle_id, puzzle, params)
	local crossword = crossword_from_word_list(puzzle.word_positions, params)
	return core.new_game_from_crossword(puzzle_id, crossword, puzzle.letters, params)
end

function core.get_filled_crossword_grid(state, show_all)
	local filled_crossword_grid = core.generate_empty_crossword(#state.finished_crossword.grid, #state.finished_crossword.grid[1]).grid
	for y=1,#filled_crossword_grid do
		for x=1,#filled_crossword_grid[y] do
			--print(string.format("crossword[%d][%d] = %q (%s, %s)", y, x, state.finished_crossword.grid[y][x], state.finished_crossword.grid[y][x] == core.EMPTY, core.EMPTY))
			filled_crossword_grid[y][x] = ""
			if state.finished_crossword.grid[y][x] ~= core.EMPTY then
				filled_crossword_grid[y][x] = "?"
			end
		end
	end
	--print(string.format("generated grid of height %d, width %d", #filled_crossword_grid, #filled_crossword_grid[1]))
	if show_all then
		for _, word_info in pairs(state.finished_crossword.words) do
			-- TODO note that this actually solves the crossword in state.
			-- this is bad. It should only show the words.
			-- But I am lazy and taking a shortcut since this is just for testing for now.
			--print(string.format("word is: %s", word_info.word))
			state.found_words[word_info.word] = true
		end
	end
	for word, _ in pairs(state.found_words) do
		local word_info = state.finished_crossword.words[word]
		local cell_positions = get_word_positions(word_info.word, word_info.pos, word_info.orientation)
		for _, pos in ipairs(cell_positions) do
			--print(string.format("populating pos %d %d with letter %s", pos.y, pos.x, pos.letter))
			filled_crossword_grid[pos.y][pos.x] = pos.letter
		end
	end

	for _, hint in ipairs(state.hint_letters) do
		-- they should be the same anyway... but it feels weird
		-- to overwrite a cell with a hint, if the rest of the word
		-- was already guessed correctly.
		if filled_crossword_grid[hint.y][hint.x] == "?" then
			filled_crossword_grid[hint.y][hint.x] = state.finished_crossword.grid[hint.y][hint.x]
		end
	end
	return filled_crossword_grid
end

local function is_game_finished(state)
	for word, _ in pairs(state.finished_crossword.words) do
		if not state.found_words[word] then
			return false
		end
	end
	return true
end

function core.word_input(state, word)
	word = string.lower(word)
	if state.finished_crossword.words[word] == nil then
		return core.RC_NOT_IN_CROSSWORD
	end
	if state.found_words[word] then
		return core.RC_WORD_ALREADY_FOUND
	end

	print("User found word %q", word)
	state.found_words[word] = true
	if is_game_finished(state) then
		state.finished = true
	end
	return core.RC_SUCCESS
end

function find_word_with_fewest_letters_revealed(state)
	local min_letters_revealed = nil
	local min_letters_word     = nil
	for word, word_info in pairs(state.finished_crossword.words) do
		if state.found_words[word] ~= nil then
			goto next_word
		end
		local letters_revealed = get_letters_revealed_for_word(state, word)
		if letters_revealed ~= #word and
		   (min_letters_revealed == nil or
		   letters_revealed <= min_letters_revealed or
		   #min_letters_word < #word) then
			min_letters_revealed = letters_revealed
			min_letters_word     = word
		end

		::next_word::
	end

	return min_letters_word
end

function core.hint(state)
	-- see if the word previously chosen for hints has now been fully revealed
	if state.hint_word ~= nil then
		local revealed = get_letters_revealed_for_word(state, state.hint_word)
		print(string.format("existing hint word %q has %s letters revealed, len %s", state.hint_word, revealed, #state.hint_word))
	end
	if state.hint_word ~= nil and
	   get_letters_revealed_for_word(state, state.hint_word) == #state.hint_word then
		print(string.format("existing hint word %q has all %d letters revealed, finding new hint word", state.hint_word, #state.hint_word))
		state.hint_word = nil
	end

	-- if we don't have a chosen hint word, choose one
	if state.hint_word == nil then
		state.hint_word = find_word_with_fewest_letters_revealed(state)

		if state.hint_word == nil then
			print("Can't provide hint, all letters have been revealed!")
			return
		end
	end

	local crossword = core.get_filled_crossword_grid(state)
	print(string.format("Looking for word %q", state.hint_word))
	local word_info = state.finished_crossword.words[state.hint_word]

	for _, pos in ipairs(get_word_positions(state.hint_word, word_info.pos, word_info.orientation)) do
		if crossword[pos.y][pos.x] == "?" then
			table.insert(state.hint_letters, { y = pos.y, x = pos.x })
			return
		end
	end

end

return core
-- Author: Alex Barry (github.com/alexbarry)
local alex_c_api  = require("alex_c_api")
local draw_shapes = require("libs/draw/draw_shapes")

local draw_celebration_anim = require("libs/draw/draw_celebration_anim")
local buttons = require("libs/ui/buttons")

local core = require("games/crossword_letters/crossword_letters_core")

local draw = {}

draw.ACTION_SUBMIT      = 1
draw.ACTION_HINT        = 2
draw.ACTION_NEW_PUZZLE  = 3
draw.ACTION_PREV_PUZZLE = 4
draw.ACTION_NEXT_PUZZLE = 5

local board_width  = 480
local board_height = 480


local BTN_ID_HINT   = "hint"
local BTN_ID_BKSP   = "bksp"
local BTN_ID_SUBMIT = "submit"

local SOFT_BTN_ID_PREV_PUZZLE = "prev_puzzle"
local SOFT_BTN_ID_NEXT_PUZZLE = "next_puzzle"

local SOFT_BTN_WIDTH  = 50
local SOFT_BTN_HEIGHT = 50
local SOFT_BTN_BG_COLOUR      = "#bbbbbb"
local SOFT_BTN_FG_COLOUR      = "#000000"
local SOFT_BTN_OUTLINE_WIDTH  = 2
local SOFT_BTN_TEXT_SIZE      = 12
local padding = 5


local CELL_SIZE    = 25
local PADDING  = 5
local TEXT_PADDING = 5
local CELL_TEXT_SIZE = 16

local crossword_y_offset = CELL_TEXT_SIZE + PADDING

local KEY_TEXT_SIZE = 24

local CELL_BG_COLOUR         = '#0088ee'
local CELL_BG_COLOUR_OUTLINE = '#000000'

KEY_USED_BG_COLOUR           = '#88888888'
KEY_USED_FG_COLOUR           = '#cccccc88'

local CELL_BG_COLOUR_OUTLINE_WIDTH = 2
local CELL_FG_COLOUR         = "#000000"

if alex_c_api.get_user_colour_pref() == "dark" or 
   alex_c_api.get_user_colour_pref() == "very_dark" then 
	CELL_BG_COLOUR         = '#002244'
	CELL_BG_COLOUR_OUTLINE = '#666666'
	CELL_BG_COLOUR_OUTLINE_WIDTH = 2
	CELL_FG_COLOUR         = "#888888"

	KEY_USED_BG_COLOUR     = '#111111'
	KEY_USED_FG_COLOUR     = '#333333'

	SOFT_BTN_BG_COLOUR  = "#333333"
	SOFT_BTN_FG_COLOUR  = "#888888"
end

local function get_soft_btn_params(params)
	return {
		id             = params.id,
		text           = params.text,
		bg_colour      = SOFT_BTN_BG_COLOUR,
		fg_colour      = SOFT_BTN_FG_COLOUR,
		outline_colour = SOFT_BTN_FG_COLOUR,
		outline_width  = SOFT_BTN_OUTLINE_WIDTH,
		btn_shape      = buttons.BTN_SHAPE_RECT,
		shape_param    = nil,
		text_size      = SOFT_BTN_TEXT_SIZE,
		padding        = PADDING,
		y_start        = params.y_start,
		x_start        = params.x_start,
		y_end          = params.y_end,
		x_end          = params.x_end,
		callback       = nil,
	}
end


function draw.init(params)
	local ui_state = {
		input_letters = {},
		crossword_width_cells = nil,
		keys_used = {},
		buttons = buttons.new_state(),
		num_puzzles = params.num_puzzles,
	}

	buttons.new_button(ui_state.buttons, get_soft_btn_params({
		id      = SOFT_BTN_ID_PREV_PUZZLE,
		text    = "<",
		y_start = PADDING,
		x_start = PADDING,
		y_end   = PADDING + SOFT_BTN_HEIGHT,
		x_end   = PADDING + SOFT_BTN_WIDTH,
	}))

	buttons.new_button(ui_state.buttons, get_soft_btn_params({
		id      = SOFT_BTN_ID_NEXT_PUZZLE,
		text    = ">",
		y_start = PADDING,
		x_start = board_width - SOFT_BTN_WIDTH,
		y_end   = PADDING + SOFT_BTN_HEIGHT,
		x_end   = board_width - PADDING,
	}))

	ui_state.anim = draw_celebration_anim.new_state({
		on_finish = function()
			alex_c_api.set_timer_update_ms(0)
		end
	})

	alex_c_api.create_btn(BTN_ID_HINT,   "Hint",      1)
	alex_c_api.create_btn(BTN_ID_BKSP,   "Backspace", 2)
	alex_c_api.create_btn(BTN_ID_SUBMIT, "Submit"   , 2)
	return ui_state
end

local function get_cell_pos(ui_state, y, x)
	local y_offset = CELL_TEXT_SIZE + 2*PADDING
	local x_offset = math.floor((board_width - CELL_SIZE * ui_state.crossword_width_cells)/2)
	local pos = {
		y_start = (y-1) * CELL_SIZE + PADDING + y_offset,
		x_start = (x-1) * CELL_SIZE + PADDING + x_offset,
		y_end   = (y  ) * CELL_SIZE + PADDING + y_offset,
		x_end   = (x  ) * CELL_SIZE + PADDING + x_offset,
	} 
	pos.y_text = pos.y_end - TEXT_PADDING
	pos.x_text = pos.x_start + math.floor((pos.x_end - pos.x_start)/2)
	return pos
end

local function get_letter_size(letters)
	return math.floor(board_width / #letters - TEXT_PADDING)
end

local function get_key_pos(key_idx, letter_size)
	local key_y_start = 15 * CELL_SIZE
	local key_y_end   = board_height - PADDING
	local key_x_start = TEXT_PADDING + (key_idx-1) * (letter_size + PADDING)
	local key_x_end   = key_x_start + letter_size

	local text_y = key_y_start + (key_y_end - key_y_start)/2 + KEY_TEXT_SIZE/2
	local text_x = TEXT_PADDING + (key_idx-1+0.5) * (letter_size + PADDING)

	return {
		y_start = key_y_start,
		y_end   = key_y_end,
		x_start = key_x_start,
		x_end   = key_x_end,
		text_y      = text_y,
		text_x      = text_x,
	}

end

local function get_keys_used_map(ui_state)
	local keys_used_map = {}
	for _, keys_used_idx in ipairs(ui_state.keys_used) do
		keys_used_map[keys_used_idx] = true
	end 

	return keys_used_map
end

function draw.draw_state(ui_state, game_state)
	alex_c_api.draw_clear()
	if game_state == nil then return end
	local puzzle_id = "?"
	if game_state.puzzle_id ~= nil then
		puzzle_id = game_state.puzzle_id
	end
	local puzzle_id_text = string.format("Puzzle %3s of %3d", puzzle_id, ui_state.num_puzzles)
	alex_c_api.draw_text(puzzle_id_text, CELL_FG_COLOUR,
	                     CELL_TEXT_SIZE + PADDING, board_width/2,
	                     CELL_TEXT_SIZE,
	                     alex_c_api.TEXT_ALIGN_CENTRE)
	local show_all = false
	--show_all = true -- TODO DO NOT SUBMIT
	local crossword_grid = core.get_filled_crossword_grid(game_state, show_all)
	ui_state.crossword_width_cells = #crossword_grid

	for y, row in ipairs(crossword_grid) do
		for x, cell in ipairs(row) do
			--print(string.format("drawing cell {y=%2d, x=%2d}, cell=%s", y, x, cell))
			local pos = get_cell_pos(ui_state, y, x)

			-- TODO find a better way to indicate empty cells
			if #cell > 0 then
				if cell == "?" then cell = ' ' end
				--cell = game_state.finished_crossword.grid[y][x]
				alex_c_api.draw_rect(CELL_BG_COLOUR,
				                     pos.y_start, pos.x_start,
				                     pos.y_end,   pos.x_end)
				draw_shapes.draw_rect_outline(CELL_BG_COLOUR_OUTLINE, CELL_BG_COLOUR_OUTLINE_WIDTH,
				                              pos.y_start, pos.x_start,
				                              pos.y_end,   pos.x_end)
				if cell ~= core.EMPTY then
					cell = string.upper(cell)
					alex_c_api.draw_text(cell, CELL_FG_COLOUR,
					                     pos.y_text, pos.x_text,
					                     CELL_TEXT_SIZE,
					                     alex_c_api.TEXT_ALIGN_CENTRE)
				end
			end
		end
	end

	local letter_size = get_letter_size(game_state.letters) 
	local keys_used_map = get_keys_used_map(ui_state)
	for letter_idx, letter in ipairs(game_state.letters) do

		local key_pos = get_key_pos(letter_idx, letter_size)
		local key_bg_colour
		local key_fg_colour

		if keys_used_map[letter_idx] then
			key_bg_colour = KEY_USED_BG_COLOUR
			key_fg_colour = KEY_USED_FG_COLOUR
		else
			key_bg_colour = CELL_BG_COLOUR
			key_fg_colour = CELL_FG_COLOUR
		end

		alex_c_api.draw_rect(key_bg_colour,
		                     key_pos.y_start, key_pos.x_start,
		                     key_pos.y_end,   key_pos.x_end)

		alex_c_api.draw_text(string.upper(letter), key_fg_colour,
		                     key_pos.text_y, key_pos.text_x,
		                     KEY_TEXT_SIZE,
		                     alex_c_api.TEXT_ALIGN_CENTRE)
	end

	local input_display_y_start = 14 * CELL_SIZE
	local input_word = draw.get_word(ui_state)
	input_word = string.upper(input_word)
	alex_c_api.draw_text(input_word, CELL_FG_COLOUR,
	                     input_display_y_start,
	                     board_width/2,
	                     KEY_TEXT_SIZE,
	                     alex_c_api.TEXT_ALIGN_CENTRE)

	buttons.draw(ui_state.buttons)

	local dt = 1000/60 -- TODO
	draw_celebration_anim.update(ui_state.anim, dt/1000)
	draw_celebration_anim.draw(ui_state.anim)

	alex_c_api.draw_refresh()
end

local function get_letter_idx(ui_state, game_state, letter_arg)
	local keys_used_map = get_keys_used_map(ui_state)
	for letter_idx, letter in ipairs(game_state.letters) do
		if keys_used_map[letter_idx] then
			goto next_letter
		end

		if string.lower(letter) == string.lower(letter_arg) then
			return letter_idx
		end

		::next_letter::
	end
end

local function add_to_keys_used_letter_idx(ui_state, game_state, letter_idx)
	local keys_used_map = get_keys_used_map(ui_state)
	if not keys_used_map[letter_idx] then
		table.insert(ui_state.keys_used, letter_idx)
	else
		letter_idx = get_letter_idx(ui_state, game_state, game_state.letters[letter_idx])
		if letter_idx ~= nil then
			table.insert(ui_state.keys_used, letter_idx)
		end
	end
end

local function get_letters_map(game_state)
	local letters_map = {}
	for _, letter in ipairs(game_state.letters) do
		if letters_map[letter] == nil then
			letters_map[letter] = 0
		end
		letters_map[letter] = letters_map[letter] + 1
	end

	return letters_map
end

function draw.input_letter(ui_state, game_state, letter, letter_idx)
	if letter == nil then
		error("draw.input_letter received nil `letter` arg", 2)
	end

	local letters_map = get_letters_map(game_state)


	if letters_map[string.lower(letter)] == nil then
		return core.RC_LETTER_NOT_AVAILABLE
	end

	-- keyboard input doesn't provide an index, but touch/mouse input does
	if letter_idx == nil then
		letter_idx = get_letter_idx(ui_state, game_state, letter)
	end

	if letter_idx == nil then
		return core.RC_LETTER_NOT_AVAILABLE
	end
	table.insert(ui_state.keys_used, letter_idx)

	table.insert(ui_state.input_letters, letter)
	return core.RC_SUCCESS
end

function draw.backspace(ui_state)
	table.remove(ui_state.keys_used)
	table.remove(ui_state.input_letters)
end

function draw.get_word(ui_state)
	local output = ""
	for _, letter in ipairs(ui_state.input_letters) do
		output = output .. letter
	end

	return output
end

function draw.clear_input(ui_state)
	ui_state.input_letters = {}
	ui_state.keys_used     = {}
end

function draw.handle_user_clicked(ui_state, game_state, pos_y, pos_x)
	local btn_id_pressed = buttons.on_user_click(ui_state.buttons, pos_y, pos_x)
	if btn_id_pressed ~= nil then
		if btn_id_pressed == SOFT_BTN_ID_PREV_PUZZLE then
			return draw.ACTION_PREV_PUZZLE
		elseif btn_id_pressed == SOFT_BTN_ID_NEXT_PUZZLE then
			return draw.ACTION_NEXT_PUZZLE
		else
			error(string.format("Unhandled soft button ID \"%s\"", btn_id_pressed))
		end
	end
	local letter_size = get_letter_size(game_state.letters)
	for letter_idx, letter in ipairs(game_state.letters) do
		local key_pos = get_key_pos(letter_idx, letter_size)
		if key_pos.y_start <= pos_y and pos_y <= key_pos.y_end and
		   key_pos.x_start <= pos_x and pos_x <= key_pos.x_end then
			draw.input_letter(ui_state, game_state, letter, letter_idx)
		end
	end
end

function draw.handle_btn_clicked(ui_state, btn_id)
	if btn_id == BTN_ID_SUBMIT then
		return draw.ACTION_SUBMIT
	elseif btn_id == BTN_ID_BKSP then
		draw.backspace(ui_state)
	elseif btn_id == BTN_ID_HINT then
		return draw.ACTION_HINT
	end
end

function draw.handle_popup_btn_clicked(popup_id, btn_id)
end

function draw.player_won(ui_state)
	draw_celebration_anim.fireworks_display(ui_state.anim)
	local dt = 1000/60 -- TODO
	alex_c_api.set_timer_update_ms(dt)
end

return draw
#!/usr/bin/env lua
-- Unlike most other Lua scripts in this repo, this script is meant to be run
-- on a PC with any Lua program, it doesn't rely on any alexgames APIs.
-- It reads the dictionary file as an sqlite3 database.
-- Note that this means you need to run `src/dictionary/build_word_list_w_freq.py`
-- before you can run this script.
--
-- This script only prints to stdout. It outputs Lua code that defines
-- some `crossword_letter` puzzles, based on a hardcoded list of words/letters.
--
-- To find useful sets of letters, run `gen_crossword_letters2.py`.


--local core = require("src/lua_scripts/games/crossword_letters/crossword_letters_core")
package.path = 'src/lua_scripts/?.lua'
local core = require("games/crossword_letters/crossword_letters_core")
local shuffle = require("libs/shuffle")



local function get_words(query)
	local rows = {}
	--print(string.format('Executing query %q', query))
	local handle = io.popen(string.format("sqlite3 out/word_dict.db %q", query))
	while true do
		local result = handle:read("*l")
		if not result then break end
		--print(string.format("read result: %q", result))
		table.insert(rows, result)
	end
	handle:close()
	return rows
end

core.set_get_words_func(get_words)

local params = {
	min_word_len  = 3,
	min_word_freq = 1e-6,
	crossword_height = 12,
	crossword_width  = 12,
}

local letter_sets = {
--[[
	{ "f", "a", "c", "e", "d", "t"},
	{ "s", "c", "i", "e", "c", "n"},
	{ "d", "e", "i", "s", "r", "e"},
	{ "d", "o", "v", "e", "e", "t"},
	{ "m", "a", "r", "v", "e", "l"},
	{ "r", "s", "t", "e", "n", "e"},
	{ "e", "s", "t", "l", "n", "a"},
--]]


--[[
	"plates",
	"easter",
	"raised",
	"paints",
	"traces",
	"master",
	"median",
	"hearts",
	"ladies",
	"scrape",
	"faster",
	"gamers",
	"stable",
	"browse",
	"sought",
--]]

--[[
	"soothe",
	"hustle",
	"hunted",
	"yogurt",
	"outcry",
	"fronts",
	"rights",
	"forget",
	"births",
	"snitch",
	"outing",
	"bylaws",
	"covent",
	"hernia",
	"beware",
	"amount",
	"warren",
	"renown",
	"relish",
	"shiver",
	"freaky",
	"retake",
	"budget",
	"submit",
	"sphere",
	"beaver",
	"thorns",
	"reaper",
	"barker",
	"banish",
	"tubing",
--]]

-- TODO uncomment this one, I found these words on 2023-11-27
-- they make up a lot of 5 letter words (20, I think).
-- but the lua generate puzzle program was taking forever.
-- I suspect that it would be a lot better if I just limit the
-- number of words used when there are so many 5 letter words. They might not
-- all fit.
-- Perhaps the Lua algorithm should simply return the best puzzle it can within a few minutes or
-- so many iterations, though.
--[[
	"pastel",
	"alerts",
	"earths",
	"lasted",
	"merits",
	"master",
	"metals",
	"metals",
	"traced",
	"easter",
	"insert",
	"stable",
	"arches",
	"stared",
	"pacers",
	"faster",
	"waters",
	"steals",
	"shared",
--]]

	"others",
	"morale",
	"father",
	"herald",
	"metric",
	"backer",
	"voters",
	--"halted",
	"chapel",
	"farmed",
	"skates",
	"purest",
	"flared",
	--"delays",
	"finder",
	"loaned",
	"braids",
	"course",
	"chalet",
	"scaled",
	"curate",
	"scored",
	"hordes",
	"corset",
	"angled",
	"fiesta",
	"malice",
	"tigers",
	"banker",
	"banter",
	"brides",
	"saturn",
	"unites",
	"slider",
	"ponies",
	"hassle",
	"washer",
	"graves",
	"ratios",
	"reigns",
	"daring",
	"grants",
	"spores",
	"hermit",
	"almost",
	"modest",
	"floats",
	"harmed",
	"biased",
	"greasy",

-- Added on 2023-12-23
	--"slogan",
	"makers",
	"permit",
	"blamed",
	"parcel",
	"dancer",
	"finder",
	"linear",
	"course",
	"dental",
	"rained",
	--"meters",
	"bailed",
	"wander",
	"soften",
	"lesion",
	"alpine",
}

local function string_to_char_list(str)
	local char_list = {}
	for i=1,#str do
		local c = str:sub(i,i)
		table.insert(char_list, c)
	end
	return char_list
end

local header = [[
local puzzles = {}

local core = require("games/crossword_letters/crossword_letters_core")

puzzles.puzzles = {
]]

print(header)

for _, letter_set in ipairs(letter_sets) do
	letter_set = string_to_char_list(letter_set)
	shuffle.shuffle(letter_set)
	local crossword = core.generate_crossword_from_letters(letter_set, params)

	local crossword_str = core.crossword_to_string(crossword)
	crossword_str = "--" .. crossword_str:gsub("\n", "\n--")
	print(crossword_str)
	local output = core.crossword_words_to_lua_code(letter_set, crossword)
	print(output)
end


local footer = [[
}

return puzzles
]]

print(footer)
-- Crossword letters
-- Author: Alex Barry (github.com/alexbarry)
--
-- TODO:
--     * user still needs to enter words that were revealed completely by hints...
--       should automatically add word to "found words" if it was revealed with hints.
--       Make sure to check for the win condition in that case, too.
--
local alex_c_api  = require("alex_c_api")
local alex_dict   = require("alex_c_api.dict")

local core    = require("games/crossword_letters/crossword_letters_core")
local draw    = require("games/crossword_letters/crossword_letters_draw")
local puzzles = require("games/crossword_letters/crossword_letters_puzzles")
local serialize = require("games/crossword_letters/crossword_letters_serialize")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local PUZZLE_IDX_KEY = "crossword_letters_puzzle_idx"
local OLD_SAVED_STATE_KEY = "crossword_letters_state"

local GAME_OPTION_RESET_PUZZLE = "opt_reset_puzzle"

local POPUP_ID_RESET_PUZZLE_CONFIRM = "popup_id_reset_puzzle"

local state = {
	game_state = nil,
	ui_state   = nil,
}

-- TODO clean this up
state.ui_state   = draw.init({
	num_puzzles  = #puzzles.puzzles,
})

local function get_words(query)
	--print(query)
	local word_info = alex_dict.get_words(query, LANGUAGE)
	local words = {}
	for _, info in ipairs(word_info) do
		table.insert(words, info[1])
	end
	--print(string.format("found %d words", #words))
	return words
end

core.set_get_words_func(get_words)

local function get_saved_state_key(puzzle_id)
	if puzzle_id == nil then error("puzzle_id is nil", 2) end
	return string.format("crossword_letters_state_%04d", puzzle_id)
end

function draw_board()
	draw.draw_state(state.ui_state, state.game_state)
	update_saved_state()
end

function update_saved_state()
	if state.game_state == nil then return end
	local serialized_state = serialize.serialize_state(state.game_state)
	alex_c_api.store_data(PUZZLE_IDX_KEY, tostring(state.game_state.puzzle_id))
	alex_c_api.store_data(get_saved_state_key(state.game_state.puzzle_id), serialized_state)
end

local function str_list_to_str(str_list)
	local output = "{"
	for i, s in ipairs(str_list) do
		if i ~= 1 then
			output = output .. ", "
		end
		output = output .. s
	end
	return output .. "}"
end

local function new_puzzle(puzzle_id)
	print("Starting to generate game")
	local params = {
		min_word_len  = 3,
		min_word_freq = 1e-6,
		crossword_height = 12,
		crossword_width  = 12,
	}


	if puzzle_id == nil then
		puzzle_id = math.random(1, #puzzles.puzzles)
	end
	state.game_state = core.new_game_from_pregen_puzzle(puzzle_id, puzzles.puzzles[puzzle_id], params)
	draw.draw_state(state.ui_state, state.game_state)
	local letters_list_str = str_list_to_str(state.game_state.letters)
	alex_c_api.set_status_msg(string.format("Starting new game with letters: %s", letters_list_str))
	--update_saved_state()
end

local function str_array_eq(arr1, arr2)
	if #arr1 ~= #arr2 then return false end
	for i=1,#arr1 do
		if arr1[i] ~= arr2[i] then
			return false
		end
	end
	return true
end

local function find_puzzle_id(puzzles, game_state)
	for puzzle_id, puzzle in ipairs(puzzles) do
		if str_array_eq(game_state.letters, puzzle.letters) then
			return puzzle_id
		end
	end
	return nil
end

local function switch_puzzle(puzzle_id)
	local serialized_state = alex_c_api.read_stored_data(get_saved_state_key(puzzle_id))

	if serialized_state == nil then
		new_puzzle(puzzle_id)
	else
		state.game_state = serialize.deserialize_state(serialized_state)
	end

	print("Done generating game")

	draw.draw_state(state.ui_state, state.game_state)
	update_saved_state()
	print("Done drawing state")

end

function get_state()
	return serialize.serialize_state(state.game_state)
end

function start_game(session_idx, serialized_state)
	local puzzle_idx_serialized = alex_c_api.read_stored_data(PUZZLE_IDX_KEY)

	if serialized_state ~= nil then
		state.game_state = serialize.deserialize_state(serialized_state)
	elseif puzzle_idx_serialized == nil then

		-- TODO BEFORE PUBLISHING remove
		serialized_state = alex_c_api.read_stored_data(OLD_SAVED_STATE_KEY)

		-- legacy state, TODO BEFORE PUBLISHING remove
		if serialized_state ~= nil then
			state.game_state = serialize.deserialize_state(serialized_state)
	
			-- TODO BEFORE PUBLISHING remove this. Puzzle ID should be stored in the state.
			if state.game_state.puzzle_id == nil then
				state.game_state.puzzle_id = find_puzzle_id(puzzles.puzzles, state.game_state)
			end
	
			if state.game_state.puzzle_id ~= nil then
				alex_c_api.store_data(get_saved_state_key(state.game_state.puzzle_id), serialized_state)
			end
		-- no previous state
		else
			switch_puzzle(1)
		end
	else
		print(string.format("puzzle_idx_serialized is %s", puzzle_idx_serialized))
		local puzzle_id = tonumber(puzzle_idx_serialized)
		switch_puzzle(puzzle_id)
	end

	alex_c_api.set_status_msg("Come up with as many words as you can, using the provided letters. " ..
	                          "They should fit into the crossword. If you get stuck, press the " ..
	                          "\"hint\" button to reveal a letter.")
	alex_c_api.enable_evt("key")

	alex_c_api.add_game_option(GAME_OPTION_RESET_PUZZLE, { label = "Reset puzzle", type = alex_c_api.OPTION_TYPE_BTN })
end

function handle_game_option_evt(option_id)
	if option_id == GAME_OPTION_RESET_PUZZLE then
		show_buttons_popup.show_popup(POPUP_ID_RESET_PUZZLE_CONFIRM,
                              "Reset puzzle?",
                              "Are you sure you want to reset this puzzle?",
                              { "Cancel", "Reset Puzzle" })

	else
		error(string.format("Unhandled game option id = \"%s\"", option_id))
	end
end

local function get_hint_status_str(game_state)
	if #game_state.hint_letters == 0 then
		return "no hints"
	else
		return string.format("%d hints", #game_state.hint_letters)
	end
end

local function handle_submit()
	local word = draw.get_word(state.ui_state)
	local rc = core.word_input(state.game_state, word)
	if rc == core.RC_SUCCESS then
		local msg = string.format("Revealed word \"%s\" in puzzle.", string.lower(word))
		alex_c_api.set_status_msg(msg)
		if state.game_state.finished then
			local hint_status_str = get_hint_status_str(state.game_state)
			alex_c_api.set_status_msg(string.format("Congratulations! You win, with %s. Press the '>' button at the top right to switch to the next puzzle.", hint_status_str))
			draw.player_won(state.ui_state)
		end
	else
		local msg = string.format("Word \"%s\": %s", string.lower(word), core.rc_to_msg(rc))
		alex_c_api.set_status_err(msg)
	end
	draw.clear_input(state.ui_state)
	draw.draw_state(state.ui_state, state.game_state)
	update_saved_state()
end

function handle_key_evt(evt_id, key_code)
	if evt_id == "keydown" then
		if key_code == "Enter" then
			print("User pressed enter")
			handle_submit()
		elseif key_code == "Backspace" then
			draw.backspace(state.ui_state)
			draw.draw_state(state.ui_state, state.game_state)
		else
			local m = string.match(key_code, "Key(%a)")
			if m == nil then 
				print(string.format("Unrecognized key_code %s", key_code))
				return
			end
			local letter = m
			print(string.format("User pressed letter %q", letter))
			local rc = draw.input_letter(state.ui_state, state.game_state, letter)
			if rc ~= core.RC_SUCCESS then
				local msg = string.format("Letter \"%s\": %s", letter, core.rc_to_msg(rc))
				alex_c_api.set_status_err(msg)
			end
			draw.draw_state(state.ui_state, state.game_state)
		end
	end
end

function handle_btn_clicked(btn_id)
	print(string.format("handle_btn_clicked(id=%s)", btn_id))
	local action = draw.handle_btn_clicked(state.ui_state, btn_id)

	if action == draw.ACTION_SUBMIT then
		handle_submit()
	elseif action == draw.ACTION_HINT then
		core.hint(state.game_state)
	end
	draw.draw_state(state.ui_state, state.game_state)
	update_saved_state()
end

function handle_popup_btn_clicked(popup_id, btn_id)
	print(string.format("handle_popup_btn_clicked(popup_id=%s, btn_id=%s)", popup_id, btn_id))
	if popup_id == POPUP_ID_RESET_PUZZLE_CONFIRM then
		if btn_id == 0 then
			alex_c_api.hide_popup()
			-- do nothing
		elseif btn_id == 1 then
			alex_c_api.hide_popup()
			new_puzzle(state.game_state.puzzle_id)
		end
	end
end

function handle_user_clicked(pos_y, pos_x)
	local action = draw.handle_user_clicked(state.ui_state, state.game_state, pos_y, pos_x)
	if action == nil then
		-- do nothing
	elseif action == draw.ACTION_PREV_PUZZLE then
		local puzzle_id = state.game_state.puzzle_id
		puzzle_id = puzzle_id - 1
		if puzzle_id < 1 then puzzle_id = 1 end
		switch_puzzle(puzzle_id)
	elseif action == draw.ACTION_NEXT_PUZZLE then
		local puzzle_id = state.game_state.puzzle_id
		puzzle_id = puzzle_id + 1
		if puzzle_id > #puzzles.puzzles then puzzle_id = #puzzles.puzzles end
		switch_puzzle(puzzle_id)
	else
		error(string.format("Unhandled action ID %s", action))
	end
	draw.draw_state(state.ui_state, state.game_state)
	update_saved_state()
end
local puzzles = {}

local core = require("games/crossword_letters/crossword_letters_core")

puzzles.puzzles = {

--+------------+
--|other  shot |
--|t       o   |
--|h       rest|
--|e t   r s o |
--|r h shore r |
--|short s   t |
--|  s o e  s  |
--|  e r   toes|
--|   hers  r  |
--|hero  hose  |
--|   s  o     |
--|   t  e     |
--+------------+
--
{
	letters = {"r", "e", "s", "t", "o", "h"},
	word_positions = {
		{ word = "others"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "hero"              , pos = { y = 10, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "toes"              , pos = { y =  8, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y =  4, x =  7 }, orientation = core.VERTICAL    },
		{ word = "rest"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "shore"             , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "store"             , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "host"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "other"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "sort"              , pos = { y =  3, x = 11 }, orientation = core.VERTICAL    },
		{ word = "those"             , pos = { y =  4, x =  3 }, orientation = core.VERTICAL    },
		{ word = "shot"              , pos = { y =  1, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "shoe"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "sore"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "hose"              , pos = { y = 10, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "short"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "hers"              , pos = { y =  9, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "horse"             , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|moral   meal|
--|o e  r  a  a|
--|real oral  m|
--|a l  l  e  e|
--|l more m    |
--|e   o  are  |
--|    a  r r  |
--|    mole arm|
--|      o     |
--|      r     |
--|   aloe     |
--|            |
--+------------+
--
{
	letters = {"e", "m", "r", "o", "l", "a"},
	word_positions = {
		{ word = "mole"              , pos = { y =  8, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "lame"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "oral"              , pos = { y =  3, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "real"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "male"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "are"               , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "moral"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lore"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "more"              , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "era"               , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "realm"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "arm"               , pos = { y =  8, x = 10 }, orientation = core.HORIZONTAL  },
		{ word = "roam"              , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "meal"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "aloe"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "role"              , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "mare"              , pos = { y =  5, x =  8 }, orientation = core.VERTICAL    },
		{ word = "morale"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|f  h    heat|
--|after   a   |
--|t  a    r   |
--|h  r fare   |
--|earth  a f  |
--|r   a  frat |
--|    t  t t f|
--|   hear fear|
--|    r a e  e|
--|      tear t|
--|   hate t   |
--|            |
--+------------+
--
{
	letters = {"a", "h", "f", "t", "e", "r"},
	word_positions = {
		{ word = "after"             , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "hare"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fare"              , pos = { y =  4, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "father"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "raft"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "fret"              , pos = { y =  7, x = 12 }, orientation = core.VERTICAL    },
		{ word = "hate"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "feat"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
		{ word = "earth"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "fate"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "heat"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "tear"              , pos = { y = 10, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "heart"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "rate"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "hater"             , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "fear"              , pos = { y =  8, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "frat"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "hear"              , pos = { y =  8, x =  4 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|heard  herd |
--|e  e   a  a |
--|r hard d  r |
--|a  l e   her|
--|l    a   a  |
--|d  held  r  |
--|   e  e heal|
--| read are  e|
--|   d  r a  a|
--|        r  d|
--|            |
--|            |
--+------------+
--
{
	letters = {"r", "a", "h", "e", "d", "l"},
	word_positions = {
		{ word = "her"               , pos = { y =  4, x = 10 }, orientation = core.HORIZONTAL  },
		{ word = "dear"              , pos = { y =  6, x =  7 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y =  1, x = 11 }, orientation = core.VERTICAL    },
		{ word = "held"              , pos = { y =  6, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "real"              , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "herald"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "heard"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "are"               , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "head"              , pos = { y =  6, x =  4 }, orientation = core.VERTICAL    },
		{ word = "hard"              , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "had"               , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "hear"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "read"              , pos = { y =  8, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "herd"              , pos = { y =  1, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "lead"              , pos = { y =  7, x = 12 }, orientation = core.VERTICAL    },
		{ word = "hare"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "deal"              , pos = { y =  3, x =  6 }, orientation = core.VERTICAL    },
		{ word = "heal"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|merit  trim |
--|e   e  i    |
--|timer  rite |
--|r   mice  m |
--|i t   i   i |
--|crime t mite|
--|  m   e e   |
--|item    t   |
--| i  i       |
--| e  c       |
--| rice       |
--|            |
--+------------+
--
{
	letters = {"m", "r", "i", "e", "c", "t"},
	word_positions = {
		{ word = "crime"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "time"              , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "mite"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "term"              , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "metric"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "timer"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tire"              , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "mice"              , pos = { y =  4, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rice"              , pos = { y = 11, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "item"              , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "merit"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ice"               , pos = { y =  9, x =  5 }, orientation = core.VERTICAL    },
		{ word = "trim"              , pos = { y =  1, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "cite"              , pos = { y =  4, x =  7 }, orientation = core.VERTICAL    },
		{ word = "met"               , pos = { y =  6, x =  9 }, orientation = core.VERTICAL    },
		{ word = "emit"              , pos = { y =  3, x = 11 }, orientation = core.VERTICAL    },
		{ word = "tier"              , pos = { y =  8, x =  2 }, orientation = core.VERTICAL    },
		{ word = "rite"              , pos = { y =  3, x =  8 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|break  b b  |
--|a    brake  |
--|care a c a  |
--|k a  k k r  |
--|e cake      |
--|r e  rack   |
--|   b  c   b |
--|   a  r   e |
--|  brace r c |
--|   e r bark |
--|     a  k   |
--|     bake   |
--+------------+
--
{
	letters = {"b", "c", "a", "k", "e", "r"},
	word_positions = {
		{ word = "bear"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "acre"              , pos = { y =  6, x =  7 }, orientation = core.VERTICAL    },
		{ word = "cake"              , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "bake"              , pos = { y = 12, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "baker"             , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "brace"             , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "rack"              , pos = { y =  6, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "backer"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "brake"             , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "race"              , pos = { y =  3, x =  3 }, orientation = core.VERTICAL    },
		{ word = "rake"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "bare"              , pos = { y =  7, x =  4 }, orientation = core.VERTICAL    },
		{ word = "break"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "back"              , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "crab"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "bark"              , pos = { y = 10, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "beck"              , pos = { y =  7, x = 11 }, orientation = core.VERTICAL    },
		{ word = "care"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|votes       |
--|o     t  r  |
--|t  overs o  |
--|e s o o  s  |
--|r t t vote  |
--|store e o   |
--|  v r   r t |
--|over s veto |
--|v  e o    e |
--|e  sort vest|
--|r  t e      |
--|t           |
--+------------+
--
{
	letters = {"e", "v", "t", "o", "r", "s"},
	word_positions = {
		{ word = "overt"             , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "toes"              , pos = { y =  7, x = 11 }, orientation = core.VERTICAL    },
		{ word = "rose"              , pos = { y =  2, x = 10 }, orientation = core.VERTICAL    },
		{ word = "over"              , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rest"              , pos = { y =  8, x =  4 }, orientation = core.VERTICAL    },
		{ word = "vote"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "overs"             , pos = { y =  3, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "store"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "veto"              , pos = { y =  8, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "voters"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sort"              , pos = { y = 10, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "stove"             , pos = { y =  4, x =  3 }, orientation = core.VERTICAL    },
		{ word = "sore"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "tore"              , pos = { y =  5, x =  9 }, orientation = core.VERTICAL    },
		{ word = "voter"             , pos = { y =  3, x =  5 }, orientation = core.VERTICAL    },
		{ word = "vest"              , pos = { y = 10, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "votes"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "trove"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|cheap       |
--|h      heap |
--|a e pace    |
--|place  a    |
--|e c a clap p|
--|l h c    l a|
--|    help e l|
--|      e lace|
--|     cape   |
--|      c ache|
--|     chap   |
--|            |
--+------------+
--
{
	letters = {"h", "c", "p", "e", "l", "a"},
	word_positions = {
		{ word = "cape"              , pos = { y =  9, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "help"              , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "peach"             , pos = { y =  3, x =  5 }, orientation = core.VERTICAL    },
		{ word = "cheap"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "each"              , pos = { y =  3, x =  3 }, orientation = core.VERTICAL    },
		{ word = "chapel"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "pale"              , pos = { y =  5, x = 12 }, orientation = core.VERTICAL    },
		{ word = "clap"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "plea"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "leap"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
		{ word = "ache"              , pos = { y = 10, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "lace"              , pos = { y =  8, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "heal"              , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "leach"             , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "place"             , pos = { y =  4, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "pace"              , pos = { y =  3, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "chap"              , pos = { y = 11, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "heap"              , pos = { y =  2, x =  8 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|farmed  farm|
--|r    r  a   |
--|a armed deaf|
--|m    a  e  a|
--|e frame  f r|
--|d a     dare|
--|  made   m  |
--|  e e fared |
--|  d a e   a |
--|    read  m |
--|      r   e |
--|            |
--+------------+
--
{
	letters = {"d", "r", "e", "f", "m", "a"},
	word_positions = {
		{ word = "made"              , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "fare"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "famed"             , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "armed"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "fade"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "deaf"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "fared"             , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "dream"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "frame"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "dear"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "fame"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "read"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "dame"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "farmed"            , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "fear"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "framed"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "farm"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|steaks      |
--|t    k s    |
--|a   takes  a|
--|k  e t a   s|
--|e take tasks|
--|s  s s s t e|
--|   t     a t|
--|a    steak  |
--|sets k a e  |
--|k a  a t    |
--|s seat sake |
--|  k  e      |
--+------------+
--
{
	letters = {"t", "a", "s", "s", "e", "k"},
	word_positions = {
		{ word = "steak"             , pos = { y =  8, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "seat"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "skates"            , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "asset"             , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "stakes"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "asks"              , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "tasks"             , pos = { y =  5, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "steaks"            , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "task"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "sake"              , pos = { y = 11, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "skate"             , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "take"              , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "eats"              , pos = { y =  8, x =  8 }, orientation = core.VERTICAL    },
		{ word = "sets"              , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "east"              , pos = { y =  4, x =  4 }, orientation = core.VERTICAL    },
		{ word = "stake"             , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "seats"             , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "takes"             , pos = { y =  3, x =  5 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|p u     puts|
--|upset   u  p|
--|r e     r  u|
--|e  s  step r|
--|super u     |
--|t  t  rest  |
--|  purse  r  |
--|   p   r u  |
--|     p user |
--|    pets  u |
--|     s t  s |
--|     t    e |
--+------------+
--
{
	letters = {"s", "e", "t", "r", "u", "p"},
	word_positions = {
		{ word = "use"               , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "sure"              , pos = { y =  4, x =  7 }, orientation = core.VERTICAL    },
		{ word = "step"              , pos = { y =  4, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "rest"              , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "pest"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "purse"             , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "pure"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "spur"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "setup"             , pos = { y =  4, x =  4 }, orientation = core.VERTICAL    },
		{ word = "super"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "pets"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "upset"             , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "user"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "ruse"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "rust"              , pos = { y =  8, x =  8 }, orientation = core.VERTICAL    },
		{ word = "true"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "purest"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "puts"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|flare       |
--|l  e f      |
--|a fared     |
--|r  l r l  d |
--|e   dare  e |
--|deal l a  a |
--|   e   fear |
--| read    r  |
--|   d f fled |
--|     l a  e |
--|     e r  a |
--|    fade  f |
--+------------+
--
{
	letters = {"r", "l", "a", "d", "f", "e"},
	word_positions = {
		{ word = "dear"              , pos = { y =  4, x = 11 }, orientation = core.VERTICAL    },
		{ word = "fare"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "real"              , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "feral"             , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "flare"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "fade"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "deaf"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "fared"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "flared"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "flea"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "are"               , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "read"              , pos = { y =  8, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "deal"              , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lead"              , pos = { y =  6, x =  4 }, orientation = core.VERTICAL    },
		{ word = "fear"              , pos = { y =  7, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "fled"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "leaf"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|finder      |
--|r  i        |
--|i infer  f  |
--|e  e  i  i  |
--|n fried  r  |
--|d i   e fern|
--|  r     i   |
--|fiend finer |
--|i d i i e e |
--|n   r n   i |
--|e  nerd dine|
--|d           |
--+------------+
--
{
	letters = {"d", "i", "f", "e", "n", "r"},
	word_positions = {
		{ word = "dire"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "friend"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "finer"             , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "fined"             , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "fiend"             , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ride"              , pos = { y =  3, x =  7 }, orientation = core.VERTICAL    },
		{ word = "rein"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "find"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "diner"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "infer"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "fired"             , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "finder"            , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "fine"              , pos = { y =  6, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fried"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "dine"              , pos = { y = 11, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "nerd"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "fern"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "fire"              , pos = { y =  3, x = 10 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|laden       |
--|o          l|
--|alone   lane|
--|n       o  a|
--|e  d  loan n|
--|done  e d   |
--| n a  a   a |
--| e land lone|
--|     o  e d |
--|     dean   |
--|  aloe  d   |
--|            |
--+------------+
--
{
	letters = {"o", "l", "n", "e", "d", "a"},
	word_positions = {
		{ word = "done"              , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "alone"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "dean"              , pos = { y = 10, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "lone"              , pos = { y =  8, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "node"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "aloe"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "loan"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "load"              , pos = { y =  3, x =  9 }, orientation = core.VERTICAL    },
		{ word = "one"               , pos = { y =  6, x =  2 }, orientation = core.VERTICAL    },
		{ word = "land"              , pos = { y =  8, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "laden"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lend"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
		{ word = "loaned"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "deal"              , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "lead"              , pos = { y =  5, x =  7 }, orientation = core.VERTICAL    },
		{ word = "lean"              , pos = { y =  2, x = 12 }, orientation = core.VERTICAL    },
		{ word = "lane"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "and"               , pos = { y =  7, x = 11 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|birds b    b|
--|r a airs   i|
--|a i i a arid|
--|i d d i  a s|
--|d s   drab  |
--|s   b    i  |
--|    a bird  |
--| bard a a   |
--| r i  r i   |
--| a bias d   |
--| d s        |
--|            |
--+------------+
--
{
	letters = {"s", "b", "r", "d", "i", "a"},
	word_positions = {
		{ word = "drab"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "raid"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "bars"              , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "ribs"              , pos = { y =  8, x =  4 }, orientation = core.VERTICAL    },
		{ word = "raids"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "bids"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "airs"              , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "birds"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "braid"             , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "bird"              , pos = { y =  7, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "bias"              , pos = { y = 10, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "brad"              , pos = { y =  8, x =  2 }, orientation = core.VERTICAL    },
		{ word = "bard"              , pos = { y =  8, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "arid"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "said"              , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "bad"               , pos = { y =  6, x =  5 }, orientation = core.VERTICAL    },
		{ word = "braids"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "rabid"             , pos = { y =  3, x = 10 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|c curse     |
--|o    c      |
--|u euros     |
--|r    r  c   |
--|source  u  c|
--|e   o   e  u|
--|  cures sour|
--|    e    u e|
--| rouse sore |
--| o   u u s  |
--|user r r    |
--| e  core    |
--+------------+
--
{
	letters = {"u", "e", "r", "c", "o", "s"},
	word_positions = {
		{ word = "cores"             , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "curse"             , pos = { y =  1, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "cures"             , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "score"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "course"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "source"            , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "cues"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "ours"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "euros"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "cure"              , pos = { y =  5, x = 12 }, orientation = core.VERTICAL    },
		{ word = "sour"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "sore"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "user"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rouse"             , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "euro"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "core"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y =  9, x =  2 }, orientation = core.VERTICAL    },
		{ word = "sure"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|cheat       |
--|h    e      |
--|a  leach    |
--|l  a c a l  |
--|e  t h t a  |
--|teach heat l|
--|   h  e  e a|
--|      a    c|
--|    halt the|
--|     c e e  |
--|     h chat |
--|  tale h l  |
--+------------+
--
{
	letters = {"c", "l", "h", "e", "t", "a"},
	word_positions = {
		{ word = "the"               , pos = { y =  9, x = 10 }, orientation = core.HORIZONTAL  },
		{ word = "teach"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "latch"             , pos = { y =  3, x =  4 }, orientation = core.VERTICAL    },
		{ word = "teal"              , pos = { y =  9, x = 10 }, orientation = core.VERTICAL    },
		{ word = "heat"              , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "tale"              , pos = { y = 12, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "each"              , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "tech"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "ache"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "hate"              , pos = { y =  3, x =  8 }, orientation = core.VERTICAL    },
		{ word = "chat"              , pos = { y = 11, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "lace"              , pos = { y =  6, x = 12 }, orientation = core.VERTICAL    },
		{ word = "chalet"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "leach"             , pos = { y =  3, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "cheat"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "late"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "halt"              , pos = { y =  9, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "heal"              , pos = { y =  6, x =  7 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|scale       |
--|c  e        |
--|a  a l   d c|
--|l  deals e a|
--|e  s c laces|
--|d c  e a a e|
--|  lead d l  |
--|  a    e    |
--|  deal  l s |
--|     a  aces|
--|  sled  c a |
--|     sale l |
--+------------+
--
{
	letters = {"c", "l", "e", "a", "d", "s"},
	word_positions = {
		{ word = "sled"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "laces"             , pos = { y =  5, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "seal"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "scaled"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "lads"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "sale"              , pos = { y = 12, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "case"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "aces"              , pos = { y = 10, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "scale"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "slade"             , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "clad"              , pos = { y =  6, x =  3 }, orientation = core.VERTICAL    },
		{ word = "lace"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "deals"             , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "deal"              , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "lead"              , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "laced"             , pos = { y =  3, x =  6 }, orientation = core.VERTICAL    },
		{ word = "leads"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "decal"             , pos = { y =  3, x = 10 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|c     t acre|
--|u truce  a  |
--|r  e  acute |
--|a  a  r  e  |
--|trace  care |
--|e  t   r    |
--|    c  a c  |
--| c  u  true |
--| a  race t  |
--| rate u  e  |
--| t   are    |
--|      t     |
--+------------+
--
{
	letters = {"r", "a", "c", "e", "t", "u"},
	word_positions = {
		{ word = "cute"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "acre"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "truce"             , pos = { y =  2, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "care"              , pos = { y =  5, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "react"             , pos = { y =  2, x =  4 }, orientation = core.VERTICAL    },
		{ word = "acute"             , pos = { y =  3, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "crate"             , pos = { y =  5, x =  8 }, orientation = core.VERTICAL    },
		{ word = "cater"             , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "curate"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "curt"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "tear"              , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "cart"              , pos = { y =  8, x =  2 }, orientation = core.VERTICAL    },
		{ word = "trace"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rate"              , pos = { y = 10, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "are"               , pos = { y = 11, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "race"              , pos = { y =  9, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "cure"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "true"              , pos = { y =  8, x =  8 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|score     c |
--|c r  rose o |
--|o code o  r |
--|r s  d rode |
--|e  c o e o  |
--|decor    s  |
--|   d    red |
--|cores   o   |
--|o  s cord   |
--|r       s   |
--|does        |
--|s           |
--+------------+
--
{
	letters = {"r", "o", "d", "s", "c", "e"},
	word_positions = {
		{ word = "redo"              , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "cores"             , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "cords"             , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "rose"              , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "core"              , pos = { y =  1, x = 11 }, orientation = core.VERTICAL    },
		{ word = "score"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rode"              , pos = { y =  4, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "dose"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "decor"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "does"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "sore"              , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "cord"              , pos = { y =  9, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "codes"             , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "red"               , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "scored"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "rods"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "orcs"              , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "code"              , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|horse       |
--|o  h  hero  |
--|r horde     |
--|d  r  r  d  |
--|e  e  d  o  |
--|s     shred |
--|       e s  |
--|       r  h |
--|rose s shoe |
--|o o  h  o r |
--|d rode  s d |
--|s e  dose   |
--+------------+
--
{
	letters = {"o", "s", "e", "d", "h", "r"},
	word_positions = {
		{ word = "hers"              , pos = { y =  6, x =  8 }, orientation = core.VERTICAL    },
		{ word = "hero"              , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "horde"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "shore"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "herds"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "rode"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "dose"              , pos = { y = 12, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "hordes"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "shred"             , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "does"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "shoe"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "sore"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "herd"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "hose"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "rods"              , pos = { y =  9, x =  1 }, orientation = core.VERTICAL    },
		{ word = "shed"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "horse"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|s  c score  |
--|escort  e c |
--|c  r o  sort|
--|t  sore t e |
--|o  e e    s |
--|r  t   cost |
--|    o  o    |
--|    r  rose |
--|  t core c  |
--| toes  s o  |
--|  r      t  |
--| sect       |
--+------------+
--
{
	letters = {"o", "s", "r", "e", "t", "c"},
	word_positions = {
		{ word = "cores"             , pos = { y =  6, x =  8 }, orientation = core.VERTICAL    },
		{ word = "toes"              , pos = { y = 10, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y =  8, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "rest"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "orcs"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "store"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "escort"            , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "sort"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "sect"              , pos = { y = 12, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "corset"            , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "sore"              , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "tore"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "core"              , pos = { y =  9, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "sector"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "scot"              , pos = { y =  8, x = 10 }, orientation = core.VERTICAL    },
		{ word = "score"             , pos = { y =  1, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "cost"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "crest"             , pos = { y =  2, x = 11 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|angel   d  l|
--|n l angle  e|
--|g and l a  a|
--|l n e a land|
--|end n d  g  |
--|d       lend|
--|         d e|
--|           a|
--|        lean|
--|        a g |
--|        n e |
--|       led  |
--+------------+
--
{
	letters = {"g", "l", "e", "d", "a", "n"},
	word_positions = {
		{ word = "dean"              , pos = { y =  6, x = 12 }, orientation = core.VERTICAL    },
		{ word = "led"               , pos = { y = 12, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "lend"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "aged"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "gland"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "angel"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "angled"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "land"              , pos = { y =  4, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "age"               , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "end"               , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "angle"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "lead"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "and"               , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "deal"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "laden"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "lean"              , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "lane"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "glad"              , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|feast       |
--|i  i fast   |
--|e  t a  i   |
--|s feats e  s|
--|t    e  safe|
--|a  east    a|
--| f a    feat|
--|fist    a   |
--| a s  fits  |
--| t    a e   |
--|      t     |
--|   teas     |
--+------------+
--
{
	letters = {"f", "e", "s", "t", "a", "i"},
	word_positions = {
		{ word = "fist"              , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "site"              , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "seat"              , pos = { y =  4, x = 12 }, orientation = core.VERTICAL    },
		{ word = "feast"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "safe"              , pos = { y =  5, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "feats"             , pos = { y =  4, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "fast"              , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "teas"              , pos = { y = 12, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "ties"              , pos = { y =  2, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fate"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fates"             , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "fats"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "eats"              , pos = { y =  6, x =  4 }, orientation = core.VERTICAL    },
		{ word = "fiesta"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "east"              , pos = { y =  6, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "fiat"              , pos = { y =  7, x =  2 }, orientation = core.VERTICAL    },
		{ word = "fits"              , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "feat"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|m    mail   |
--|a  e i  a c |
--|l  male meal|
--|i  a e  e m |
--|claim     e |
--|e  l    calm|
--|        a  i|
--| lice lime c|
--|   l  a e  e|
--|   a  c     |
--|   mace     |
--|            |
--+------------+
--
{
	letters = {"l", "c", "a", "m", "e", "i"},
	word_positions = {
		{ word = "mile"              , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "lame"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "camel"             , pos = { y =  2, x = 11 }, orientation = core.VERTICAL    },
		{ word = "email"             , pos = { y =  2, x =  4 }, orientation = core.VERTICAL    },
		{ word = "lime"              , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "male"              , pos = { y =  3, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "clam"              , pos = { y =  8, x =  4 }, orientation = core.VERTICAL    },
		{ word = "claim"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "mice"              , pos = { y =  6, x = 12 }, orientation = core.VERTICAL    },
		{ word = "lice"              , pos = { y =  8, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "came"              , pos = { y =  6, x =  9 }, orientation = core.VERTICAL    },
		{ word = "mace"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "ice"               , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "mail"              , pos = { y =  1, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "lace"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "calm"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "malice"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "meal"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|tries     s |
--|i       rite|
--|gets      i |
--|e      tier |
--|rites  i    |
--|s i    rigs |
--|  g rise r  |
--|  e e i  i  |
--|tires t  t  |
--|i   tiers   |
--|e           |
--|sire        |
--+------------+
--
{
	letters = {"i", "s", "t", "e", "g", "r"},
	word_positions = {
		{ word = "ties"              , pos = { y =  9, x =  1 }, orientation = core.VERTICAL    },
		{ word = "stir"              , pos = { y =  1, x = 11 }, orientation = core.VERTICAL    },
		{ word = "rest"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "rigs"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "sire"              , pos = { y = 12, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "gets"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "grit"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "site"              , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "tier"              , pos = { y =  4, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "tire"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "rise"              , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tiger"             , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "rites"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tries"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tiers"             , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tigers"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "tires"             , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rite"              , pos = { y =  2, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|break       |
--|a       b b |
--|near  brake |
--|k  a  a r a |
--|earn  k e n |
--|r  kane  b b|
--|      rake a|
--|         a r|
--|      b bran|
--|     bake   |
--|      n a   |
--|   bark k   |
--+------------+
--
{
	letters = {"r", "a", "e", "k", "n", "b"},
	word_positions = {
		{ word = "barn"              , pos = { y =  6, x = 12 }, orientation = core.VERTICAL    },
		{ word = "bear"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "bake"              , pos = { y = 10, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "baker"             , pos = { y =  3, x =  7 }, orientation = core.VERTICAL    },
		{ word = "beak"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "rank"              , pos = { y =  3, x =  4 }, orientation = core.VERTICAL    },
		{ word = "bran"              , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "near"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "banker"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "break"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "bean"              , pos = { y =  2, x = 11 }, orientation = core.VERTICAL    },
		{ word = "bare"              , pos = { y =  2, x =  9 }, orientation = core.VERTICAL    },
		{ word = "earn"              , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "brake"             , pos = { y =  3, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "rake"              , pos = { y =  7, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "bark"              , pos = { y = 12, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "bank"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "kane"              , pos = { y =  6, x =  4 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|b        b  |
--|a r      e  |
--|near r   t  |
--|t t  e bear |
--|e earn e  a |
--|r  n tear n |
--|   t   t  t |
--|  bean   b  |
--|  r  e barn |
--|  a bare a  |
--|  t  t n n  |
--|       t    |
--+------------+
--
{
	letters = {"b", "n", "r", "e", "a", "t"},
	word_positions = {
		{ word = "rant"              , pos = { y =  4, x = 11 }, orientation = core.VERTICAL    },
		{ word = "bear"              , pos = { y =  4, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "beta"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "earn"              , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "neat"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "bran"              , pos = { y =  8, x = 10 }, orientation = core.VERTICAL    },
		{ word = "tear"              , pos = { y =  6, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "brat"              , pos = { y =  8, x =  3 }, orientation = core.VERTICAL    },
		{ word = "banter"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "rent"              , pos = { y =  3, x =  6 }, orientation = core.VERTICAL    },
		{ word = "near"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "bare"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "beat"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "rate"              , pos = { y =  2, x =  3 }, orientation = core.VERTICAL    },
		{ word = "bean"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "ante"              , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "bent"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "barn"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|d        b  |
--|e b      r  |
--|brides  bird|
--|r r      e i|
--|i dries    e|
--|s s   i ribs|
--|   bride  i |
--|    i e   d |
--|  ride beds |
--|  i e  r i  |
--|  s sire r  |
--|  e    d e  |
--+------------+
--
{
	letters = {"r", "b", "i", "e", "s", "d"},
	word_positions = {
		{ word = "beds"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "brie"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "ribs"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "bride"             , pos = { y =  7, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "rides"             , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "ride"              , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "side"              , pos = { y =  5, x =  7 }, orientation = core.VERTICAL    },
		{ word = "sire"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "dies"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "bird"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "brides"            , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "debris"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "bids"              , pos = { y =  6, x = 11 }, orientation = core.VERTICAL    },
		{ word = "birds"             , pos = { y =  2, x =  3 }, orientation = core.VERTICAL    },
		{ word = "bred"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "dries"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "rise"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "dire"              , pos = { y =  9, x = 10 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|s           |
--|a t         |
--|turns      a|
--|u a   t r  r|
--|rants u u  t|
--|n s t r nuts|
--|    aunts s |
--|    r  u  a |
--|rats aunt r |
--|a  t n a    |
--|n rust      |
--|t  n s      |
--+------------+
--
{
	letters = {"r", "t", "n", "s", "u", "a"},
	word_positions = {
		{ word = "rant"              , pos = { y =  9, x =  1 }, orientation = core.VERTICAL    },
		{ word = "arts"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "ants"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "saturn"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "turns"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "runs"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "trans"             , pos = { y =  2, x =  3 }, orientation = core.VERTICAL    },
		{ word = "aunt"              , pos = { y =  9, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "rants"             , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rats"              , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tsar"              , pos = { y =  6, x = 11 }, orientation = core.VERTICAL    },
		{ word = "turn"              , pos = { y =  4, x =  7 }, orientation = core.VERTICAL    },
		{ word = "aunts"             , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tuna"              , pos = { y =  7, x =  8 }, orientation = core.VERTICAL    },
		{ word = "rust"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "stun"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "nuts"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "star"              , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|units       |
--|n   unite   |
--|i   i  u  u |
--|t  stein  n |
--|e   e  e  i |
--|site   sent |
--|  i      u  |
--|  e      t  |
--|  suit nest |
--|     e e  u |
--|  stun t  n |
--|     s sine |
--+------------+
--
{
	letters = {"t", "e", "u", "i", "n", "s"},
	word_positions = {
		{ word = "ties"              , pos = { y =  6, x =  3 }, orientation = core.VERTICAL    },
		{ word = "site"              , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "units"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "unit"              , pos = { y =  3, x = 11 }, orientation = core.VERTICAL    },
		{ word = "nets"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "nest"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "sine"              , pos = { y = 12, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "unite"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tens"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "stein"             , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "tune"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "sent"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "suit"              , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "stun"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "tunes"             , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "suite"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "nuts"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "unites"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|slide s dies|
--|l    rise   |
--|i  d  d lies|
--|d  ride i  l|
--|e  i       i|
--|rides   lied|
--| s s     d  |
--| l       l  |
--| e l  sire  |
--|   i  l     |
--|   dire     |
--|   s  d     |
--+------------+
--
{
	letters = {"r", "d", "e", "i", "s", "l"},
	word_positions = {
		{ word = "lids"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "idle"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "sled"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "slid"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "lies"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "rise"              , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "rides"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ride"              , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "side"              , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "deli"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "dies"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "slider"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "isle"              , pos = { y =  6, x =  2 }, orientation = core.VERTICAL    },
		{ word = "slide"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "sire"              , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "lied"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "dries"             , pos = { y =  3, x =  4 }, orientation = core.VERTICAL    },
		{ word = "dire"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|p s o s     |
--|o p pines o |
--|noise i   p |
--|i n n poise |
--|e e s e o n |
--|s    n  n   |
--|  p  ones   |
--|  i  s   p  |
--|  nope pies |
--|  e o  i n  |
--|    spin s  |
--|    e  s    |
--+------------+
--
{
	letters = {"p", "i", "s", "o", "e", "n"},
	word_positions = {
		{ word = "poise"             , pos = { y =  4, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "ones"              , pos = { y =  7, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "open"              , pos = { y =  2, x = 11 }, orientation = core.VERTICAL    },
		{ word = "pose"              , pos = { y =  9, x =  5 }, orientation = core.VERTICAL    },
		{ word = "pies"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "noise"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "pine"              , pos = { y =  7, x =  3 }, orientation = core.VERTICAL    },
		{ word = "ponies"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "pens"              , pos = { y =  8, x = 10 }, orientation = core.VERTICAL    },
		{ word = "pines"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "nope"              , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "spin"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "nose"              , pos = { y =  6, x =  6 }, orientation = core.VERTICAL    },
		{ word = "snipe"             , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "spine"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "ions"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "pins"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "opens"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|h s  a  s  h|
--|a a  seals e|
--|sale h  a  a|
--|s e  e  seal|
--|lashes  h   |
--|e  e        |
--| leash  l   |
--| e l   sash |
--| s seas s   |
--| s    has   |
--|      e     |
--|    lash    |
--+------------+
--
{
	letters = {"l", "e", "h", "a", "s", "s"},
	word_positions = {
		{ word = "slash"             , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "lash"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "less"              , pos = { y =  7, x =  2 }, orientation = core.VERTICAL    },
		{ word = "seal"              , pos = { y =  4, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "seals"             , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "sash"              , pos = { y =  8, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "sale"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ashes"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "has"               , pos = { y = 10, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "lashes"            , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "leash"             , pos = { y =  7, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "hassle"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sales"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "seas"              , pos = { y =  9, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "lass"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "shes"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "heals"             , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "heal"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|wears  h    |
--|a   wares  h|
--|share  a   e|
--|h   a  r w a|
--|e wars shear|
--|r a      a  |
--|  s    ears |
--|  hers      |
--|    a was   |
--| eras  r    |
--|    hare    |
--|            |
--+------------+
--
{
	letters = {"a", "s", "e", "r", "h", "w"},
	word_positions = {
		{ word = "hers"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "hare"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "shear"             , pos = { y =  5, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "was"               , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "ears"              , pos = { y =  7, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "are"               , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "rash"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "wear"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "swear"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "eras"              , pos = { y = 10, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "washer"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "wash"              , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "wares"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "wars"              , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "wears"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "hears"             , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "share"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "hear"              , pos = { y =  2, x = 12 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|grave   gear|
--|r       a  a|
--|a rages v  g|
--|v   e ages e|
--|e   a v     |
--|saver ears  |
--|  a s    are|
--|  s    r g  |
--|age   rave  |
--|       g    |
--|    eras    |
--|            |
--+------------+
--
{
	letters = {"r", "a", "e", "g", "v", "s"},
	word_positions = {
		{ word = "ears"              , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "grave"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "are"               , pos = { y =  7, x = 10 }, orientation = core.HORIZONTAL  },
		{ word = "rave"              , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "sage"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "save"              , pos = { y =  3, x =  7 }, orientation = core.VERTICAL    },
		{ word = "age"               , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rage"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "rages"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "ages"              , pos = { y =  4, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "gears"             , pos = { y =  3, x =  5 }, orientation = core.VERTICAL    },
		{ word = "eras"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "graves"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "saver"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rags"              , pos = { y =  8, x =  8 }, orientation = core.VERTICAL    },
		{ word = "vase"              , pos = { y =  6, x =  3 }, orientation = core.VERTICAL    },
		{ word = "gear"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "gave"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|ratio s     |
--|a r arts    |
--|t i t i s  o|
--|i o s riot a|
--|o  r    a  r|
--|stair   rats|
--|   o  i  i  |
--| s t  tsar  |
--|roast s  s  |
--| r          |
--|star        |
--|            |
--+------------+
--
{
	letters = {"i", "t", "s", "o", "r", "a"},
	word_positions = {
		{ word = "oats"              , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "ratio"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "stir"              , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "arts"              , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rats"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "riot"              , pos = { y =  4, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "airs"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "stair"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "oars"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "ratios"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "soar"              , pos = { y =  3, x =  9 }, orientation = core.VERTICAL    },
		{ word = "tsar"              , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "roast"             , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "its"               , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "trio"              , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "riots"             , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "sort"              , pos = { y =  8, x =  2 }, orientation = core.VERTICAL    },
		{ word = "star"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|s rings     |
--|i e    r  r |
--|n i risen i |
--|g g e  s  s |
--|e n i rinse |
--|resign n i  |
--|    n   grin|
--| s       e  |
--| i r  reins |
--| rein i   i |
--| e g  n   g |
--|   sing   n |
--+------------+
--
{
	letters = {"s", "n", "r", "e", "g", "i"},
	word_positions = {
		{ word = "risen"             , pos = { y =  3, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "siren"             , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "rinse"             , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "rigs"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "reigns"            , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "grin"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "rein"              , pos = { y = 10, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "reign"             , pos = { y =  3, x =  5 }, orientation = core.VERTICAL    },
		{ word = "reins"             , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "singer"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sire"              , pos = { y =  8, x =  2 }, orientation = core.VERTICAL    },
		{ word = "resign"            , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "resin"             , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "rings"             , pos = { y =  1, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "sign"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "rise"              , pos = { y =  2, x = 11 }, orientation = core.VERTICAL    },
		{ word = "sing"              , pos = { y = 12, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "ring"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|d    gain   |
--|a  g r      |
--|r drain     |
--|i  a n r    |
--|n  i drag   |
--|grand  i    |
--| i   rang   |
--| n    r r   |
--| grid i air |
--|  a i d d   |
--|  i n       |
--|and grin    |
--+------------+
--
{
	letters = {"i", "a", "g", "n", "d", "r"},
	word_positions = {
		{ word = "grind"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "raid"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "drag"              , pos = { y =  5, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "ding"              , pos = { y =  9, x =  5 }, orientation = core.VERTICAL    },
		{ word = "grin"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rang"              , pos = { y =  7, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "grand"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "drain"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "grain"             , pos = { y =  2, x =  4 }, orientation = core.VERTICAL    },
		{ word = "daring"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "gain"              , pos = { y =  1, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "air"               , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "rain"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "arid"              , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "and"               , pos = { y = 12, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "grid"              , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "grad"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "ring"              , pos = { y =  6, x =  2 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|grant  s    |
--|r n rants   |
--|a g a  a    |
--|n s n arts  |
--|t t s    a  |
--|s        n  |
--|       tags |
--|r       n n |
--|a  r  r tsar|
--|n  a rats g |
--|tang  n     |
--|   stag     |
--+------------+
--
{
	letters = {"g", "r", "a", "t", "n", "s"},
	word_positions = {
		{ word = "rant"              , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "arts"              , pos = { y =  4, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "ants"              , pos = { y =  7, x =  9 }, orientation = core.VERTICAL    },
		{ word = "rats"              , pos = { y = 10, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "grant"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "trans"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "sang"              , pos = { y =  4, x = 10 }, orientation = core.VERTICAL    },
		{ word = "rang"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "rants"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tang"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tsar"              , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "stag"              , pos = { y = 12, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "tags"              , pos = { y =  7, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "angst"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "rags"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "snag"              , pos = { y =  7, x = 11 }, orientation = core.VERTICAL    },
		{ word = "grants"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "star"              , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|s        p  |
--|press pesos |
--|o     o  s  |
--|roses r  s r|
--|e o   e repo|
--|s ropes    p|
--|  e     pose|
--|poses     o |
--|r   p   pore|
--|o  rose r e |
--|s   r   o   |
--|e   e   s   |
--+------------+
--
{
	letters = {"e", "r", "s", "p", "o", "s"},
	word_positions = {
		{ word = "spore"             , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "pesos"             , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "ropes"             , pos = { y =  6, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y = 10, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "repo"              , pos = { y =  5, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "prose"             , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "spores"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sores"             , pos = { y =  4, x =  3 }, orientation = core.VERTICAL    },
		{ word = "pores"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "pros"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "press"             , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "sore"              , pos = { y =  7, x = 11 }, orientation = core.VERTICAL    },
		{ word = "pose"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "roses"             , pos = { y =  4, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "pore"              , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "poses"             , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "posse"             , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "rope"              , pos = { y =  4, x = 12 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|hire    h   |
--|e    timer  |
--|r  m i  i   |
--|m term trim |
--|i  r e h    |
--|their  emit |
--| e t   m  i |
--| r      i e |
--|      m tire|
--|     rite   |
--|      t m   |
--|    the     |
--+------------+
--
{
	letters = {"t", "m", "i", "e", "h", "r"},
	word_positions = {
		{ word = "time"              , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "them"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "mite"              , pos = { y =  9, x =  7 }, orientation = core.VERTICAL    },
		{ word = "term"              , pos = { y =  4, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "timer"             , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "their"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tire"              , pos = { y =  9, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "hermit"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "tier"              , pos = { y =  6, x = 11 }, orientation = core.VERTICAL    },
		{ word = "merit"             , pos = { y =  3, x =  4 }, orientation = core.VERTICAL    },
		{ word = "heir"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "her"               , pos = { y =  6, x =  2 }, orientation = core.VERTICAL    },
		{ word = "trim"              , pos = { y =  4, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "rite"              , pos = { y = 10, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "item"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
		{ word = "hire"              , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "the"               , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "emit"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|atoms       |
--|l  o a      |
--|m  salt    m|
--|o  t s     o|
--|s s lost o a|
--|t l a l malt|
--| lots a  t  |
--|  t t mats  |
--|       t  l |
--|    alto  o |
--|       mast |
--|            |
--+------------+
--
{
	letters = {"l", "m", "a", "o", "s", "t"},
	word_positions = {
		{ word = "oats"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "most"              , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "lost"              , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "salt"              , pos = { y =  3, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "atoms"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "malt"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "lots"              , pos = { y =  7, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "atom"              , pos = { y =  8, x =  8 }, orientation = core.VERTICAL    },
		{ word = "almost"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "mast"              , pos = { y = 11, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "last"              , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "alto"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "slot"              , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "lot"               , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "mats"              , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "slam"              , pos = { y =  5, x =  7 }, orientation = core.VERTICAL    },
		{ word = "also"              , pos = { y =  2, x =  6 }, orientation = core.VERTICAL    },
		{ word = "moat"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|modes    d  |
--|o e   dose s|
--|domes o  m t|
--|e o o e mode|
--|s s most   m|
--|t   e  o    |
--|       e    |
--|    dots    |
--|   m  o     |
--|   e  mods  |
--|   dome  e  |
--|   s     t  |
--+------------+
--
{
	letters = {"t", "d", "e", "o", "s", "m"},
	word_positions = {
		{ word = "most"              , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "demos"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "dots"              , pos = { y =  8, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "tome"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "some"              , pos = { y =  3, x =  5 }, orientation = core.VERTICAL    },
		{ word = "demo"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "meds"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "modest"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "does"              , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "dome"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "stem"              , pos = { y =  2, x = 12 }, orientation = core.VERTICAL    },
		{ word = "set"               , pos = { y = 10, x = 10 }, orientation = core.VERTICAL    },
		{ word = "toes"              , pos = { y =  5, x =  8 }, orientation = core.VERTICAL    },
		{ word = "mode"              , pos = { y =  4, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "mods"              , pos = { y = 10, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "domes"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "modes"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "dose"              , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|float       |
--|l  l  last  |
--|o  o   l   l|
--|a  flats   o|
--|t  t l o   f|
--|s    t  slot|
--|  f lost o  |
--|  l o    a  |
--| fast  soft |
--|  t sofa    |
--|       l    |
--|     fats   |
--+------------+
--
{
	letters = {"o", "l", "f", "t", "s", "a"},
	word_positions = {
		{ word = "flats"             , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "lost"              , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "salt"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "aloft"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "sofa"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "loaf"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "fast"              , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "loft"              , pos = { y =  3, x = 12 }, orientation = core.VERTICAL    },
		{ word = "last"              , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "float"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "alto"              , pos = { y =  4, x =  6 }, orientation = core.VERTICAL    },
		{ word = "flat"              , pos = { y =  7, x =  3 }, orientation = core.VERTICAL    },
		{ word = "fats"              , pos = { y = 12, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "floats"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "lots"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "soft"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "also"              , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "slot"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|heard    h  |
--|a r read e  |
--|r m e    a  |
--|m e a  hard |
--|e d made  e |
--|d      a  a |
--|    herd  r |
--|    a       |
--|    r  m  d |
--|    mare  a |
--|     r a  m |
--|  hare dare |
--+------------+
--
{
	letters = {"m", "r", "e", "d", "a", "h"},
	word_positions = {
		{ word = "dear"              , pos = { y =  4, x = 11 }, orientation = core.VERTICAL    },
		{ word = "harmed"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y = 12, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "armed"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "heard"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "mare"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "head"              , pos = { y =  4, x =  8 }, orientation = core.VERTICAL    },
		{ word = "dream"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "hard"              , pos = { y =  4, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "hare"              , pos = { y = 12, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "hear"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "made"              , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "read"              , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "dame"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
		{ word = "are"               , pos = { y = 10, x =  6 }, orientation = core.VERTICAL    },
		{ word = "harm"              , pos = { y =  7, x =  5 }, orientation = core.VERTICAL    },
		{ word = "herd"              , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "mead"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|based      b|
--|i    bead  i|
--|aside   idea|
--|s d     e  s|
--|e e a base  |
--|d abide     |
--|  s d a  s  |
--|    e d  i  |
--| beds said  |
--| i     i e  |
--| d   bad    |
--| s     e    |
--+------------+
--
{
	letters = {"d", "b", "a", "i", "e", "s"},
	word_positions = {
		{ word = "base"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "abide"             , pos = { y =  6, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "said"              , pos = { y =  9, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "beads"             , pos = { y =  5, x =  7 }, orientation = core.VERTICAL    },
		{ word = "based"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "side"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "dies"              , pos = { y =  2, x =  9 }, orientation = core.VERTICAL    },
		{ word = "ideas"             , pos = { y =  3, x =  3 }, orientation = core.VERTICAL    },
		{ word = "bias"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "aside"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "biased"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "aides"             , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "bad"               , pos = { y = 11, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "beds"              , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "bead"              , pos = { y =  2, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "aide"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "bids"              , pos = { y =  9, x =  2 }, orientation = core.VERTICAL    },
		{ word = "idea"              , pos = { y =  3, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|gears say   |
--|r  a   r e  |
--|easy   eras |
--|a  s     r  |
--|s r   rags  |
--|years   r   |
--|  g   gear  |
--| year r y   |
--|  s ages    |
--|    g y     |
--| sage       |
--|            |
--+------------+
--
{
	letters = {"r", "a", "s", "y", "e", "g"},
	word_positions = {
		{ word = "easy"              , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rays"              , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "ears"              , pos = { y =  2, x = 10 }, orientation = core.VERTICAL    },
		{ word = "are"               , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "years"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ages"              , pos = { y =  9, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "sage"              , pos = { y = 11, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "eras"              , pos = { y =  3, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "rages"             , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "gray"              , pos = { y =  5, x =  9 }, orientation = core.VERTICAL    },
		{ word = "year"              , pos = { y =  8, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "rage"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "greasy"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "grey"              , pos = { y =  7, x =  7 }, orientation = core.VERTICAL    },
		{ word = "gears"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rags"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "gear"              , pos = { y =  7, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "say"               , pos = { y =  1, x =  7 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|makes       |
--|a   marks   |
--|k   e       |
--|e  maker    |
--|r   r a     |
--|same  r     |
--|  a mask    |
--|sake r    r |
--|e e  mark a |
--|a    s a  k |
--|mesa   mare |
--|    eras    |
--+------------+
--
{
	letters = {"k", "a", "m", "s", "e", "r"},
	word_positions = {
		{ word = "smear"             , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "same"              , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ears"              , pos = { y =  4, x =  7 }, orientation = core.VERTICAL    },
		{ word = "makers"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "mare"              , pos = { y = 11, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "makes"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "make"              , pos = { y =  6, x =  3 }, orientation = core.VERTICAL    },
		{ word = "seam"              , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sake"              , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rake"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "eras"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "arms"              , pos = { y =  7, x =  6 }, orientation = core.VERTICAL    },
		{ word = "marks"             , pos = { y =  2, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rams"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "mark"              , pos = { y =  9, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "maker"             , pos = { y =  4, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "mesa"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "mask"              , pos = { y =  7, x =  5 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|prime    t t|
--|e  e  time i|
--|r  r  e  m e|
--|m timer  per|
--|i  t  m i m |
--|t       trip|
--|   r tire t |
--|  pier  m   |
--| m p i      |
--|rite m      |
--| t          |
--| e          |
--+------------+
--
{
	letters = {"t", "p", "m", "r", "e", "i"},
	word_positions = {
		{ word = "temp"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "mite"              , pos = { y =  9, x =  2 }, orientation = core.VERTICAL    },
		{ word = "trip"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "per"               , pos = { y =  4, x = 10 }, orientation = core.HORIZONTAL  },
		{ word = "pier"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "timer"             , pos = { y =  4, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "tire"              , pos = { y =  7, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "prime"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "tier"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "merit"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "item"              , pos = { y =  5, x =  9 }, orientation = core.VERTICAL    },
		{ word = "emit"              , pos = { y =  4, x = 11 }, orientation = core.VERTICAL    },
		{ word = "trim"              , pos = { y =  7, x =  6 }, orientation = core.VERTICAL    },
		{ word = "term"              , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "ripe"              , pos = { y =  7, x =  4 }, orientation = core.VERTICAL    },
		{ word = "rite"              , pos = { y = 10, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "time"              , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "permit"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|blame       |
--|l  e  m  d  |
--|a  d  able  |
--|m  a  d  a  |
--|e blade  l  |
--|d e  a l  b |
--|  a  mead e |
--|  male m  a |
--|    e  bald |
--|  meal   a  |
--|    d    m  |
--|      bale  |
--+------------+
--
{
	letters = {"l", "d", "m", "a", "e", "b"},
	word_positions = {
		{ word = "beam"              , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "made"              , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "blade"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "blame"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "bead"              , pos = { y =  6, x = 11 }, orientation = core.VERTICAL    },
		{ word = "male"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "blamed"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "meal"              , pos = { y = 10, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "deal"              , pos = { y =  2, x = 10 }, orientation = core.VERTICAL    },
		{ word = "lead"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "medal"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "bale"              , pos = { y = 12, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "bald"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "dame"              , pos = { y =  5, x =  6 }, orientation = core.VERTICAL    },
		{ word = "able"              , pos = { y =  3, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "lame"              , pos = { y =  9, x = 10 }, orientation = core.VERTICAL    },
		{ word = "lamb"              , pos = { y =  6, x =  8 }, orientation = core.VERTICAL    },
		{ word = "mead"              , pos = { y =  7, x =  6 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|place leap p|
--|a  l     l a|
--|r pearl  e c|
--|c  a e  race|
--|e  r care a |
--|l a  a  a p |
--|  clap  l e |
--|  r   l     |
--| reap a     |
--|    e c     |
--|   pale     |
--|    r       |
--+------------+
--
{
	letters = {"e", "r", "a", "c", "p", "l"},
	word_positions = {
		{ word = "acre"              , pos = { y =  6, x =  3 }, orientation = core.VERTICAL    },
		{ word = "cape"              , pos = { y =  4, x = 11 }, orientation = core.VERTICAL    },
		{ word = "care"              , pos = { y =  5, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "recap"             , pos = { y =  3, x =  6 }, orientation = core.VERTICAL    },
		{ word = "pale"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "clap"              , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "place"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "clear"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "parcel"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "pear"              , pos = { y =  9, x =  5 }, orientation = core.VERTICAL    },
		{ word = "lace"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "pearl"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "plea"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "real"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "race"              , pos = { y =  4, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "pace"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "leap"              , pos = { y =  1, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "reap"              , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|dance       |
--|a  a  care  |
--|n crane     |
--|c  e  d r  n|
--|e  d raced e|
--|r     r a  a|
--|   d    dear|
--|   acre  a  |
--|   r a card |
--|acne c a n  |
--|    dean    |
--|       e    |
--+------------+
--
{
	letters = {"n", "d", "c", "r", "a", "e"},
	word_positions = {
		{ word = "dancer"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "dear"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "dean"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "care"              , pos = { y =  2, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "crane"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "cared"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "cedar"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "race"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "near"              , pos = { y =  4, x = 12 }, orientation = core.VERTICAL    },
		{ word = "cane"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "acne"              , pos = { y = 10, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "card"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "read"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "earn"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "raced"             , pos = { y =  5, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "dare"              , pos = { y =  7, x =  4 }, orientation = core.VERTICAL    },
		{ word = "dance"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "acre"              , pos = { y =  8, x =  4 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|finder      |
--|r  i        |
--|i infer  f  |
--|e  e  i  i  |
--|n fried  r  |
--|d i   e fern|
--|  r     i   |
--|fiend finer |
--|i d i i e e |
--|n   r n   i |
--|e  nerd dine|
--|d           |
--+------------+
--
{
	letters = {"i", "n", "e", "d", "f", "r"},
	word_positions = {
		{ word = "dire"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "friend"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "finer"             , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "fined"             , pos = { y =  8, x =  1 }, orientation = core.VERTICAL    },
		{ word = "fiend"             , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ride"              , pos = { y =  3, x =  7 }, orientation = core.VERTICAL    },
		{ word = "rein"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "find"              , pos = { y =  8, x =  7 }, orientation = core.VERTICAL    },
		{ word = "diner"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "infer"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "fired"             , pos = { y =  5, x =  3 }, orientation = core.VERTICAL    },
		{ word = "finder"            , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "fine"              , pos = { y =  6, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fried"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "dine"              , pos = { y = 11, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "nerd"              , pos = { y = 11, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "fern"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "fire"              , pos = { y =  3, x = 10 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|learn   rain|
--|i l e l e  a|
--|n i a i a  i|
--|e e renal  l|
--|a n   e     |
--|r     rail  |
--|         i  |
--|       lane |
--|  liar e e  |
--|  a  e a    |
--|  i lien    |
--|earn n      |
--+------------+
--
{
	letters = {"a", "i", "e", "l", "r", "n"},
	word_positions = {
		{ word = "rail"              , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "earn"              , pos = { y = 12, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "liar"              , pos = { y =  9, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "real"              , pos = { y =  1, x =  9 }, orientation = core.VERTICAL    },
		{ word = "nail"              , pos = { y =  1, x = 12 }, orientation = core.VERTICAL    },
		{ word = "alien"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "liner"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "lair"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "rein"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "line"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "renal"             , pos = { y =  4, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rain"              , pos = { y =  1, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "lien"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "learn"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "near"              , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "lean"              , pos = { y =  8, x =  8 }, orientation = core.VERTICAL    },
		{ word = "lane"              , pos = { y =  8, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "linear"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|c curse     |
--|o    c      |
--|u euros     |
--|r    r  c   |
--|source  u  c|
--|e   o   e  u|
--|  cures sour|
--|    e    u e|
--| rouse sore |
--| o   u u s  |
--|user r r    |
--| e  core    |
--+------------+
--
{
	letters = {"o", "e", "r", "c", "s", "u"},
	word_positions = {
		{ word = "cores"             , pos = { y =  5, x =  5 }, orientation = core.VERTICAL    },
		{ word = "curse"             , pos = { y =  1, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "cures"             , pos = { y =  7, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "score"             , pos = { y =  1, x =  6 }, orientation = core.VERTICAL    },
		{ word = "course"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "source"            , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "cues"              , pos = { y =  4, x =  9 }, orientation = core.VERTICAL    },
		{ word = "ours"              , pos = { y =  7, x = 10 }, orientation = core.VERTICAL    },
		{ word = "euros"             , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "cure"              , pos = { y =  5, x = 12 }, orientation = core.VERTICAL    },
		{ word = "sour"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "sore"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "user"              , pos = { y = 11, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "rouse"             , pos = { y =  9, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "euro"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "core"              , pos = { y = 12, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rose"              , pos = { y =  9, x =  2 }, orientation = core.VERTICAL    },
		{ word = "sure"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|dealt land  |
--|e  a  a  a  |
--|n  delta t  |
--|tale  e deal|
--|a  n       e|
--|l        d a|
--|        tend|
--|         a  |
--|  l  l lane |
--|  e  e e    |
--|  n  neat   |
--|  dent n    |
--+------------+
--
{
	letters = {"l", "t", "n", "a", "d", "e"},
	word_positions = {
		{ word = "dealt"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "dean"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "dental"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "dent"              , pos = { y = 12, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "neat"              , pos = { y = 11, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "lend"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "lent"              , pos = { y =  9, x =  6 }, orientation = core.VERTICAL    },
		{ word = "tale"              , pos = { y =  4, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "land"              , pos = { y =  1, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "date"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "delta"             , pos = { y =  3, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "lead"              , pos = { y =  4, x = 12 }, orientation = core.VERTICAL    },
		{ word = "lean"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "deal"              , pos = { y =  4, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "laden"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "late"              , pos = { y =  1, x =  7 }, orientation = core.VERTICAL    },
		{ word = "lane"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "tend"              , pos = { y =  7, x =  9 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|r     dine  |
--|aired    a  |
--|i      nerd |
--|n r d  e n  |
--|e e idea  d |
--|drain  ride |
--|  d e     a |
--|    rain  r |
--|   r i  d   |
--|   a dare   |
--|  dire  a   |
--|   d    n   |
--+------------+
--
{
	letters = {"d", "r", "e", "n", "i", "a"},
	word_positions = {
		{ word = "dire"              , pos = { y = 11, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "dear"              , pos = { y =  5, x = 11 }, orientation = core.VERTICAL    },
		{ word = "dean"              , pos = { y =  9, x =  9 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y = 10, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "rained"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "ride"              , pos = { y =  6, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "idea"              , pos = { y =  5, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "rain"              , pos = { y =  8, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "nerd"              , pos = { y =  3, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "diner"             , pos = { y =  4, x =  5 }, orientation = core.VERTICAL    },
		{ word = "aired"             , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "raid"              , pos = { y =  9, x =  4 }, orientation = core.VERTICAL    },
		{ word = "read"              , pos = { y =  4, x =  3 }, orientation = core.VERTICAL    },
		{ word = "earn"              , pos = { y =  1, x = 10 }, orientation = core.VERTICAL    },
		{ word = "dine"              , pos = { y =  1, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "aide"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "near"              , pos = { y =  3, x =  8 }, orientation = core.VERTICAL    },
		{ word = "drain"             , pos = { y =  6, x =  1 }, orientation = core.HORIZONTAL  },
	},
},

--+------------+
--|blade  b    |
--|a      e    |
--|ideal bald  |
--|l  b   d i  |
--|e  idea  a  |
--|d  d  bail  |
--| lied l     |
--|  d  deal a |
--|bale e  e i |
--|  e  l laid |
--|     i  d e |
--|            |
--+------------+
--
{
	letters = {"i", "a", "e", "b", "l", "d"},
	word_positions = {
		{ word = "abide"             , pos = { y =  3, x =  4 }, orientation = core.VERTICAL    },
		{ word = "laid"              , pos = { y = 10, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "blade"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ideal"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "bead"              , pos = { y =  1, x =  8 }, orientation = core.VERTICAL    },
		{ word = "bald"              , pos = { y =  3, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "lied"              , pos = { y =  7, x =  2 }, orientation = core.HORIZONTAL  },
		{ word = "deli"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "idea"              , pos = { y =  5, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "dial"              , pos = { y =  3, x = 10 }, orientation = core.VERTICAL    },
		{ word = "bail"              , pos = { y =  6, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "bailed"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "lead"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
		{ word = "deal"              , pos = { y =  8, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "bale"              , pos = { y =  9, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "aide"              , pos = { y =  8, x = 11 }, orientation = core.VERTICAL    },
		{ word = "able"              , pos = { y =  5, x =  7 }, orientation = core.VERTICAL    },
		{ word = "idle"              , pos = { y =  7, x =  3 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|wander      |
--|a  r  r     |
--|r warden    |
--|n  w  a     |
--|earn  draw  |
--|d    w   e  |
--|     a near |
--|     d e r  |
--|  w dear  d |
--|  a r  dare |
--|  r e     a |
--|  dawn warn |
--+------------+
--
{
	letters = {"r", "e", "n", "a", "d", "w"},
	word_positions = {
		{ word = "draw"              , pos = { y =  5, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "dear"              , pos = { y =  9, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "wander"            , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "ward"              , pos = { y =  9, x =  3 }, orientation = core.VERTICAL    },
		{ word = "dare"              , pos = { y = 10, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "drew"              , pos = { y =  9, x =  5 }, orientation = core.VERTICAL    },
		{ word = "wear"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "warned"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "near"              , pos = { y =  7, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "wade"              , pos = { y =  6, x =  6 }, orientation = core.VERTICAL    },
		{ word = "earn"              , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "dawn"              , pos = { y = 12, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "read"              , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "warden"            , pos = { y =  3, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "warn"              , pos = { y = 12, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "nerd"              , pos = { y =  7, x =  8 }, orientation = core.VERTICAL    },
		{ word = "drawn"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "dean"              , pos = { y =  9, x = 11 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|s s       s |
--|often f ones|
--|f o o o n n |
--|t n tones t |
--|e e e t e   |
--|n   s s tone|
--|       t  o |
--|  tens o  t |
--|    e  nose |
--|    toes o  |
--|    s    f  |
--|      nest  |
--+------------+
--
{
	letters = {"s", "o", "f", "e", "n", "t"},
	word_positions = {
		{ word = "note"              , pos = { y =  6, x = 11 }, orientation = core.VERTICAL    },
		{ word = "ones"              , pos = { y =  2, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "tons"              , pos = { y =  7, x =  8 }, orientation = core.VERTICAL    },
		{ word = "toes"              , pos = { y = 10, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "often"             , pos = { y =  2, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "nets"              , pos = { y =  8, x =  5 }, orientation = core.VERTICAL    },
		{ word = "onset"             , pos = { y =  2, x =  9 }, orientation = core.VERTICAL    },
		{ word = "fonts"             , pos = { y =  2, x =  7 }, orientation = core.VERTICAL    },
		{ word = "tone"              , pos = { y =  6, x =  9 }, orientation = core.HORIZONTAL  },
		{ word = "soften"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "sent"              , pos = { y =  1, x = 11 }, orientation = core.VERTICAL    },
		{ word = "tens"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "nose"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "tones"             , pos = { y =  4, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "nest"              , pos = { y = 12, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "soft"              , pos = { y =  9, x = 10 }, orientation = core.VERTICAL    },
		{ word = "stone"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "notes"             , pos = { y =  2, x =  5 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|lines     l |
--|e o o  lose |
--|s i i  i  n |
--|i s lions s |
--|ones   e l  |
--|n  o  i  i  |
--| l lies  e  |
--|nose  lion  |
--| n    e i   |
--| e      l   |
--|     ions   |
--|            |
--+------------+
--
{
	letters = {"o", "i", "l", "e", "n", "s"},
	word_positions = {
		{ word = "ones"              , pos = { y =  5, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "soil"              , pos = { y =  1, x =  5 }, orientation = core.VERTICAL    },
		{ word = "noise"             , pos = { y =  1, x =  3 }, orientation = core.VERTICAL    },
		{ word = "lone"              , pos = { y =  7, x =  2 }, orientation = core.VERTICAL    },
		{ word = "lies"              , pos = { y =  7, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "lien"              , pos = { y =  5, x = 10 }, orientation = core.VERTICAL    },
		{ word = "lion"              , pos = { y =  8, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "line"              , pos = { y =  2, x =  8 }, orientation = core.VERTICAL    },
		{ word = "lions"             , pos = { y =  4, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "ions"              , pos = { y = 11, x =  6 }, orientation = core.HORIZONTAL  },
		{ word = "lose"              , pos = { y =  2, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "isle"              , pos = { y =  6, x =  7 }, orientation = core.VERTICAL    },
		{ word = "lesion"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "lines"             , pos = { y =  1, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "nose"              , pos = { y =  8, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lens"              , pos = { y =  1, x = 11 }, orientation = core.VERTICAL    },
		{ word = "sole"              , pos = { y =  5, x =  4 }, orientation = core.VERTICAL    },
		{ word = "oils"              , pos = { y =  8, x =  9 }, orientation = core.VERTICAL    },
	},
},

--+------------+
--|a  plain    |
--|l  a    p   |
--|plane plan  |
--|i  e  e i   |
--|n alien n   |
--|e     a  l  |
--|   p  line  |
--|  lien   a  |
--|   n a lane |
--|pale i e    |
--|    plea    |
--|       pile |
--+------------+
--
{
	letters = {"p", "e", "l", "n", "i", "a"},
	word_positions = {
		{ word = "pile"              , pos = { y = 12, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "plain"             , pos = { y =  1, x =  4 }, orientation = core.HORIZONTAL  },
		{ word = "alpine"            , pos = { y =  1, x =  1 }, orientation = core.VERTICAL    },
		{ word = "nail"              , pos = { y =  8, x =  6 }, orientation = core.VERTICAL    },
		{ word = "alien"             , pos = { y =  5, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "pale"              , pos = { y = 10, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lien"              , pos = { y =  8, x =  3 }, orientation = core.HORIZONTAL  },
		{ word = "pine"              , pos = { y =  7, x =  4 }, orientation = core.VERTICAL    },
		{ word = "plea"              , pos = { y = 11, x =  5 }, orientation = core.HORIZONTAL  },
		{ word = "leap"              , pos = { y =  9, x =  8 }, orientation = core.VERTICAL    },
		{ word = "line"              , pos = { y =  7, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "panel"             , pos = { y =  1, x =  4 }, orientation = core.VERTICAL    },
		{ word = "penal"             , pos = { y =  3, x =  7 }, orientation = core.VERTICAL    },
		{ word = "plan"              , pos = { y =  3, x =  7 }, orientation = core.HORIZONTAL  },
		{ word = "plane"             , pos = { y =  3, x =  1 }, orientation = core.HORIZONTAL  },
		{ word = "lean"              , pos = { y =  6, x = 10 }, orientation = core.VERTICAL    },
		{ word = "lane"              , pos = { y =  9, x =  8 }, orientation = core.HORIZONTAL  },
		{ word = "pain"              , pos = { y =  2, x =  9 }, orientation = core.VERTICAL    },
	},
},

}

return puzzles

local serialize = {}

local serialize_lib = require("libs/serialize/serialize")

local core    = require("games/crossword_letters/crossword_letters_core")

function serialize.serialize_state(state)
	if state == nil then return nil end
	local output = ""
	output = output .. serialize_lib.serialize_byte(#state.letters)
	for _, letter in ipairs(state.letters) do
		output = output .. serialize_lib.serialize_byte(string.byte(letter))
	end
	output = output .. serialize_lib.serialize_byte(#state.finished_crossword.grid)
	output = output .. serialize_lib.serialize_byte(#state.finished_crossword.grid[1])
	output = output .. serialize_lib.serialize_byte(state.finished_crossword.word_count)
	for word, word_info in pairs(state.finished_crossword.words) do
		output = output .. serialize_lib.serialize_byte(word_info.pos.y)
		output = output .. serialize_lib.serialize_byte(word_info.pos.x)
		output = output .. serialize_lib.serialize_byte(word_info.orientation)
		output = output .. serialize_lib.serialize_string(word)
	end

	output = output .. serialize_lib.serialize_string(state.hint_word)

	local found_word_count = 0
	for word, _ in pairs(state.found_words) do
		found_word_count = found_word_count + 1
	end

	output = output .. serialize_lib.serialize_16bit(found_word_count)
	for word, _ in pairs(state.found_words) do
		output = output .. serialize_lib.serialize_string(word)
	end

	output = output .. serialize_lib.serialize_16bit(#state.hint_letters)
	for _, pos in ipairs(state.hint_letters) do
		output = output .. serialize_lib.serialize_byte(pos.y)
		output = output .. serialize_lib.serialize_byte(pos.x)
	end

	output = output .. serialize_lib.serialize_16bit(state.puzzle_id)

	return output
end

function serialize.deserialize_state(bytes)
	if bytes == nil then return nil end
	bytes = serialize_lib.bytestr_to_byteary(bytes)

	if #bytes == 0 then return nil end

	local state = {}

	state.letters = {}
	local letter_count = serialize_lib.deserialize_byte(bytes)
	for _=1,letter_count do
		table.insert(state.letters, string.char(serialize_lib.deserialize_byte(bytes)))
	end

	local grid_y_size = serialize_lib.deserialize_byte(bytes)
	local grid_x_size = serialize_lib.deserialize_byte(bytes)
	local word_count  = serialize_lib.deserialize_byte(bytes)

	state.finished_crossword = core.generate_empty_crossword(grid_y_size, grid_x_size)
	for _=1,word_count do
		local word_info = {
			pos = {}
		}
		word_info.pos.y           = serialize_lib.deserialize_byte(bytes)
		word_info.pos.x           = serialize_lib.deserialize_byte(bytes)
		word_info.orientation     = serialize_lib.deserialize_byte(bytes)
		word_info.word            = serialize_lib.deserialize_string(bytes)

		core.add_word_to_crossword_modify(state.finished_crossword, word_info.pos, word_info.orientation, word_info.word)
	end

	state.hint_word = serialize_lib.deserialize_string(bytes)

	local found_word_count = serialize_lib.deserialize_16bit(bytes)
	state.found_words = {}
	for _=1,found_word_count do
		local found_word = serialize_lib.deserialize_string(bytes)
		state.found_words[found_word] = true
	end

	state.hint_letters = {}
	local hint_count = serialize_lib.deserialize_16bit(bytes)
	for _=1,hint_count do
		local hint = {
			y = serialize_lib.deserialize_byte(bytes),
			x = serialize_lib.deserialize_byte(bytes),
		}
		table.insert(state.hint_letters, hint)
	end

	-- TODO BEFORE PUBLISHING this should be a required field
	if #bytes > 0 then
		state.puzzle_id = serialize_lib.deserialize_16bit(bytes)
	end

	if #bytes ~= 0 then
		error(string.format("Found %d bytes remaining after deserialize, expected 0", #bytes))
	end
	
	return state
end

return serialize
#!/usr/bin/env python
#
# This script loops through every single combination of English letters
# (including at least one vowel), seeing what words you can make from them.
# Despite optimizing it with some good-enough hacks, it still takes forever to run.
# I think I got halfway through the 8 letter combinations (and a ~100 GB shelve
# file) before deciding that it would be better to only loop through combinations
# of letters that actually make up an English word (see gen_crossword_letters2.py).

import re
import string
import itertools
import collections
import sys

import shelve
import sqlite3

min_letters = 3
max_letters = 8
min_word_len   = 3

db_lookups     = 0
shelve_lookups = 0

def sql_regexp(pattern, item):
	reg = re.compile(pattern)
	return reg.search(item) is not None




def get_letter_counts_in_list(letter_list):
	counts = {}
	for letter in letter_list:
		if letter not in counts: counts[letter] = 0
		counts[letter] += 1
	return counts


WordCombinationInfo = collections.namedtuple('WordCombinationInfo', field_names = ['word_count', 'total_score'])
def get_words_containing_only_letters(cur, min_freq, letters, score_only, letter_combo_scores_shelve=None, only_word_len=None, recursive=True):
	global db_lookups
	global shelve_lookups

	letters_shelve_key = ''.join(sorted(letters))
	#print("trying letters key %r, only_word_len=%r" % (letters_shelve_key, only_word_len))

	if score_only:
		if letter_combo_scores_shelve is not None:
			try:
				cached_value = letter_combo_scores_shelve[letters_shelve_key]
				shelve_lookups += 1
				# print("found cached value %s" % repr(cached_value))
				word_count, total_score = cached_value
				return WordCombinationInfo(word_count, total_score)
			except KeyError:
				# print("could not find cached value for key %r" % letters_shelve_key)
				pass
	
		if recursive and not only_word_len:
			word_count  = 0
			total_score = 0
			for word_len in range(min_letters, len(letters)+1):
				#print("recursive, trying word_len %d" % word_len)
				for letters2 in itertools.combinations(letters, word_len):
					#print("trying letters2 %s" % repr(letters2))
					info = get_words_containing_only_letters(cur, min_freq, letters2, score_only=score_only,
					                                         letter_combo_scores_shelve=letter_combo_scores_shelve,
					                                         only_word_len=word_len,
					                                         recursive=recursive)
					#print("recvd info %s" % repr(info))
					word_count  += info.word_count
					if info.total_score:
						total_score += info.total_score

			if letter_combo_scores_shelve is not None:
				#print("storing key %r with value %r" % (letters_shelve_key, word_count))
				letter_combo_scores_shelve[letters_shelve_key] = (word_count, total_score)
			return WordCombinationInfo(word_count, total_score)
			
		

	# pattern matching words that only contain `letters`,
	# but may contain the same letter more than once
	word_pattern = '^[' + ''.join(letters) + ']+$'

	letter_counts = get_letter_counts_in_list(letters)

	# Create a list of conditions that would invalidate this match:
	# if it has any letter more than allowed.
	# I'm not aware of any fancy way to do this with a single regex,
	# e.g. "word matching any combination of this list of characters"
	letter_count_conditions = []
	for letter in letter_counts:
		excessive_letter_count = letter_counts[letter] + 1
		letter_count_conditions.append("'%" + "%".join([letter]*excessive_letter_count) + "%'")
	letter_count_conditions = 'word NOT LIKE' + ('AND word NOT LIKE '.join(letter_count_conditions))
		

	if score_only:
		query_params = 'COUNT(1), SUM(freq)'
	else:
		query_params = 'word, freq'

	if False and only_word_len:
		#length_condition = 'LENGTH(word) = %d AND ' % only_word_len
		length_condition = 'word_len = %d AND ' % only_word_len
	else:
		length_condition = ''

	query = ('SELECT {query_params} '
	         'FROM words{tbl_suffix} \n'
	         'WHERE \n'
	         '    LENGTH(word) >= {min_word_len} AND \n'
	         '    {length_condition} \n'
	         '    freq >= {min_freq} AND \n'
	         #'    length(word) >= 3 AND \n'
	         #'    word_len >= 3 AND \n'
	         '    word REGEXP "{word_pattern}" AND \n'
	         '    {letter_count_conditions} \n'
	         'ORDER BY \n'
	         '    LENGTH(word) DESC, \n'
	         '    freq DESC').format(min_word_len=min_word_len,
	                                 tbl_suffix= '%d' % only_word_len if only_word_len else '',
	                                 length_condition=length_condition,
	                                 query_params=query_params,
	                                 min_freq=min_freq,
	                                 word_pattern=word_pattern,
	                                 letter_count_conditions=letter_count_conditions)

	db_lookups += 1
	cur.execute(query)
	#os.system("sqlite3 word_dict.db \"%s\"" % query)

	if score_only:
		word_count, total_score = cur.fetchone()
		if letter_combo_scores_shelve:
			#print("for key %r, storing count=%d, score=%e" % (letters_shelve_key, word_count, total_score))
			letter_combo_scores_shelve[letters_shelve_key] = (word_count, total_score)
		return WordCombinationInfo(word_count, total_score)

	else:
		return cur.fetchall()
	
	#for item in cur.fetchall():
	#	word, freq = item
	#	show_info = 'shown' if freq >= 3e-6 else 'NOT SHOWN'
	#	print('%9s , %e, %s' % (word, freq, show_info))


con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("CREATE TABLE words (word, freq)")
for i in range(1,40):
	cur.execute("CREATE TABLE words%d (word, freq)" % i)

data_src_con = sqlite3.connect("word_dict.db")
data_src_cur = data_src_con.cursor()
rows = data_src_cur.execute("SELECT word, freq, LENGTH(word) from words")
for word, freq, word_length in rows:
	cur.execute("INSERT INTO words%d VALUES (?, ?)" % word_length, (word, freq))
	cur.execute("INSERT INTO words VALUES (?, ?)", (word, freq))
	


con.create_function("REGEXP", 2, sql_regexp)

LETTERS = string.ascii_lowercase
VOWELS  = [ 'a', 'e', 'i', 'o', 'u' ]

min_freq    = 3e-6
min_words   = 3

LetterCombinationInfo = collections.namedtuple("LetterCombinationInfo", field_names=["letters", "info", "words", "found_on_iter"])

letter_combo_scores = shelve.open("letter_combo_scores.shelve")
print("open shelve %r" % letter_combo_scores )

def find_all_word_combos():
	good_combos_found = 0
	i = 0
	for letters_len in range(min_letters-1,max_letters-1+1):
		good_combinations = []
		# TODO use "chain" and include the vowel in here...
		for other_letter_combinations in itertools.combinations_with_replacement(LETTERS, letters_len):
			for vowel in VOWELS:
				letter_combinations = list(other_letter_combinations) + [vowel]
				#print("trying letters  %r" % letter_combinations)
				info = get_words_containing_only_letters(cur, min_freq, letter_combinations, score_only=True, letter_combo_scores_shelve=letter_combo_scores)
				i += 1
				#if i % 100 == 0: print(i, letter_combinations)
				if info.word_count >= min_words:
	
					#words = get_words_containing_only_letters(cur, min_freq, letter_combinations, score_only=False)
					#combination_info = LetterCombinationInfo(letter_combinations, info, words, i)
					good_combinations.append((letter_combinations, info))
					#sys.stdout.write(' '.join([str(x) for x in [i, letter_combinations, info, words]]) + '\n')
					#sys.stdout.flush()
					good_combos_found += 1
					if good_combos_found % 1000 == 0: 
						sys.stdout.write(str(letter_combinations) + str(info))
						sys.stdout.write("\n")
						sys.stdout.flush()
	
		print("##########################")
		print("##########################")
		print("### sorted info ")
		print("##########################")
		good_combinations = sorted(good_combinations, key=lambda x: (x[1].word_count, x[1].total_score), reverse=True)
		print('len: %d' % len(good_combinations))
		for combination_info in good_combinations[:20]:
			letters, info = combination_info
			words = get_words_containing_only_letters(cur, min_freq, letters, score_only=False)
			sys.stdout.write('%s: %s, %s\n' % (letters, info, words))
			sys.stdout.flush()
				
	print(i)

try:
	find_all_word_combos()
except:
	letter_combo_scores.close()
	print("\n\n")
	print("db_lookups = %9d" % db_lookups)
	print("shelve_lookups = %9d" % shelve_lookups)
	raise
	
	
# get_words_containing_only_letters(cur, ["r", "m", "c", "i", "y", "e"])



#!/usr/bin/env python
#
# This script loops through each English word and finds other words that can be
# made by rearranging all, or a subset of, its letters.
#
# It depends on `out/word_dict.db`, so run `src/dictionary/build_word_list_w_freq.py`
# before running it.
#
# The useful output of this script is just interesting sets of letters which
# can make up many other common words.
# I run this script and then pick sets of letters and hardcode them into
# crossword_letters_gen_puzzles.lua. 
#
# TODO after trying some puzzles made from the max score letters, I'm realizing that
# the current score isn't ideal. The crosswords can only fit so many words, say 15-20 max.
# It's not as fun to guess words that don't fit in the crossword.
#
# So the score should actually penalize letters that find more than 15-20 common words.
#
# The highest score should be letters that can come up with 15-20 common words (above 1e-6 or so),
# have barely any common words beyond that 15-20,
# and maybe have few rare words
#
# So the score should be something like:
#     fit_words_score     = sum(freq) for words where freq >= 1e-6 LIMIT 20; -- not sure if LIMIT works here.
#     not_fit_words_score = fit_words_score - (sum(freq) for words where freq >= 1e-6) -- not sure if there's a way to do this in a single SQL query
# score = fit_words_score - weight * not_fit_words_score
#
# I'm not sure what "weight" should be. See what happens if it is like 100 at first.
# Maybe finding up to say 5 more is not a big deal, perhaps the weight for that can be 0 or less.
#
# TODO:
# * consider lowering frequency threshold for longer words in crossword letters. I defined 1e-6 from looking at 3 letter words. I think longer words have lower frequency even if they are more well known than the obscure 3 letter words that I saw.
#* consider including letter combinations that make many words, and just ensuring a certain minimum umber of easy-to-guess 3 and 4 letter words. Those will provide hints for the longer ones.
#

import re
import string
import itertools
import collections
import sys
import argparse

import shelve
import sqlite3

parser = argparse.ArgumentParser(
	prog='gen_crossword_letters',
	description='Loops through combinations of letters, finding sets of letters that '
	            'can make up a certain number of other English words. A subset of '
	            'letters can be used. Sorts all sets of letters based on "score" (highest '
	            'frequency) and outputs the highest ones.',
	epilog='Intended to be used to generate sets of letters to be used to generate '
	       'crossword puzzles for the `crossword_letters` game.')

parser.add_argument('--min_word_len', type=int,   default=4   ,
                    help='Minimum length of words to be included in score calculation')
parser.add_argument('--min_freq',     type=float, default=1e-6,
                    help='Minimum frequency for a word to be included in score calculation')
parser.add_argument('--min_words',    type=int,   default=3   ,
                    help='Only include sets of letters that can make up this many words or more.')
parser.add_argument('--max_words',    type=int,   default=20  ,
                    help='Exclude sets of letters that make up more than this many words.')

parser.add_argument('--min_letters',  type=int,   default=None   ,
                    help='Only bother trying sets of letters with at least this many letters. '
                         'Must be >= than min_word_len. '
                         'If not set, defaults to min_word_len.')

parser.add_argument('--max_letters',  type=int,   default=8   ,
                    help='Maximum length of sets of letters to try.')

# TODO not sure that I want to do this,
# since changing any of the parameters can mess up the score.
parser.add_argument('--cache_file', default='out/word_scores.shelve',
                    help='Cache scores in this file, so future executions of this program '
                         'can be faster when looking up the same words.')

args = parser.parse_args()

min_freq    = args.min_freq
min_words   = args.min_words
max_words   = args.max_words

max_letters = args.max_letters
min_word_len   = args.min_word_len
min_letters    = args.min_letters

if min_letters is None:
	min_letters = min_word_len

if min_letters < min_word_len:
	raise Exception('arg min_letters (%r) must be >= min_word_len (%r)' % (min_letters, min_word_len))

db_lookups     = 0
shelve_lookups = 0

def sql_regexp(pattern, item):
	reg = re.compile(pattern)
	return reg.search(item) is not None




def get_letter_counts_in_list(letter_list):
	counts = {}
	for letter in letter_list:
		if letter not in counts: counts[letter] = 0
		counts[letter] += 1
	return counts


WordCombinationInfo = collections.namedtuple('WordCombinationInfo', field_names = ['word_count', 'total_score', 'max_word_len'])
def get_words_containing_only_letters(cur, min_freq, letters, score_only, letter_combo_scores_shelve=None, only_word_len=None, recursive=True):
	global db_lookups
	global shelve_lookups

	letters_shelve_key = ''.join(sorted(letters))
	#print("trying letters key %r, only_word_len=%r" % (letters_shelve_key, only_word_len))

	if score_only:
		if letter_combo_scores_shelve is not None:
			try:
				cached_value = letter_combo_scores_shelve[letters_shelve_key]
				shelve_lookups += 1
				# print("found cached value %s" % repr(cached_value))
				word_count, total_score = cached_value
				return WordCombinationInfo(word_count, total_score)
			except KeyError:
				# print("could not find cached value for key %r" % letters_shelve_key)
				pass
	
		if recursive and not only_word_len:
			word_count  = 0
			total_score = 0
			for word_len in range(min_letters, len(letters)+1):
				#print("recursive, trying word_len %d" % word_len)
				for letters2 in itertools.combinations(letters, word_len):
					#print("trying letters2 %s" % repr(letters2))
					info = get_words_containing_only_letters(cur, min_freq, letters2, score_only=score_only,
					                                         letter_combo_scores_shelve=letter_combo_scores_shelve,
					                                         only_word_len=word_len,
					                                         recursive=recursive)
					#print("recvd info %s" % repr(info))
					word_count  += info.word_count
					if info.total_score:
						total_score += info.total_score

			if letter_combo_scores_shelve is not None:
				#print("storing key %r with value %r" % (letters_shelve_key, word_count))
				letter_combo_scores_shelve[letters_shelve_key] = (word_count, total_score)
			return WordCombinationInfo(word_count, total_score)
			
		

	# pattern matching words that only contain `letters`,
	# but may contain the same letter more than once
	word_pattern = '^[' + ''.join(letters) + ']+$'

	letter_counts = get_letter_counts_in_list(letters)

	# Create a list of conditions that would invalidate this match:
	# if it has any letter more than allowed.
	# I'm not aware of any fancy way to do this with a single regex,
	# e.g. "word matching any combination of this list of characters"
	letter_count_conditions = []
	for letter in letter_counts:
		excessive_letter_count = letter_counts[letter] + 1
		letter_count_conditions.append("'%" + "%".join([letter]*excessive_letter_count) + "%'")
	letter_count_conditions = 'word NOT LIKE' + ('AND word NOT LIKE '.join(letter_count_conditions))
		

	if score_only:
		query_params = 'COUNT(1), SUM(freq), MAX(LENGTH(word))'
	else:
		query_params = 'word, freq'

	if False and only_word_len:
		#length_condition = 'LENGTH(word) = %d AND ' % only_word_len
		length_condition = 'word_len = %d AND ' % only_word_len
	else:
		length_condition = ''

	query = ('SELECT {query_params} '
	         'FROM words{tbl_suffix} \n'
	         'WHERE \n'
	         '    LENGTH(word) >= {min_word_len} AND \n'
	         '    {length_condition} \n'
	         '    freq >= {min_freq} AND \n'
	         #'    length(word) >= 3 AND \n'
	         #'    word_len >= 3 AND \n'
	         '    word REGEXP "{word_pattern}" AND \n'
	         '    {letter_count_conditions} \n'
	         'ORDER BY \n'
	         '    LENGTH(word) DESC, \n'
	         '    freq DESC').format(min_word_len=min_word_len,
	                                 tbl_suffix= '%d' % only_word_len if only_word_len else '',
	                                 length_condition=length_condition,
	                                 query_params=query_params,
	                                 min_freq=min_freq,
	                                 word_pattern=word_pattern,
	                                 letter_count_conditions=letter_count_conditions)

	db_lookups += 1
	#print(query)
	#sys.exit()
	cur.execute(query)
	#os.system("sqlite3 word_dict.db \"%s\"" % query)

	if score_only:
		word_count, total_score, max_word_len = cur.fetchone()
		if letter_combo_scores_shelve:
			#print("for key %r, storing count=%d, score=%e" % (letters_shelve_key, word_count, total_score))
			letter_combo_scores_shelve[letters_shelve_key] = (word_count, total_score, max_word_len)
		return WordCombinationInfo(word_count, total_score, max_word_len)

	else:
		return cur.fetchall()
	
	#for item in cur.fetchall():
	#	word, freq = item
	#	show_info = 'shown' if freq >= 3e-6 else 'NOT SHOWN'
	#	print('%9s , %e, %s' % (word, freq, show_info))


con = sqlite3.connect(":memory:")
cur = con.cursor()
cur.execute("CREATE TABLE words (word, freq)")
for i in range(1,40):
	cur.execute("CREATE TABLE words%d (word, freq)" % i)

data_src_con = sqlite3.connect("out/word_dict.db")
data_src_cur = data_src_con.cursor()
rows = data_src_cur.execute("""
SELECT word, freq, LENGTH(word) from words
WHERE NOT words.is_vulgar_or_weird""")
for word, freq, word_length in rows:
	cur.execute("INSERT INTO words%d VALUES (?, ?)" % word_length, (word, freq))
	cur.execute("INSERT INTO words VALUES (?, ?)", (word, freq))

skip_words = set([
	'tae',
	'dna',
	'dan',
	'ons',
	'opt',
	'nos',
	'das',
	'mar',
	'mae',
])
	


con.create_function("REGEXP", 2, sql_regexp)

LETTERS = string.ascii_lowercase
VOWELS  = [ 'a', 'e', 'i', 'o', 'u', 'y' ]



LetterCombinationInfo = collections.namedtuple("LetterCombinationInfo", field_names=["letters", "info", "words", "found_on_iter"])


"""
words = get_words_containing_only_letters(cur, min_freq, list("deeaft"), score_only=False)
for word in words:
	print(word)
sys.exit()
"""

letter_combo_scores = shelve.open(args.cache_file)
#letter_combo_scores = None
print("open shelve %r" % letter_combo_scores )

def get_all_words_by_length():
	words_by_len = {}
	data = cur.execute("SELECT word, freq FROM words WHERE LENGTH(word) >= ? AND freq >= ?", (min_word_len, min_freq))
	for word, freq in cur.fetchall():
		word_length = len(word)
		if word_length not in words_by_len:
			words_by_len[word_length] = []

		words_by_len[word_length].append( (word, freq) )
		
	return words_by_len

def find_all_word_combos():
	good_combos_found = 0
	i = 0

	words_by_len = get_all_words_by_length()

	for letters_len in range(min_letters,max_letters+1):
	#for letters_len in [4]:
		good_combinations = []

		for letter_combinations, freq in words_by_len[letters_len]:
			letter_combinations = list(letter_combinations)
			if True:
				#print("trying letters  %r" % letter_combinations)
				info = get_words_containing_only_letters(cur, min_freq, letter_combinations, score_only=True, letter_combo_scores_shelve=letter_combo_scores, recursive=False)
				i += 1
				#if i % 100 == 0: print(i, letter_combinations)
				#if min_words <= info.word_count:
				if min_words <= info.word_count <= max_words:
	
					#words = get_words_containing_only_letters(cur, min_freq, letter_combinations, score_only=False)
					#combination_info = LetterCombinationInfo(letter_combinations, info, words, i)
					good_combinations.append((letter_combinations, info))
					#sys.stdout.write(' '.join([str(x) for x in [i, letter_combinations, info, words]]) + '\n')
					#sys.stdout.flush()
					good_combos_found += 1
					if False and good_combos_found % 1000 == 0: 
						sys.stdout.write(str(letter_combinations) + str(info))
						sys.stdout.write("\n")
						sys.stdout.flush()
	
		print("##########################")
		print("##########################")
		print("### sorted info ")
		print("##########################")

		words_by_letters = {}
		words_seen_before = set()
		letter_combos_seen_before = set()
		good_combinations = sorted(good_combinations, key=lambda x: (x[1].max_word_len, x[1].total_score), reverse=True)
		print('len: %d' % len(good_combinations))
		j = 0
		for combination_info in good_combinations:
			letters, info = combination_info
			letters_key = ''.join(sorted(letters))
			if letters_key in letter_combos_seen_before: continue
			letter_combos_seen_before.add(letters_key)

			word_info = get_words_containing_only_letters(cur, min_freq, letters, score_only=False)
			#words = [ word for word, freq in word_info if word not in words_seen_before and word not in skip_words ]
			words = [ word for word, freq in word_info if word not in skip_words ]
			#print(words)
			for word in words: words_seen_before.add(word)
			words_by_letters[letters_key] = words

		good_combinations = sorted(good_combinations, key=lambda x: (len(words_by_letters[''.join(sorted(x[0]))]), x[1].total_score), reverse=True)

		words_seen_before = set()
		for combination_info in good_combinations:
			letters, info = combination_info
			letters_key = ''.join(sorted(letters))
			if letters_key in words_seen_before: continue
			words_seen_before.add(letters_key)
			words = words_by_letters[letters_key]
			sys.stdout.write('%4d %s: %s, %s\n' % (j, letters, info, words[:100]))
			sys.stdout.flush()
			j += 1
			if j >= 100: break
				
	print(i)

try:
	find_all_word_combos()
except:
	if letter_combo_scores is not None:
		letter_combo_scores.close()
	print("\n\n")
	print("db_lookups = %9d" % db_lookups)
	print("shelve_lookups = %9d" % shelve_lookups)
	raise
	
	



#!/usr/bin/env lua
package.path = 'src/lua_scripts/?.lua'

local puzzles = require("games/crossword_letters/crossword_letters_puzzles")

local words_list = {}
local words_count = {}

for _, puzzle in ipairs(puzzles.puzzles) do
	for _, word_pos_info in ipairs(puzzle.word_positions) do
		local word = word_pos_info.word
		if not words_count[word] then
			table.insert(words_list, word)
			words_count[word] = 1
		else
			words_count[word] = words_count[word] + 1
		end
	end
end

--[[
for word, count in pairs(words_count) do
	if count > 1 then
		print(string.format("Found word %-8s %d times", word, count))
	end
end
--]]


local bad_words_list = {
}

local bad_words_set = {}

for _, word in ipairs(bad_words_list) do
	bad_words_set[word] = true
end

for _, word in ipairs(words_list) do
	if bad_words_set[word] then
		goto next_word
	end
	print(string.format("%-6s", word))
	::next_word::
end
#!/usr/bin/env python
import sys


fname1 = sys.argv[1]
fname2 = sys.argv[2]

words1 = set()
with open(fname1, 'r') as f:
	for line in f:
		word = line.strip()
		words1.add(word)

print('Words in %s that are not present in %s:' % (fname2, fname1))
with open(fname2, 'r') as f:
	for line in f:
		word = line.strip()
		if word not in words1:
			print(word)
local core = {}

-- TODO remove, only for debugging
local alex_c_api = require("alex_c_api")

local Y_MIN =  0
local Y_MAX = 10

core.PLAYER_SIZE_Y = 0.5
core.PLAYER_SIZE_X = 0.75

core.WALL_SIZE_X = 1

core.JUMP_TYPE_KEY   = 1
core.JUMP_TYPE_TOUCH = 2

local DIST_BETWEEN_WALLS = 4
local GRAVITY = 15
--local JUMP_SPEED_INC_KEY = 8
--local JUMP_SPEED_INC_TOUCH = 6.5

local Y_VEL_ON_JUMP = 5

local Y_POS_INIT = 5
--local WALL_GAP_SIZE = 3.5 -- this doesn't seem hard enough, even on mobile
--local WALL_GAP_SIZE = 3.25 -- this seems a bit harder, but not much
--local WALL_GAP_SIZE = 3 -- this seems about right
--local WALL_GAP_SIZE = 2.75
--local WALL_GAP_SIZE = 2.5
local WALL_GAP_SIZE = 2.0

local FIRST_WALL_X = 8


local WALL_GAP_POS_MIN = 2
local WALL_GAP_POS_MAX = 8

local WALL_INIT_SEGMENTS = 5

local PLAYER_X_VEL = DIST_BETWEEN_WALLS

-- Once a wall is this far away behind the player,
-- remove it
local REMOVE_WALLS_BEHIND_DIST = 5

local function clip(val, min_val, max_val)
	if val <= min_val then
		return min_val
	end

	if val >= max_val then
		return max_val
	end

	return val
end

local function random_range(min_val, max_val)
	return min_val + math.random() * (max_val - min_val)
end

local function generate_new_wall_segs(prev_gap_y_pos, x_pos)
	local new_gap_pos = prev_gap_y_pos + math.random(-3,3)
	--local new_gap_pos = prev_gap_y_pos + math.random(-1,1) * 3
	new_gap_pos = clip(new_gap_pos, WALL_GAP_POS_MIN, WALL_GAP_POS_MAX)
	-- TODO consider decreasing gap size gradually from say 4 to 3 or so
	-- from wall 0 to 100.
	-- TODO change x_pos to index
	--local wall_gap_size = random_range(2,4)
	local wall_gap_size = 2.75
	local wall1_y = new_gap_pos - wall_gap_size/2
	local wall2_y = new_gap_pos + wall_gap_size/2
	local wall1 = {
		x       = x_pos,
		y_outer = Y_MIN,
		y_inner = wall1_y
	}
	local wall2 = {
		x       = x_pos,
		y_outer = Y_MAX,
		y_inner = wall2_y
	}

	return {
		wall1 = wall1,
		wall2 = wall2,
		gap_pos = new_gap_pos
	}
end

local function get_last_gap_pos(state)
	assert(#state.walls >= 2)
	local wall1 = state.walls[#state.walls-1]
	local wall2 = state.walls[#state.walls-0]

	return (wall1.y_inner + wall2.y_inner)/2
end

function core.update_state(state, dt_ms)
	if state.game_over then
		return
	end

	local dt = dt_ms / 1000

	local prev_player_x = state.player_x

	state.player_x = state.player_x + PLAYER_X_VEL * dt
	state.player_y_vel = state.player_y_vel - GRAVITY * dt
	state.player_y = state.player_y + state.player_y_vel * dt

	if state.player_y - core.PLAYER_SIZE_Y/2 < Y_MIN then
		state.game_over = true
	end
	if state.player_y + core.PLAYER_SIZE_Y/2 >= Y_MAX then
		state.game_over = true
	end

	for _, wall in ipairs(state.walls) do
		if prev_player_x - core.PLAYER_SIZE_X/2 <= wall.x + core.WALL_SIZE_X/2 and
		   wall.x - core.WALL_SIZE_X/2 <= state.player_x + core.PLAYER_SIZE_X/2 then
			-- TODO this is a bit ugly
			if wall.y_outer == Y_MAX and state.player_y + core.PLAYER_SIZE_Y/2 > wall.y_inner or
			   wall.y_outer == Y_MIN and state.player_y - core.PLAYER_SIZE_Y/2 < wall.y_inner then
				local debug_str = string.format("wall { y_outer: %s, y_inner: %s, x: %s },  player = { y: %s, x: %s }",
				                    wall.y_outer, wall.y_inner, wall.x, state.player_y, state.player_x)
				-- TODO remove
				alex_c_api.set_status_msg("Wall collision! Debug info: " .. debug_str)
				state.game_over = true
				break
			end
		
		end
	end

	while #state.walls > 0 and state.walls[1].x < state.player_x - REMOVE_WALLS_BEHIND_DIST do
		table.remove(state.walls, 1)
	end

	local prev_gap_pos = get_last_gap_pos(state)
	local prev_x_pos = state.walls[#state.walls].x
	while #state.walls < 2*WALL_INIT_SEGMENTS do
		local x_pos = prev_x_pos + DIST_BETWEEN_WALLS
		local wall_info = generate_new_wall_segs(prev_gap_pos, x_pos)
		table.insert(state.walls, wall_info.wall1)
		table.insert(state.walls, wall_info.wall2)
		prev_gap_pos = wall_info.gap_pos
		prev_x_pos   = x_pos
	end

	--print(string.format("walls count: %d; first x: %5d, last x: %5d", #state.walls, state.walls[1].x, state.walls[#state.walls].x))
end

function core.jump(state, jump_type)
	if state.game_over then
		return
	end


	--[[
	local jump_inc = nil

	if jump_type == core.JUMP_TYPE_KEY then
		jump_inc = JUMP_SPEED_INC_KEY
	elseif jump_type == core.JUMP_TYPE_TOUCH then
		jump_inc = JUMP_SPEED_INC_TOUCH
	end

	state.player_y_vel = state.player_y_vel + jump_inc
	--]]
	state.player_y_vel = Y_VEL_ON_JUMP
end

function core.score(state)
	local score = math.ceil( (state.player_x - FIRST_WALL_X) / DIST_BETWEEN_WALLS )
	if score < 0 then
		return 0
	else
		return score
	end
end

function core.new_state()
	local state = {
		player_y = Y_POS_INIT,
		player_x = 0,
		player_y_vel = 0,

		walls = {},

		game_over = false,
	}

	local prev_gap_pos = Y_POS_INIT
	for i=1,WALL_INIT_SEGMENTS do
		if #state.walls >= 2 then
			assert(get_last_gap_pos(state) == prev_gap_pos)
		end
		local x_pos = FIRST_WALL_X + (i-1)*DIST_BETWEEN_WALLS
		local wall_info = generate_new_wall_segs(prev_gap_pos, x_pos)
		table.insert(state.walls, wall_info.wall1)
		table.insert(state.walls, wall_info.wall2)
		prev_gap_pos = wall_info.gap_pos
	end
	return state
end

return core
local draw = {}

local core = require("games/endless_runner/endless_runner_core")

local buttons = require("libs/ui/buttons")

local alex_c_api = require("alex_c_api")

local PLAYER_FILL_COLOUR = '#ff0000'
local PLAYER_OUTLINE_COLOUR = '#000000'
local PLAYER_RADIUS = 20


local WALL_COLOUR = '#0000ff'
local WALL_THICKNESS = 10

local BTN_BACKGROUND_COLOUR = '#888'

local board_width  = 480
local board_height = 480

local player_pos_y = board_height/2
local player_pos_x = board_height/4

local SCORE_TEXT_SIZE = 24
local padding = 5

local buttons_state = buttons.new_state()
local BTN_ID_NEW_GAME = "btn_new_game"

buttons.new_button(buttons_state, {
	id   = BTN_ID_NEW_GAME,
	text = "New Game",
	-- TODO add defaults for all of these
	bg_colour = "#888",
	fg_colour = "#000",
	outline_colour = "#000",
	outline_width = 3,
	text_size = 24,

	y_start = padding,
	y_end   = padding + 75,

	x_start = board_width - padding - 200,
	x_end   = board_width - padding,
})


local WALL_TO_PIXEL_SCALE = 480/10

local function game_pos_to_screen_pos(state, pt)
	local screen_pt = {}
	screen_pt.y = board_height - (pt.y * WALL_TO_PIXEL_SCALE)
	screen_pt.x = (pt.x - state.player_x) * WALL_TO_PIXEL_SCALE + player_pos_x

	return screen_pt
end

function draw.draw_board(state, dt_ms)
	alex_c_api.draw_clear()

	for _, wall in ipairs(state.walls) do
		local pt1 = game_pos_to_screen_pos(state, { y = wall.y_outer, x = wall.x - core.WALL_SIZE_X/2 })
		local pt2 = game_pos_to_screen_pos(state, { y = wall.y_inner, x = wall.x + core.WALL_SIZE_X/2 })
		--alex_c_api.draw_line(WALL_COLOUR, WALL_THICKNESS,
		--                     pt1.y, pt1.x,
		 --                    pt2.y, pt2.x)
		alex_c_api.draw_rect(WALL_COLOUR,
		                     pt1.y, pt1.x,
		                     pt2.y, pt2.x)
	end

	local player_ul = { y = state.player_y + core.PLAYER_SIZE_Y/2, x = state.player_x - core.PLAYER_SIZE_X/2 }
	local player_lr = { y = state.player_y - core.PLAYER_SIZE_Y/2, x = state.player_x + core.PLAYER_SIZE_X/2 }
	player_ul = game_pos_to_screen_pos(state, player_ul)
	player_lr = game_pos_to_screen_pos(state, player_lr)
	--alex_c_api.draw_circle(PLAYER_FILL_COLOUR, PLAYER_OUTLINE_COLOUR,
	--                       player_pos.y, player_pos.x, PLAYER_RADIUS)
	alex_c_api.draw_rect(PLAYER_FILL_COLOUR,
	                     player_ul.y, player_ul.x,
	                     player_lr.y, player_lr.x)

	local score_text = string.format("%d", core.score(state))
	alex_c_api.draw_text(score_text, '#880000',
	                     SCORE_TEXT_SIZE + padding,
	                     board_width/2,
	                     SCORE_TEXT_SIZE, alex_c_api.TEXT_ALIGN_CENTRE)

	buttons.set_visible(buttons_state, BTN_ID_NEW_GAME, state.game_over)

	buttons.draw(buttons_state)

	alex_c_api.draw_refresh()
end


function draw.in_new_game_btn(state, pos_y, pos_x)
	if buttons.on_user_click(buttons_state, pos_y, pos_x) then
		return true
	end

	return false
end

return draw
local core = require("games/endless_runner/endless_runner_core")
local draw = require("games/endless_runner/endless_runner_draw")

local alex_c_api = require("alex_c_api")

local FPS = 60

local g_state = nil

function draw_board(dt_ms)
	if dt_ms and dt_ms > 0 then
		core.update_state(g_state, dt_ms)
	end
	draw.draw_board(g_state)
end

local jump_keys = {
	["Space"]   = true,
	["Enter"]   = true,
	["ArrowUp"] = true,
	["KeyK"]    = true,
	["KeyW"]    = true
}

local function new_game()
	g_state = core.new_state()
end

function handle_key_evt(key_evt, key_id)
	print(string.format("evt=%s, id=%s", key_evt, key_id))
	if jump_keys[key_id] then
		if key_evt == "keydown" then
			core.jump(g_state, core.JUMP_TYPE_KEY)
		end
		return true
	end
	return false
end

function handle_mouse_evt(evt_id, pos_y, pos_x)
	if evt_id == alex_c_api.MOUSE_EVT_DOWN then
		core.jump(g_state, core.JUMP_TYPE_KEY)
		if draw.in_new_game_btn(state, pos_y, pos_x) then
			new_game()
		end
	end

end

function handle_touch_evt(evt_id, touches)
	for _, touch in ipairs(touches) do
		if evt_id == "touchstart" then
			core.jump(g_state, core.JUMP_TYPE_TOUCH)
			if draw.in_new_game_btn(state, touch.y, touch.x) then
				new_game()
			end
		end
	end

end

function start_game(session_id_arg, serialized_state_arg)
	new_game()

	alex_c_api.set_timer_update_ms(1000/FPS)
	alex_c_api.enable_evt("key")
	alex_c_api.enable_evt("mouse_updown")
	alex_c_api.enable_evt("touch")
end
local core = {}

local shuffle = require("libs/shuffle")

core.RC_SUCCESS      = 0
core.RC_INVALID_MOVE = 1

function core.new_state(num_colours, num_extra_vials, num_segments, params)
	local seed_x, seed_y
	if params and params.seed_x and params.seed_y then
		seed_x, seed_y = math.randomseed(params.seed_x, params.seed_y)
	else
		seed_x, seed_y = math.randomseed()
	end

	local vials_and_segments_flat = {}
	for color_idx=1,num_colours do
		for seg=1,num_segments do
			table.insert(vials_and_segments_flat, color_idx)
		end
	end

	shuffle.shuffle(vials_and_segments_flat)

	local state = {
		num_segments = num_segments,
		vials = {},
		seed_x = seed_x,
		seed_y = seed_y,
	}
	local num_vials = num_colours + num_extra_vials
	local i = 1
	for _=1,num_vials do
		local vial = {}
		for _=1,num_segments do
			local val = 0
			if i <= #vials_and_segments_flat then
				val = vials_and_segments_flat[i]
				i = i + 1
				table.insert(vial, val)
			end
		end
		table.insert(state.vials, vial)
	end

	return state
end

function core.game_won(state)
	for _, vial in ipairs(state.vials) do
		if #vial == 0 then
			goto next_vial
		end

		if #vial ~= state.num_segments then
			return false
		end

		for _, seg in ipairs(vial) do
			if seg ~= vial[1] then
				return false
			end
		end

		::next_vial::
	end

	return true
end

local function get_same_segs_count(state, idx)
	local vial = state.vials[idx]

	if #vial == 0 then return 0 end

	local colour = vial[#vial]
	local seg_idx = 1
	while vial[#vial-seg_idx+1] == colour do
		if seg_idx == #vial then
			return #vial
		end
		seg_idx = seg_idx + 1
	end

	return seg_idx - 1
end

function core.move(state, src, dst)
	local src_vial = state.vials[src]
	local dst_vial = state.vials[dst]

	if #src_vial == 0 then
		return core.RC_INVALID_MOVE
	end


	if state.num_segments - #dst_vial < get_same_segs_count(state, src) then
		return core.RC_INVALID_MOVE
	end

	if #dst_vial > 0 and dst_vial[#dst_vial] ~= src_vial[#src_vial] then
		return core.RC_INVALID_MOVE
	end

	if src == dst then
		return core.RC_INVALID_MOVE
	end

	local colour = src_vial[#src_vial]
	while src_vial[#src_vial] == colour do
		local val = table.remove(src_vial, #src_vial)
		table.insert(dst_vial, val)
	end
end

return core
local draw = {}
local alex_c_api  = require("alex_c_api")
local draw_shapes = require("libs/draw/draw_shapes")

local draw_celebration_anim = require("libs/draw/draw_celebration_anim")

local OUTLINE_COLOUR = '#000000'
local OUTLINE_WIDTH  = 3
local HIGHLIGHT_OUTLINE_WIDTH  = 5
local HIGHLIGHT_COLOUR = '#ffff0066'
local HIGHLIGHT_OUTLINE_COLOUR = '#ffff00'
local COLOUR_MAP = {
	'#ff0000',
	'#00ff00',
	'#0000ff',
	'#ffff00',
	'#00ffff',
	'#ff00ff',
	'#ffffff',
	'#ff8800',
	'#ff0088',
	'#ff8888',
	'#00ff88',
	'#88ff00',
	'#88ff88',
	'#0088ff',
	'#8800ff',
	'#8888ff',
	'#888888',
}

local board_width  = 480
local board_height = 480

local vial_padding = 15

draw.BTN_ID_UNDO = "btn_undo"
draw.BTN_ID_REDO = "btn_redo"

local anim_state = draw_celebration_anim.new_state({
})
-- TODO this probably should be included in the anim state?
-- Perhaps as an option, for games that don't otherwise require a timer
local g_victory_anim_timer = nil


function draw.init()
	alex_c_api.create_btn(draw.BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(draw.BTN_ID_REDO, "Redo", 1)
end

function draw.new_state()
	return {
		selected = nil
	}
end

local function get_size_params(state, num_rows)
	local vials_per_row = math.ceil(#state.vials/num_rows)
	local vial_width = math.floor((board_width - (vials_per_row+1) * vial_padding)/vials_per_row)
	local vial_height = math.floor(board_height/num_rows) - 2*vial_padding

	print(string.format("width: %s, height: %s", vial_width, vial_height))

	return {
		vials_per_row = vials_per_row,
		width         = vial_width,
		height        = vial_height,
	}
end

local function get_vial_params(params, i)
	local vial_y_idx = math.floor((i-1)/params.vials_per_row)
	local vial_x_idx = (i-1) % params.vials_per_row

	return {
		y_start = (params.height + vial_padding) * vial_y_idx     + vial_padding,
		x_start = (params.width  + vial_padding) * vial_x_idx     + vial_padding,
		y_end   = (params.height + vial_padding) * (vial_y_idx+1),
		x_end   = (params.width  + vial_padding) * (vial_x_idx+1),
	}
end

local function get_num_rows(vial_count)
	return 2
end

function draw.update_state(draw_state, dt_ms)
	draw_celebration_anim.update(anim_state, dt_ms/1000.0)
end

function draw.draw_state(session_id, state, draw_state)
	alex_c_api.draw_clear()

	local num_rows = get_num_rows(#state.vials)
	local params = get_size_params(state, num_rows)

	for vial_idx, vial in ipairs(state.vials) do
		local vial_params = get_vial_params(params, vial_idx)

		draw_shapes.draw_rect_outline(OUTLINE_COLOUR, OUTLINE_WIDTH,
		                              vial_params.y_start, vial_params.x_start,
		                              vial_params.y_end,   vial_params.x_end)

		for seg_idx, colour_idx in ipairs(vial) do
			if colour_idx == 0 then
				goto draw_highlight
			end
			local colour = COLOUR_MAP[colour_idx]
			if colour == nil then
				error(string.format("could not resolve colour idx %s", colour_idx))
			end
			seg_idx = state.num_segments - seg_idx + 1
			alex_c_api.draw_rect(colour,
			                     vial_params.y_start + (seg_idx-1)*params.height/state.num_segments, vial_params.x_start,
			                     vial_params.y_start + (seg_idx)*params.height/state.num_segments,   vial_params.x_end)
			alex_c_api.draw_text(string.format("%d", colour_idx), OUTLINE_COLOUR,
			                     vial_params.y_start + params.height/2/state.num_segments + (seg_idx-1)*params.height/state.num_segments,
			                     vial_params.x_start + params.width/2,
			                     12, alex_c_api.TEXT_ALIGN_CENTRE)
		end
		::draw_highlight::
		if vial_idx == draw_state.selected then
			alex_c_api.draw_rect(HIGHLIGHT_COLOUR,
			                     vial_params.y_start, vial_params.x_start,
			                     vial_params.y_end,   vial_params.x_end)
			draw_shapes.draw_rect_outline(HIGHLIGHT_OUTLINE_COLOUR, HIGHLIGHT_OUTLINE_WIDTH,
			                     vial_params.y_start, vial_params.x_start,
			                     vial_params.y_end,   vial_params.x_end)
		end
	end
	
	draw_celebration_anim.draw(anim_state)
	alex_c_api.draw_refresh()

	alex_c_api.set_btn_enabled(draw.BTN_ID_UNDO, alex_c_api.has_saved_state_offset(session_id, -1))
	alex_c_api.set_btn_enabled(draw.BTN_ID_REDO, alex_c_api.has_saved_state_offset(session_id,  1))
end

function draw.coords_to_vial_idx(state, pos_y, pos_x)
	local num_rows = get_num_rows(#state.vials)
	local params = get_size_params(state, num_rows)

	for vial_idx, _ in ipairs(state.vials) do
		local vial_params = get_vial_params(params, vial_idx)
		if vial_params.y_start <= pos_y and pos_y <= vial_params.y_end and
		   vial_params.x_start <= pos_x and pos_x <= vial_params.x_end then
			return vial_idx
		end
	end
end

function draw.handle_user_clicked(state, draw_state, pos_y, pos_x)
	local vial_idx = draw.coords_to_vial_idx(state, pos_y, pos_x)
	if vial_idx == nil then return end
	if draw_state.selected == nil then
		draw_state.selected = vial_idx
	else
		local to_return = {
			src = draw_state.selected,
			dst = vial_idx,
		}
		draw_state.selected = nil
		return to_return
	end
end

function draw.trigger_win_anim(draw_state, fps)
	print("setting timer")
	if g_victory_anim_timer ~= nil then
		error(string.format("victory_animation: anim_timer is not nil"))
	end
	g_victory_anim_timer = alex_c_api.set_timer_update_ms(1000/fps)
	draw_celebration_anim.fireworks_display(anim_state, {
		colour_pref = "light",
		on_finish = function ()
			if g_victory_anim_timer == nil then
				alex_c_api.set_status_err("warning: g_victory_anim_timer is nil on anim complete")
			else
				alex_c_api.delete_timer(g_victory_anim_timer)
				g_victory_anim_timer = nil
			end
			--print("animation finished! Resuming timer")
			--alex_c_api.set_timer_update_ms(0)
			--alex_c_api.set_timer_update_ms(1000/60)
		end,
	})
end

return draw

local core = require("games/fluid_mix/fluid_mix_core")
local draw = require("games/fluid_mix/fluid_mix_draw")
local serialize = require("games/fluid_mix/fluid_mix_serialize")

local alex_c_api  = require("alex_c_api")


local g_session_id = nil
local g_state = nil
local draw_state = draw.new_state()
local vial_selected = nil
local g_win_anim_shown = nil

local BTN_ID_NEW_GAME = "btn_new_game"
draw.init()

alex_c_api.add_game_option(BTN_ID_NEW_GAME, { type = alex_c_api.OPTION_TYPE_BTN, label = "New Game"})


function draw_board(dt_ms)
	if g_state == nil then return end
	if dt_ms ~= nil then
		draw.update_state(draw_state, dt_ms)
	end
	draw.draw_state(g_session_id, g_state, draw_state)
end

local function save_state()
	local state_serialized = serialize.serialize(g_state)
	alex_c_api.save_state(g_session_id, state_serialized)
end

function handle_user_clicked(pos_y, pos_x)
	local move = draw.handle_user_clicked(g_state, draw_state, pos_y, pos_x)
	if move ~= nil then
		local rc = core.move(g_state, move.src, move.dst)
		save_state()
	end
	if core.game_won(g_state) and not g_win_anim_shown then
		alex_c_api.set_status_msg("Congratulations, you win!")
		g_win_anim_shown = true
		draw.trigger_win_anim(draw_state, 60)
	end
	draw.draw_state(g_session_id, g_state, draw_state)
end

function load_state_offset(move_offset)
	local state_serialized = alex_c_api.get_saved_state_offset(g_session_id, move_offset)
	g_state = serialize.deserialize(state_serialized)
	g_win_anim_shown = false
	draw_board()
end

function handle_btn_clicked(btn_id)
	if btn_id == draw.BTN_ID_UNDO then
		load_state_offset(-1)
	elseif btn_id == draw.BTN_ID_REDO then
		load_state_offset(1)
	else
		error(string.format("Unhandled btn_id %s", btn_id))
	end
end

function handle_game_option_evt(option_id)
	if option_id == BTN_ID_NEW_GAME then
		g_session_id = alex_c_api.get_new_session_id()
		g_state = core.new_state(11, 3, 4)
		g_win_anim_shown = false
		save_state()
		draw_board()
	else
		error(string.format("Unhandled game option evt id=%s", option_id))
	end
end

function start_game(session_id, state_serialized)
	g_win_anim_shown = false
	if state_serialized ~= nil then
		g_session_id = session_id
		g_state = serialize.deserialize(state_serialized)
		draw_board()
	else
		local prev_session_id = alex_c_api.get_last_session_id()
		print(string.format("Read previous session ID %s", prev_session_id))
		if prev_session_id ~= nil then
			g_session_id = prev_session_id
			state_serialized = alex_c_api.get_saved_state_offset(g_session_id, 0)
			g_state = serialize.deserialize(state_serialized)
			alex_c_api.set_status_msg(string.format("Loaded saved state from session %d", g_session_id))
		else
			g_session_id = alex_c_api.get_new_session_id()
			g_state = core.new_state(11, 3, 4)
		end
	end
end

function get_state()
	return serialize.serialize(g_state)
end

function get_init_state()
	local init_state = core.new_state(11, 3, 4, { seed_x = g_state.seed_x, g_state.seed_y })
	return serialize.serialize(init_state)
end
local serialize = {}

local serialize_lib = require("libs/serialize/serialize")

serialize.VERSION = 2

function serialize.serialize(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(serialize.VERSION)
	output = output .. serialize_lib.serialize_byte(state.num_segments)
	output = output .. serialize_lib.serialize_byte(#state.vials)
	for _, vial in ipairs(state.vials) do
		output = output .. serialize_lib.serialize_byte(#vial)
		for _, seg_val in ipairs(vial) do
			output = output .. serialize_lib.serialize_byte(seg_val)
		end
	end
	output = output .. serialize_lib.serialize_u64(state.seed_x)
	output = output .. serialize_lib.serialize_u64(state.seed_y)

	return output
end

function serialize.deserialize(bytes)
	local state = {}
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local version
	-- version 1, I didn't have a version number for this one,
	-- and had 14 vials with... 4 segments each and 3 empty ones
	-- TODO remove this, there is probably some combination of parameters
	-- where versions > 1 can have the same number of bytes
	if #bytes == 2 + 14 + (14-3)*4 + 4*2 then
		version = 1
	else
		version = serialize_lib.deserialize_byte(bytes)
		if version ~= serialize.VERSION then
			error(string.format("Unhandled fluid_mix serialized state version %d", version))
		end
	end
	state.num_segments = serialize_lib.deserialize_byte(bytes)
	state.vials = {}
	local vial_count   = serialize_lib.deserialize_byte(bytes)
	for _=1,vial_count do
		local segs_in_vial = serialize_lib.deserialize_byte(bytes)
		local vial = {}
		for _=1,segs_in_vial do
			table.insert(vial, serialize_lib.deserialize_byte(bytes))
		end
		table.insert(state.vials, vial)
	end

	if version == 1 then
		-- This is what I did before, but it's wrong-- on wxWidgets at least,
		-- the seed can be greater than 32 bits
		state.seed_x = serialize_lib.deserialize_s32(bytes)
		state.seed_y = serialize_lib.deserialize_s32(bytes)
	elseif version == serialize.VERSION then
		state.seed_x = serialize_lib.deserialize_u64(bytes)
		state.seed_y = serialize_lib.deserialize_u64(bytes)
	end

	assert(#bytes == 0)

	return state
end

return serialize
local go = {}

-- todo rename to go.EMPTY?
local EMPTY   = 0
-- Player1 is black (since black goes first)
go.PLAYER1 = 1
-- Player2 is white (since white goes second)
go.PLAYER2 = 2

function go.player_idx_to_colour_name(idx)
	local map =  {
		[go.PLAYER1] = "black",
		[go.PLAYER2] = "white",
	}
	return map[idx]
end

local Point = {x = 0, y = 0}


function Point:str(self)
	return string.format("(%d,%d)",self.y, self.x)
end

function Point:create (o)
	o.parent = self
	return o
end

function Point:add(arg1, arg2)
	return Point:create{ y = (arg1.y + arg2.y), x = (arg1.x + arg2.x) }
end

local function in_range(game_state, y, x)
	return (1 <= x and x <= game_state.x_max and
	       1 <= y and y <= game_state.y_max)
end


local dirs = {
	Point:create{y = 0, x = 1},
	Point:create{y = 0, x =-1},
	Point:create{y = 1, x = 0},
	Point:create{y =-1, x = 0},
}

local function make_2d_array(y_len,x_len, val)
	local visited = {}
	for y=1,y_len do
		table.insert(visited, {})
		for x=1,x_len do
			table.insert(visited[y], val)
		end
	end
	return visited
end

local function copy_2d_array(ary)
	local to_return = {}
	for y=1, #ary do
		table.insert(to_return, {})
		for x=1, #ary[y] do
			table.insert(to_return[y], ary[y][x])
		end
	end
	return to_return
end

local function has_liberties(game_state, y, x)
	if game_state.board[y][x] == EMPTY then
		error(string.format("has_liberties called on empty point y=%d, x=%d", y, x))
	end

	local this_player = game_state.board[y][x]
	local visited = make_2d_array(game_state.y_max, game_state.x_max, false)
	local to_visit = { Point:create{y=y, x=x}}
	while #to_visit > 0 do
		local pt = table.remove(to_visit)
		if not in_range(game_state, pt.y, pt.x) then
			--continue
			goto next_iter
		elseif game_state.board[pt.y][pt.x] == EMPTY then
			return true
		elseif visited[pt.y][pt.x] then
			-- continue
			goto next_iter
		elseif  game_state.board[pt.y][pt.x] ~= this_player then
			--continue
			goto next_iter
		elseif game_state.board[pt.y][pt.x] == this_player then
			visited[pt.y][pt.x] = true
			for _, dir in ipairs(dirs) do
				local pt2 = Point:add(pt, dir)
				if in_range(game_state, pt2.y, pt2.x) then
					table.insert(to_visit, Point:add(pt, dir))
				end
			end
		end
		::next_iter::
	end
	return false
end

local function clear_piece_group(board, y, x)
	local this_player = board[y][x]
	local visited = make_2d_array(#board, #board[1], false)
	local to_visit = { Point:create{y=y, x=x}}
	while #to_visit > 0 do
		local pt = table.remove(to_visit)
		if not in_range(game_state, pt.y, pt.x) then
			--continue
		elseif board[pt.y][pt.x] == EMPTY then
			-- continue
		elseif visited[pt.y][pt.x] then
			-- continue
		elseif  board[pt.y][pt.x] ~= this_player then
			--continue
		elseif board[pt.y][pt.x] == this_player then
			board[pt.y][pt.x] = EMPTY
			visited[pt.y][pt.x] = true
			for _, dir in ipairs(dirs) do
				local pt2 = Point:add(pt, dir)
				if in_range(game_state, pt2.y, pt2.x) then
					table.insert(to_visit, pt2)
				end
			end
		end
	end
end

local val_to_char = {
	[0] = ' ',
	--[1] = 'x',
	--[2] = 'o',
	[1] = '\x1b[32mx\x1b[0m',
	[2] = '\x1b[33mo\x1b[0m',
}

function go.print_board(board)
	if #board[1] > 9 then
		io.write('  ')
		for x =1, #board[1] do
			local c = ' '
			if x >= 10 then c = string.format('%d', math.floor(x/10)) end
			io.write(string.format('%s ', c))
		end
		io.write('\n')
	end
	io.write('  ')
	for x =1, #board[1] do
		io.write(string.format('%d ', x%10))
	end
	io.write('\n +')
	for x =1, #board[1] do
		io.write('-+')
	end
	io.write('\n')
	for y = 1, #board do
		io.write(string.format('%s|', string.char(string.byte('A')+(y-1))))
		for x = 1, #board[y] do
			local c =  board[y][x]
			io.write( val_to_char[c] )
			io.write('|')
		end
		io.write('\n +')
		for x =1, #board[y] do
			io.write('-+')
		end
		io.write('\n')
	end
end

function go.player_num_to_char(num)
	return val_to_char[num]
end

function go.new_game(size)
	game_state = {
		player_turn = 1,
		y_max = size,
		x_max = size,
		board = make_2d_array(size, size, EMPTY),
		prev_board = nil,
		last_move_y = nil,
		last_move_x = nil,
	}
	return game_state
end

function if_nil_rt_zero(val)
	if val == nil then
		return 0
	else
		return val
	end
end

function go.serialize_state(state)
	if state == nil then return nil end
	local bytes = { }
	bytes[#bytes+1] = string.char(state.player_turn)
	bytes[#bytes+1] = string.char(state.y_max)
	bytes[#bytes+1] = string.char(state.x_max)
	bytes[#bytes+1] = string.char(if_nil_rt_zero(state.last_move_y))
	bytes[#bytes+1] = string.char(if_nil_rt_zero(state.last_move_x))
	for y=1,state.y_max do
		for x=1,state.x_max do
			bytes[#bytes+1] = string.char(state.board[y][x])
		end
	end

	if state.prev_board == nil then
		bytes[#bytes+1] = "x"
	else
		for y=1,state.y_max do
			for x=1,state.x_max do
				if state.prev_board ~= nil then
					bytes[#bytes+1] = string.char(state.prev_board[y][x])
				end
			end
		end
	end
	--print(string.format("Serialized state into %d bytes", #bytes))
	return table.concat(bytes, "")
end

function go.deserialize_state(data)
	local state = {}
	if #data < 3 then
		print(string.format("Bad serialized state received, less than 3 bytes: %d", #data))
		return nil
	end
	print(string.format("len data = %d, data[1] = %q, data[2] = %q, data[3] = %q", #data, data:sub(1,1), data:sub(2,2), data:sub(3,3)))
	state.player_turn = string.byte(data:sub(1,1))
	state.y_max       = string.byte(data:sub(2,2))
	state.x_max       = string.byte(data:sub(3,3))
	state.last_move_y = string.byte(data:sub(4,4))
	state.last_move_x = string.byte(data:sub(5,5))
	local prev_bytes = 5
	if #data ~= prev_bytes + state.y_max * state.x_max + 1 and
	   #data ~= prev_bytes + state.y_max * state.x_max * 2  then
		print(string.format("Bad serialized state, recvd %d bytes, y_max = %d, x_max = %d",
		                    #data, state.y_max, state.x_max))
		return nil
	end
	state.board = make_2d_array(state.y_max, state.x_max, EMPTY)
	local idx = prev_bytes + 1
	for y=1,state.y_max do
		for x=1,state.x_max do
			state.board[y][x] = string.byte(data:sub(idx,idx))
			idx = idx + 1
		end
	end

	if #data < prev_bytes + state.y_max * state.x_max * 2 then
		state.prev_board = nil
	else
		print(string.format("first byte is %q", data:sub(idx,idx)))
		state.prev_board = make_2d_array(state.y_max, state.x_max, EMPTY)
		for y=1,state.y_max do
			for x=1,state.x_max do
				state.prev_board[y][x] = string.byte(data:sub(idx,idx))
				idx = idx + 1
			end
		end
	end
	return state
end

go.SUCCESS        =  0
go.NOT_YOUR_TURN  = -1
go.OUT_OF_RANGE   = -2
go.OCCUPIED       = -3
go.SUICIDE        = -4
go.NOT_ALLOWED_KO = -5

local code_to_str = {
	[go.SUCCESS]        = "Success",
	[go.NOT_YOUR_TURN]  = "Not your turn",
	[go.OUT_OF_RANGE]   = "Position out of range",
	[go.OCCUPIED]       = "Position occupied",
	[go.SUICIDE]        = "Position would be suicidal",
	[go.NOT_ALLOWED_KO] = "Ko rule forbids game returning to this state after two turns",
}

function go.err_code_to_str(code)
	return code_to_str[code]
end


local function boards_eq(board1, board2)
	if board2 == nil and board1 ~= nil then
		return false
	end
	for y=1,#board1 do
		for x=1, #board1[1] do
			if board1[y][x] ~= board2[y][x] then
				return false
			end
		end
	end
	return true
end

local function next_turn(game_state)
	if game_state.player_turn == 1 then
		game_state.player_turn = 2
	elseif game_state.player_turn == 2 then
		game_state.player_turn = 1
	else
		error("invalid player turn")
	end
end

function go.player_move(game_state, player, y, x)
	if game_state == nil or player == nil or y == nil or x == nil then
		error(string.format("go.player_move called with nil args: %s %s %s %s", game_state, player, y, x))
	end
	print(string.format("Attempting to move player %d to y=%d, x=%d", player, y, x))
	local old_board = copy_2d_array(game_state.board)
	if player ~= game_state.player_turn then
		return go.NOT_YOUR_TURN
	end

	if not (1 <= x and x <= game_state.x_max) or
	   not (1 <= y and y <= game_state.y_max) then
		return go.OUT_OF_RANGE
	end

	if game_state.board[y][x] ~= EMPTY then
		return go.OCCUPIED
	end

	game_state.board[y][x] = player

	-- can't check for liberties here, because
	-- it's okay to move to a position where you have no liberties
	-- if you are taking a piece (which results in liberties)
	--if not has_liberties(game_state, y, x) then
	--	game_state.board[y][x] = EMPTY
	--	return go.SUICIDE
	--end

	pt = Point:create{y=y, x=x}
	for _, dir in ipairs(dirs) do
		local pt2 = Point:add(pt, dir)
		if not in_range(game_state, pt2.y, pt2.x) then
			goto next_dir
		end
		local dst = game_state.board[pt2.y][pt2.x]
		if dst == EMPTY or dst == player then
			goto next_dir
		end

		if not has_liberties(game_state, pt2.y, pt2.x) then
			clear_piece_group(game_state.board, pt2.y, pt2.x)
		end
		::next_dir::
	end

	-- is it just the previous state?
	if boards_eq(game_state.board, game_state.prev_board) then
		game_state.board = old_board
		return go.NOT_ALLOWED_KO
	end

	if not has_liberties(game_state, y, x) then
		game_state.board[y][x] = EMPTY
		return go.SUICIDE
	end
	
	next_turn(game_state)

	game_state.prev_board = old_board
	game_state.last_move_y = pt.y
	game_state.last_move_x = pt.x
	return go.SUCCESS
end

function go.player_pass(game_state, player)
	if player ~= game_state.player_turn then
		return go.NOT_YOUR_TURN
	end

	next_turn(game_state)
	return go.SUCCESS
end

return go
local go_ctrl = {}
-- This file should contain the state for things like deciding
-- if players have been chosen yet (whether the player choice UI should be shown),
-- and what player you are

function go_ctrl.new_state()
	return {
		player_choice = nil,
		other_player_choice = nil,
	}
end

function go_ctrl.player_chosen(ctrl_state, player_idx)
	print(string.format("Storing player choice of %q", player_idx))
	ctrl_state.player_choice = player_idx
end

function go_ctrl.other_player_chosen(ctrl_state, player_idx)
	ctrl_state.other_player_choice = player_idx
end

function go_ctrl.get_player(ctrl_state)
	return ctrl_state.player_choice
end

function go_ctrl.get_other_player(ctrl_state)
	return ctrl_state.other_player_choice
end

return go_ctrl
local two_player = require("libs/multiplayer/two_player")
local utils      = require("libs/utils")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local go      = require("games/go/go_core")
local go_ui   = require("games/go/go_ui")
local go_ctrl = require("games/go/go_ctrl")

local alex_c_api = require("alex_c_api");

-- e.g. either 9x9, 13x13, or 19x19
local go_game_size = 19
local local_multiplayer = nil
local session_id = alex_c_api.get_new_session_id()
local state = go.new_game(go_game_size)

-- state was received either from another player or
-- explicitly loaded
local state_init = false

-- if this is true, then the user explicitly loaded saved state from
-- URL or history browser, don't prompt them to start a new game
local state_loaded = false

local ctrl_state = go_ctrl.new_state()
-- TODO have a C API to get height/width of canvas, or maybe
-- set it?
local height = 480
local width = 480
go_ui.init_ui(session_id, go_game_size, width, height)
alex_c_api.send_message("all", "get_state:")
alex_c_api.set_status_msg("Choose piece colour")

local PLAYER_CHOICE_POPUP_ID = "choose_player_colour"
local PLAYER_CHOICE_BTNS = {
	"Black",
	"White",
}
local PLAYER_CHOICE_BTNS_MAP = {
	[0] = go.PLAYER1,
	[1] = go.PLAYER2,
}

local POPUP_ID_GAME_SIZE_SELECTION = "game_size_sel"
local POPUP_GAME_SIZE_SEL_BTNS = {
	"9x9",
	"13x13",
	"19x19",
}
local POPUP_GAME_SIZE_SEL_BTNS_TO_SIZE = {
	9, 13, 19
}


local POPUP_ID_START_NEW_GAME_PROMPT = "new_game_prompt"
local POPUP_GAME_SIZE_NEW_GAME_PROMPT = {
	"Start new game",
	"Continue saved game",
}

local function get_player()
	if local_multiplayer then
		return state.player_turn
	else
		return go_ctrl.get_player(ctrl_state)
	end
end

local PLAYER_IDX_TO_BTN_IDX_MAP = utils.reverse_map(PLAYER_CHOICE_BTNS_MAP)

local OPTION_ID_NEW_GAME = "opt_new_game"

-- maps player IP/name to player ID
local player_name_to_id = {
}

-- adding test for ko
--[[
state.board = {
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{ 0, 0, 0, 0, 1, 2, 0, 0, 0},
	{ 0, 0, 0, 1, 0, 1, 2, 0, 0},
	{ 0, 0, 0, 0, 1, 2, 0, 0, 0},
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0},
}
--]]

function handle_user_string_input(row_col)
	local m = row_col:gmatch"(%a+)%s*(%d+)"
	-- todo raise error if inputs like "aaa5" are given (currently this is interpreted as "a5")
	local row
	local col
	row, col = m()
	if row == nil or col == nil then
		return nil
	end
	col = tonumber(col)
	row = string.byte(row:upper()) - string.byte('A') + 1
	local rc = go.player_move(state, get_player(), row, col)
	return rc
end

function draw_board() 
	if state ~= nil then
		go_ui.draw_board(session_id, state.board, state.last_move_y, state.last_move_x)
	end
end

function get_user_input()
	io.write(string.format("Move player %d (%s), enter row letter and column number (e.g. \"E5\")>> ",
		state.player_turn, go.player_num_to_char(state.player_turn)))
	local s = io.read("*l")
	return s
end

local function save_state()
	alex_c_api.save_state(session_id, go.serialize_state(state))
end

function get_state()
	return go.serialize_state(state)
end

function handle_user_clicked(pos_y, pos_x)
	local pos = go_ui.user_pos_to_piece_idx(pos_y, pos_x)
	local player = get_player()
	local rc = go.player_move(state, player, pos.y, pos.x)
	if rc == go.SUCCESS then
		if not local_multiplayer then
			alex_c_api.send_message("all", string.format("move:%d,%d,%d", player, pos.y, pos.x));
			alex_c_api.set_status_err("")
		end
		save_state()
	else
		alex_c_api.set_status_err(go.err_code_to_str(rc))
	end
	draw_board()
	update_status_msg_turn(state, ctrl_state)
end

local function broadcast_state()
	alex_c_api.send_message("all", "state:"..go.serialize_state(state))
end

local function set_state(state_arg)
	print("set_state called")
	state_init = true
	state = state_arg
end

function handle_msg_received(src, msg)
	print("handle_msg_received (from src:" .. src .. "): " .. msg);

	if local_multiplayer then
		return
	end

	if two_player.handle_msg_received(src, msg) then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "move" then
		local m = payload:gmatch"(%d+),(%d+),(%d+)"
		local player, row, col
		player, row, col = m()
		player = tonumber(player)
		row = tonumber(row)
		col = tonumber(col)
		print(string.format("Received player=%s, row=%s, col=%d", player, row, col))

		if player == go_ctrl.get_player(ctrl_state) then
			-- TODO make UI visible message for this case?
			print(string.format("Received message for move from wrong player"))
			return
		end
		go.player_move(state, player, row, col)
		alex_c_api.set_status_err("")
		draw_board()
		update_status_msg_turn(state, ctrl_state)
		save_state()
	elseif header == "get_state" then
		broadcast_state()
	elseif header == "state" then
		local new_state = go.deserialize_state(payload)
		-- TODO check with user if they want to overwrite their state with
		-- this (possibly unsolicited!!) state from the other player
		set_state(new_state)
		if go_ui.get_board_piece_size() ~= #new_state.board then
			go_ui.set_board_piece_size(#new_state.board)
		end
		draw_board()
		alex_c_api.set_status_err("")
		update_status_msg_turn(state, ctrl_state)
	elseif header == "player_left" and src == "ctrl" then
		-- do nothing
	else
		print("Unexpected message header: \""..header.."\"")
	end
end

local function load_saved_state_offset(move_id_offset)
	local serialized_state = alex_c_api.get_saved_state_offset(session_id, move_id_offset)
	if serialized_state == nil then
		error(string.format("get_saved_state_offset(offset=%d) returned nil", move_id_offset))
	end
	internal_load_state(session_id, serialized_state)
	draw_board()
end

local function handle_pass(player)
	local rc = go.player_pass(state, player)
	if rc ~= go.SUCCESS then
		alex_c_api.set_status_err(go.err_code_to_str(rc))
	else
		draw_board()
		save_state()
		update_status_msg_turn(state, ctrl_state)

		-- TODO This is lazy, I should implement a string to indicate this move
		broadcast_state()
	end
end

function handle_btn_clicked(btn_id)
	print("handle_btn_clicked: "..btn_id)
	if btn_id == go_ui.BTN_ID_UNDO then
		load_saved_state_offset(-1)
		broadcast_state()
	elseif btn_id == go_ui.BTN_ID_REDO then
		load_saved_state_offset(1)
		broadcast_state()
	elseif btn_id == go_ui.BTN_ID_PASS then
		local player = get_player()
		handle_pass(player)
	else
		error(string.format("Unhandled button pressed \"%s\"", btn_id))
	end
end

local function get_player_name(player_arg)
	for name, player_idx in pairs(player_name_to_id) do
		if player_arg == player_idx then return name end
	end
	return "nil"
end

function update_status_msg_turn(state, ctrl_state)
	if state == nil then return end

	local display_name = go.player_idx_to_colour_name(state.player_turn)
	if not local_multiplayer then
		display_name = string.format("%s (%s)", display_name, get_player_name(state.player_turn))
	end
	alex_c_api.set_status_msg(string.format("Waiting for %s to move", display_name))
	print(string.format("State is now: %s", utils.binstr_to_hr_str(go.serialize_state(state))))
end

function handle_popup_btn_clicked(popup_id, btn_idx)
	if two_player.handle_popup_btn_clicked(popup_id, btn_idx) then
		-- handled, no action here
	elseif popup_id == POPUP_ID_GAME_SIZE_SELECTION then
		local desired_game_size = POPUP_GAME_SIZE_SEL_BTNS_TO_SIZE[btn_idx+1]
		alex_c_api.hide_popup()
		alex_c_api.set_status_msg(string.format("Setting board size to %s", desired_game_size))
		set_state(go.new_game(desired_game_size))
		go_ui.set_board_piece_size(desired_game_size)
		print(string.format("state.board: %s", state.board))
		draw_board()
		broadcast_state()
	elseif popup_id == POPUP_ID_START_NEW_GAME_PROMPT then
		if btn_idx == 0 then
			state_init = false
			prompt_game_size()
		elseif btn_idx == 1 then
			alex_c_api.hide_popup()
		else
			error(string.format("popup btn_idx %s not handled for start new game prompt", btn_idx))
		end
	else
		print(string.format("Unexpected popup_id \"%s\"", popup_id));
		alex_c_api.hide_popup()
	end
end

-- "internal" means "not called by game engine", it should
-- only be called by other functions within this file.
-- Originally I had a "load_state" function as part of the API,
-- but I combined it with start_game. So I'm changing this name to
-- avoid confusing myself when grepping to see if I updated all the games.
function internal_load_state(session_id_arg, serialized_state)
	session_id = session_id_arg
	local loaded_state = go.deserialize_state(serialized_state)
	go_ui.set_board_piece_size(#loaded_state.board)
	state_loaded = true
	set_state(loaded_state)
end

local function prompt_new_game()
	show_buttons_popup.show_popup(POPUP_ID_START_NEW_GAME_PROMPT, "Start new game",
	                              "Start a new game, or load saved state?",
	                              POPUP_GAME_SIZE_NEW_GAME_PROMPT)
end

local function prompt_game_size()
	-- if previous state was already loaded, then don't prompt game size and overwrite 
	-- the loaded game
	if state_init and state_loaded then
		return
	end

	if not state_init then
		show_buttons_popup.show_popup(POPUP_ID_GAME_SIZE_SELECTION, "Choose game size",
		                              "Choose one of the below game sizes.",
		                              POPUP_GAME_SIZE_SEL_BTNS)
	end
end

function two_player_init()
	local args = {
		title = "Choose piece colour",
		supports_local_multiplayer = true,
		player_choices = PLAYER_CHOICE_BTNS,
		handle_multiplayer_type_choice = function (multiplayer_type)
			if multiplayer_type == two_player.MULTIPLAYER_TYPE_LOCAL then
				local_multiplayer = true
				prompt_game_size()
			elseif multiplayer_type == two_player.MULTIPLAYER_TYPE_NETWORK then
				local_multiplayer = false
			end
		end,
		choice_id_to_player_id = function (btn_id)
			return PLAYER_CHOICE_BTNS_MAP[btn_id]
		end,
		player_name_to_id = player_name_to_id,
		player_id_to_nice_name = function (player_id)
			local player_colour = go.player_idx_to_colour_name(player_id)
			return utils.make_first_char_uppercase(player_colour)
		end,
		get_msg = function ()
			local msg = "Black moves first."
			--local other_player = go_ctrl.get_other_player(ctrl_state)
			if utils.table_len(player_name_to_id) == 0 then
				msg = msg .. "\nThe other player has not yet chosen."
			else
				--msg = msg .. string.format("The other player has chosen %s",
				--                           go.player_idx_to_colour_name(other_player))
				for player_name, player_id in pairs(player_name_to_id) do
					local player_colour = go.player_idx_to_colour_name(player_id)
					msg = msg .. string.format("\n%s is chosen by %s", utils.make_first_char_uppercase(player_colour), player_name)
				end
			end
			return msg
		end,
		handle_player_choice = function (player_name, player_id)
			local choice_str = go.player_idx_to_colour_name(player_id)
			print(string.format("handle_player_choice{ player_name=\"%s\", choice=%q (%q) }", player_name, player_id, choice_str))
			if player_name == two_player.LOCAL_PLAYER then
				go_ctrl.player_chosen(ctrl_state, player_id)
				update_status_msg_turn(state, ctrl_state)
			else
				go_ctrl.other_player_chosen(ctrl_state, player_id)

			end

			if player_name == two_player.LOCAL_PLAYER and go_ctrl.get_other_player(ctrl_state) == nil then
				prompt_game_size()
			end
			print(string.format("we are %q, other player is %q",
			      go_ctrl.get_player(ctrl_state), go_ctrl.get_other_player(ctrl_state)))
		end,

		need_reselect = function ()
			local this_player  = go_ctrl.get_player(ctrl_state)
			local other_player = go_ctrl.get_other_player(ctrl_state)

			-- print(string.format("needs_reselect { this_player = %q, other_player = %q }", this_player, this_player == other_player))
			return this_player == nil or this_player == other_player
		end,

		get_local_player_choice = function ()
			return go_ctrl.get_player(ctrl_state)
		end
	}

	two_player.init(args)
end

function handle_game_option_evt(option_id)
	if option_id == OPTION_ID_NEW_GAME then
		-- TODO remove these bools, this is ugly. At least do the check outside of
		-- where the function is called
		state_init = false
		state_loaded = false
		prompt_game_size()
	else
		error(string.format("Unhandled option_id %s", option_id))
	end
end

function start_game(session_id, state_serialized)
	if state_serialized ~= nil then
		internal_load_state(session_id, state_serialized)
	else
		local session_id = alex_c_api.get_last_session_id()
		if session_id ~= nil then
			state_serialized = alex_c_api.get_saved_state_offset(session_id, 0)
			internal_load_state(session_id, state_serialized)
		end
	end

	-- Note that this sets who the player on this device is,
	-- and without it, the player arg is nil and the game can't progress
	two_player_init()

	alex_c_api.add_game_option(OPTION_ID_NEW_GAME, { type = alex_c_api.OPTION_TYPE_BTN, label = "New Game"})
end

function lua_main()
	while true do
		print_board()
		::read_input::
		local user_input = get_user_input()
		local rc = handle_user_string_input(user_input)
		if rc ~= go.SUCCESS then
			print('Error: '.. go.err_code_to_str(rc))
			goto read_input
		end
	end
end
local go_ui = {}
local go    = require("games/go/go_core")
local draw_more = require("libs/draw/draw_more")
local alex_c_api = require("alex_c_api");

local board_line_size = 2

local board_size = nil
local height = nil
local width = nil
local piece_space_size = nil
local board_piece_size = nil

go_ui.BTN_ID_UNDO = "undo"
go_ui.BTN_ID_REDO = "redo"
go_ui.BTN_ID_PASS = "pass"

local function update_undo_redo_btns(session_id)
	alex_c_api.set_btn_enabled(go_ui.BTN_ID_UNDO, alex_c_api.has_saved_state_offset(session_id, -1))
	alex_c_api.set_btn_enabled(go_ui.BTN_ID_REDO, alex_c_api.has_saved_state_offset(session_id,  1))
end

function go_ui.get_board_piece_size()
	return board_piece_size
end

function go_ui.set_board_piece_size(board_piece_size_arg)
	board_piece_size = board_piece_size_arg
	piece_space_size = board_size*1.0/(board_piece_size+1)
end

function go_ui.init_ui(session_id, board_piece_size_arg, screen_width, screen_height)
	board_size = math.min(screen_width, screen_height)
	height = screen_height
	width  = screen_width
	go_ui.set_board_piece_size(board_piece_size_arg)

	alex_c_api.create_btn(go_ui.BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(go_ui.BTN_ID_REDO, "Redo", 1)
	alex_c_api.create_btn(go_ui.BTN_ID_PASS, "Pass", 2)
	alex_c_api.set_btn_enabled(go_ui.BTN_ID_UNDO, false)
	alex_c_api.set_btn_enabled(go_ui.BTN_ID_REDO, false)

	update_undo_redo_btns(session_id)
end

function go_ui.draw_board(session_id, board, last_y, last_x)

	alex_c_api.draw_clear()

	draw_more.draw_graphic_ul("board", 0, 0, board_size, board_size)

	local piece_size = piece_space_size*0.90
	piece_size = math.floor(piece_size)

	for i=0, board_piece_size-1 do
		local y1 = piece_space_size
		local y2 = board_size - piece_space_size
		local x1 = piece_space_size*(i+1)
		local x2 = x1
		alex_c_api.draw_line("#000000", board_line_size, y1, x1, y2, x2)
	end

	for i=0, board_piece_size-1 do
		local x1 = piece_space_size
		local x2 = board_size - piece_space_size
		local y1 = piece_space_size*(i+1)
		local y2 = y1
		alex_c_api.draw_line("#000000", board_line_size, y1, x1, y2, x2)
	end

	for y_idx=0, board_piece_size-1 do
		for x_idx=0, board_piece_size-1 do
			local y_pos = piece_space_size/2 + y_idx * piece_space_size
			local x_pos = piece_space_size/2 + x_idx * piece_space_size
			local img_id = nil
			if y_idx > #board or x_idx > #board[1] then
				error(string.format("draw_board: {y=%d, x=%d} out of range of board size {y=%d,x=%d}", y_idx+1, x_idx+1, #board, #board[1]))
			end
			local piece_type = board[y_idx+1][x_idx+1]
			-- TODO replace 1 and 2 with go.PLAYER1 and go.PLAYER2
			if piece_type == go.PLAYER1 then
				img_id = "piece_black"
			elseif piece_type == go.PLAYER2 then
				img_id = "piece_white"
			end
			if img_id ~= nil then
				draw_more.draw_graphic_ul(img_id, y_pos, x_pos, math.floor(piece_size), math.floor(piece_size))
			end


			if y_idx+1 == last_y and x_idx+1 == last_x then
				draw_more.draw_graphic_ul("piece_highlight", y_pos, x_pos, math.floor(piece_size), math.floor(piece_size))
			end
		end
	end

	alex_c_api.draw_refresh()
	update_undo_redo_btns(session_id)
end

function go_ui.user_pos_to_piece_idx(pos_y, pos_x)
	local y_idx = math.floor((pos_y - piece_space_size/2)/piece_space_size) + 1
	local x_idx = math.floor((pos_x - piece_space_size/2)/piece_space_size) + 1
	local to_return = {
		y = y_idx,
		x = x_idx
	}
	return to_return
end

return go_ui
local core = {}

local PLAYER_MOVE_SPEED = 3.0/1000

core.ITEM_ID_PLAYER         =  1
core.ITEM_ID_PATIENT_IN_BED =  2
core.ITEM_ID_PATIENT_IN_BED_FLIPPED = 3
core.ITEM_ID_BED            =  4
core.ITEM_ID_BED_FLIPPED    =  5
core.ITEM_ID_BED_SEGMENT_2  =  6
core.ITEM_ID_IV_BAG         =  7
core.ITEM_ID_DEFIB          =  8
core.ITEM_ID_VENTILATOR     =  9
core.ITEM_ID_XRAY_SHEET     = 10
core.ITEM_ID_XRAY_SOURCE    = 11

core.NEEDS_LOW_FLUIDS   = 1
core.NEEDS_LOW_OXYGEN   = 2
core.NEEDS_NO_HEARTBEAT = 3
core.NEEDS_BROKEN_BONE  = 4


core.ACTION_DIR_PAD_POS_CHANGE  = 1
core.ACTION_USE_BTN_DOWN        = 2
core.ACTION_USE_BTN_RELEASE     = 3
core.ACTION_DROP_BTN_DOWN       = 4
core.ACTION_DROP_BTN_RELEASE    = 5

core.USING_ACTION_REVEAL_NEEDS = 1
core.USING_ACTION_LOW_FLUIDS   = 2
core.USING_ACTION_DEFIB        = 3
core.USING_ACTION_VENTILATOR   = 4
core.USING_ACTION_PICK_UP_PATIENT = 5
core.USING_ACTION_PUT_PATIENT_IN_BED = 6

core.EVT_PATIENT_NEED_EXPIRED = 1
core.EVT_PATIENT_CURED        = 2

core.USE_PROGRESS_MAX = 100

local TIME_TO_REVEAL_NEEDS    = 1.0
local TIME_TO_PICK_UP_PATIENT = 0.7

local NEED_LIST = {
	core.NEEDS_LOW_FLUIDS,
	core.NEEDS_NO_HEARTBEAT,
	core.NEEDS_LOW_OXYGEN,
	core.NEEDS_BROKEN_BONE,
}

local NEEDS_TO_USE_TIME_MAP = {
	[core.NEEDS_LOW_FLUIDS]   = 2.5,
	[core.NEEDS_NO_HEARTBEAT] = 1.5,
	[core.NEEDS_LOW_OXYGEN]   = 2.5,
}

local NEED_TO_BED_FIX_TIME_MS = {
	[core.NEEDS_BROKEN_BONE] = 20*1000,
}


local NEEDS_TO_ITEMS_MAP = {
		[core.NEEDS_LOW_FLUIDS]    = { core.ITEM_ID_IV_BAG     },
		[core.NEEDS_NO_HEARTBEAT]  = { core.ITEM_ID_DEFIB      },
		[core.NEEDS_LOW_OXYGEN]    = { core.ITEM_ID_VENTILATOR },
		[core.NEEDS_BROKEN_BONE]   = { },
}

local ITEMS_DROPPED_ON_USE_MAP = {
	[core.ITEM_ID_IV_BAG] = true,
	[core.ITEM_ID_VENTILATOR] = true,
}

-- These seem good for one player...
-- rough ideas, should be sum of:
--    * time to reveal max-ish number of patients that could reasonably need to have
--      their needs revealed at any given time, plus
--    * time to walk halfway across the map, plus
--    * time to fix patient with equipment 
local NEED_TYPE_TO_TIME_LEFT = {
	[core.NEEDS_LOW_FLUIDS]   = 60,
	[core.NEEDS_NO_HEARTBEAT] = 25,
	[core.NEEDS_LOW_OXYGEN]   = 40,
	[core.NEEDS_BROKEN_BONE]  = 90,
}


local DIRS = {
	{ y =  1, x =  0 },
	{ y =  1, x = -1 },
	{ y =  0, x = -1 },
	{ y = -1, x = -1 },
	{ y = -1, x =  0 },
	{ y = -1, x =  1 },
	{ y =  0, x =  1 },
	{ y =  1, x =  1 },
}

local PICK_UP_ITEMS = {
	[core.ITEM_ID_IV_BAG]     = true,
	[core.ITEM_ID_DEFIB]      = true,
	[core.ITEM_ID_VENTILATOR] = true,
}


local function get_player_starting_pos(i)
	--[[
	local map = {
		[1] = { y = 2.5, x = 2.5 },
		[2] = { y = 7.5, x = 7.5 },
		[3] = { y = 7.5, x = 2.5 },
		[4] = { y = 2.5, x = 7.5 },
	}
	]]

	local map = {
		[1] = { y = 2.5, x = 5.0 },
		[2] = { y = 7.5, x = 5.0 },
		[3] = { y = 5.0, x = 2.5 },
		[4] = { y = 5.0, x = 7.5 },
	}
	return map[i]
end

local function new_item(id)
	return {
		id = id,
	}
end

local function new_bed(id, fixes_needs)
	local item = new_item(id)
	if not core.is_bed(item) then
		error(string.format("Item id %s is not bed", id), 2)
	end
	item.fixes_needs = fixes_needs
	return item
end

local needs_type_debug = 0


function core.is_patient(item_info)
	if item_info == nil then
		error("arg is nil", 2)
	end
	return item_info.id == core.ITEM_ID_PATIENT_IN_BED or
	       item_info.id == core.ITEM_ID_PATIENT_IN_BED_FLIPPED
end

function core.is_player(item_info)
	return item_info.id == core.ITEM_ID_PLAYER
end

function core.is_bed(item_info)
	return item_info.id == core.ITEM_ID_BED or
	       item_info.id == core.ITEM_ID_BED_FLIPPED
end

local function new_patient(y, x)
	needs_type_debug = needs_type_debug + 1
	return {
		id = core.ITEM_ID_PATIENT_IN_BED,
		y = y,
		x = x,

		requires_help  = false,
		needs_revealed = false,
		needs_type     = needs_type_debug,

		time_left      = nil,
		orig_time_left = nil,

		held_by        = nil,
	}
end

local function set_patient_need(patient, need_type)
	patient.requires_help  = true
	patient.needs_revealed = false
	patient.needs_type     = need_type
	patient.time_left      = NEED_TYPE_TO_TIME_LEFT[need_type]
	patient.orig_time_left = NEED_TYPE_TO_TIME_LEFT[need_type]
end

local function load_level1(state)
	-- TODO put xray room in top left or top right,
	-- so that it's easier to see
	local level_map = {
		--0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},   -- 0
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},   -- 1
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},   -- 2
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},   -- 3
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},   -- 4
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},   -- 5
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},   -- 6
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1},   -- 7
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},   -- 8
		{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},   -- 9
		--{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   -- 0
		--{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},   -- 1
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 2
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 3
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 4
		--{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},   -- 5
	}

	for row_idx, row in ipairs(level_map) do
		local y = row_idx-1
		state.cells[y] = {}
		for col_idx, cell in ipairs(row) do
			local x = col_idx-1
			if level_map[row_idx][col_idx] == 1 then
				state.cells[y][x] = {}
			end
		end
	end

	local level_items = {
		{ y = 2, x = 1, item = new_bed(core.ITEM_ID_BED_FLIPPED) },
		{ y = 1, x = 1, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },
		{ y = 2, x = 4, item = new_bed(core.ITEM_ID_BED_FLIPPED) },
		{ y = 1, x = 4, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },
		{ y = 2, x = 7, item = new_bed(core.ITEM_ID_BED_FLIPPED) },
		{ y = 1, x = 7, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },

		{ y = 2, x = 1, item = new_item(core.ITEM_ID_PATIENT_IN_BED) },
		{ y = 2, x = 4, item = new_item(core.ITEM_ID_PATIENT_IN_BED) },
		{ y = 2, x = 7, item = new_item(core.ITEM_ID_PATIENT_IN_BED) },

		{ y = 7, x = 1, item = new_bed(core.ITEM_ID_BED) },
		{ y = 6, x = 1, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },
		{ y = 7, x = 4, item = new_bed(core.ITEM_ID_BED) },
		{ y = 6, x = 4, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },
		{ y = 7, x = 7, item = new_bed(core.ITEM_ID_BED) },
		{ y = 6, x = 7, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },

		{ y = 7, x = 1, item = new_item(core.ITEM_ID_PATIENT_IN_BED_FLIPPED) },
		{ y = 7, x = 4, item = new_item(core.ITEM_ID_PATIENT_IN_BED_FLIPPED) },
		{ y = 7, x = 7, item = new_item(core.ITEM_ID_PATIENT_IN_BED_FLIPPED) },

		{ y = 1, x = 2, item = new_item(core.ITEM_ID_IV_BAG) },
		{ y = 7, x = 5, item = new_item(core.ITEM_ID_IV_BAG) },
		{ y = 1, x = 6, item = new_item(core.ITEM_ID_IV_BAG) },

		{ y = 7, x = 8, item = new_item(core.ITEM_ID_DEFIB) },
		{ y = 7, x = 2, item = new_item(core.ITEM_ID_VENTILATOR) },


		{ y = 3, x = 14, item = new_item(core.ITEM_ID_XRAY_SOURCE) },
		{ y = 4, x = 14, item = new_item(core.ITEM_ID_BED_SEGMENT_2) },
		{ y = 5, x = 14, item = new_bed(core.ITEM_ID_BED_FLIPPED, {core.NEEDS_BROKEN_BONE}) },
		{ y = 6, x = 14, item = new_item(core.ITEM_ID_XRAY_SHEET) },
	}

	for _, item_info in ipairs(level_items) do
		if core.is_patient(item_info.item) then
			local patient_info = new_patient(item_info.y, item_info.x)
			table.insert(state.patients, patient_info)
			table.insert(state.cells[item_info.y][item_info.x], patient_info)
		else
			table.insert(state.cells[item_info.y][item_info.x], item_info.item)
		end
	end

	set_patient_need(state.patients[1], core.NEEDS_BROKEN_BONE)
	set_patient_need(state.patients[2], core.NEEDS_LOW_FLUIDS)
end

local function add_player(state, player_idx, pos_y, pos_x)
	local player_item = new_item(core.ITEM_ID_PLAYER)
	player_item.player_idx = player_idx
	table.insert(state.cells[math.floor(pos_y)][math.floor(pos_x)], player_item)
	state.players[player_idx] = {
		y = pos_y,
		x = pos_x,
		vel_y = 0,
		vel_x = 0,
		use_btn_down  = false,
		drop_btn_down = false,
		holding = nil,
		is_using = false,
		use_progress = 0,
		use_time     = nil,
	}
end

function core.init(game_params)
	local state = {
		y_size  = game_params.y_size,
		x_size  = game_params.x_size,
		cells   = {},
		patients = {},
		players = {},

		-- 15 seconds was a bit too hard for just one player
		new_sickness_period = 18*1000,
		time_to_new_sickness  = nil,
		new_sickness_count    = 2,
	}
	state.time_to_new_sickness = state.new_sickness_period

	-- print("loading level 1...")
	load_level1(state)


	for i=1,game_params.num_players do
		local pos = get_player_starting_pos(i)
		add_player(state, i, pos.y, pos.x)
	end


	return state
end

function core.handle_player_dirpad_update(state, player, vec_y, vec_x)

	if vec_y ~= 0 or vec_x ~= 0 then
		-- TODO could probably simplify this with a trig identity?
		local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)
		local angle = math.atan(vec_y, vec_x)
		angle = angle - math.pi/4
		
		vec_y = mag * math.sin(angle)
		vec_x = mag * math.cos(angle)
	end

	state.players[player].vel_y = vec_y * PLAYER_MOVE_SPEED
	state.players[player].vel_x = vec_x * PLAYER_MOVE_SPEED
end

function core.handle_player_use_btn(state, player, btn_down)
	local player_state = state.players[player]
	player_state.use_btn_down = btn_down
	if btn_down then
		return core.use_start(state, player)
	else
		return core.use_stop(state, player)
	end
end

function core.handle_player_drop_btn(state, player, btn_down)
	local player_state = state.players[player]
	player_state.drop_btn_down = btn_down
	if btn_down then
		if player_state.holding ~= nil and
		   not core.is_patient(player_state.holding) then
			core.drop_item(state, player)
		end
	end
end

local function clip_min_max(min_val, max_val, val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end

local function is_collision(state, player_idx, tentative_y, tentative_x)
	local tentative_y_idx = math.floor(tentative_y)
	local tentative_x_idx = math.floor(tentative_x)

	-- If we'are already in this cell-- let the player walk through it to escape.
	-- Otherwise they would be completely trapped
	if tentative_y_idx == math.floor(state.players[player_idx].y) and
	   tentative_x_idx == math.floor(state.players[player_idx].x) then
		return false
	end

	if state.cells[tentative_y_idx] == nil or
	   state.cells[tentative_y_idx][tentative_x_idx] == nil then
		return true
	elseif #state.cells[tentative_y_idx][tentative_x_idx] == 0 then
		return false
	elseif #state.cells[tentative_y_idx][tentative_x_idx] == 1 then
		local item_info = state.cells[tentative_y_idx][tentative_x_idx][1]
		return not (item_info.id == core.ITEM_ID_PLAYER and item_info.player_idx == player_idx)
	else
		-- more than one item in dst, so must be collision
		return true
	end
		
end

local function move_player(state, player_idx, pos_y, pos_x)
	local player_state = state.players[player_idx]
	local old_y_idx = math.floor(player_state.y)
	local old_x_idx = math.floor(player_state.x)
	local new_y_idx = math.floor(pos_y)
	local new_x_idx = math.floor(pos_x)
	player_state.y = pos_y
	player_state.x = pos_x

	if old_y_idx ~= new_y_idx or
	   old_x_idx ~= new_x_idx then
		local old_cell = state.cells[old_y_idx][old_x_idx]
		local player_tbl_idx = nil
		for idx, item_info in ipairs(old_cell) do
			if item_info.id == core.ITEM_ID_PLAYER and item_info.player_idx == player_idx then
				player_tbl_idx = idx
				goto found_elem
			end
		end
		::found_elem::

		local item_info = table.remove(old_cell, player_tbl_idx)
		table.insert(state.cells[new_y_idx][new_x_idx], item_info)
	end
end

local function player_can_move(player_state)
	return not player_state.is_using
end

function core.update_state(state, dt)
	local events = {}
	for player_idx, player_state in ipairs(state.players) do

		if player_can_move(player_state) then
			local tentative_y = player_state.y + player_state.vel_y * dt
			local tentative_x = player_state.x + player_state.vel_x * dt

			-- Try to move to the new position.
			-- If it is blocked, try moving in just the y direction, or just the x direction
			if not is_collision(state, player_idx, tentative_y, tentative_x) then
				move_player(state, player_idx, tentative_y, tentative_x)
				player_state.y = tentative_y
				player_state.x = tentative_x
			elseif not is_collision(state, player_idx, tentative_y, player_state.x) then
				move_player(state, player_idx, tentative_y, player_state.x)
				player_state.y = tentative_y
			elseif not is_collision(state, player_idx, player_state.y, tentative_x) then
				move_player(state, player_idx, player_state.y, tentative_x)
				player_state.x = tentative_x
			end
		end

		if player_state.is_using then
			player_state.use_progress = player_state.use_progress + (dt/1000.0/player_state.use_time)*core.USE_PROGRESS_MAX
			if player_state.use_progress >=	core.USE_PROGRESS_MAX then
				player_state.use_progress = core.USE_PROGRESS_MAX
				core.on_use_complete_func(state, player_idx, events)
			end
		end
	end

	for _, patient in ipairs(state.patients) do
		if patient.requires_help then
			if patient.fix_time ~= nil then
				patient.fix_time = patient.fix_time - dt
				if patient.fix_time <= 0 then
					table.insert(events, {
						event = core.EVT_PATIENT_CURED,
						patient = patient,
					})
					patient.requires_help  = false
					patient.needs_revealed = false
					patient.needs_type     = nil
					patient.time_left      = nil
					patient.orig_time_left = nil
					patient.fix_time       = nil
					patient.orig_fix_time  = nil
					goto next_patient
				end
				
			end
			patient.time_left = patient.time_left - dt / 1000.0
			if patient.time_left <= 0 then
				patient.time_left = 0
				table.insert(events, {
					event = core.EVT_PATIENT_NEED_EXPIRED,
					patient = patient,
				})
				patient.requires_help  = false
				patient.needs_revealed = false
				patient.needs_type     = nil
				patient.time_left      = nil
				patient.orig_time_left = nil
				patient.fix_time       = nil
				patient.orig_fix_time  = nil
			end
		end
		::next_patient::
	end

	state.time_to_new_sickness = state.time_to_new_sickness - dt
	if state.time_to_new_sickness <= 0 then
		state.time_to_new_sickness = state.new_sickness_period
		local healthy_patients = {}
		for _, patient in ipairs(state.patients) do
			if not patient.requires_help then
				table.insert(healthy_patients, patient)
			end
		end
		for _=1,state.new_sickness_count do
			if #healthy_patients > 0 then
				local idx = math.random(#healthy_patients)
				set_patient_need(healthy_patients[idx], NEED_LIST[math.random(#NEED_LIST)])
				table.remove(healthy_patients, idx)
			end
		end
	end

	return events
end

function core.get_item_needs_type(item_id)
	local map = {
		[core.ITEM_ID_IV_BAG]        = core.NEEDS_LOW_FLUIDS,
		[core.ITEM_ID_DEFIB]         = core.NEEDS_NO_HEARTBEAT,
		[core.ITEM_ID_VENTILATOR]    = core.NEEDS_LOW_OXYGEN,

	}
	return map[item_id]
end

local function in_range_coords(state, y, x)
	return state.cells[y] ~= nil and state.cells[y][x] ~= nil
end

local function item_id_can_be_picked_up(item_id)
	return PICK_UP_ITEMS[item_id] == true
end


local function ary_contains(ary, elem)
	for _, val in ipairs(ary) do
		if val == elem then return true end
	end
	return false
end

local function patient_can_be_interacted(player_state, patient_info)
	if patient_info.requires_help then
		if not patient_info.needs_revealed then
			return true
		else
			if player_state.holding ~= nil and
			       ary_contains(NEEDS_TO_ITEMS_MAP[patient_info.needs_type], player_state.holding.id) then
				return true
			elseif patient_info.needs_type == core.NEEDS_BROKEN_BONE and
			       -- don't let the player pick up a patient if they are already holding one...
			       -- unless the patients should be swapped? That might be an option in the future
			       (player_state.holding == nil or not core.is_patient(player_state.holding)) then
				return true
			end
		end
	end
	if player_state.holding == nil then
		-- can always pick up patients to move them around
		return true
	end

	return false
end

local function item_id_can_be_interacted(player_state, item_info)
	if item_id_can_be_picked_up(item_info.id) then
		return true
	end

	if core.is_patient(item_info) then
		return patient_can_be_interacted(player_state, item_info)
	end

	if core.is_bed(item_info) and
	   player_state.holding ~= nil and
	   core.is_patient(player_state.holding) then
		return true
	end

	return false
end

local function get_interact_in_cell_idx(state, player_idx, y, x)
	for idx, item in ipairs(state.cells[y][x]) do
		if item_id_can_be_interacted(state.players[player_idx], item) then
			return idx
		end
	end
	return nil
end

local function calc_dist(player_state, y, x)
	local dy = player_state.y - y
	local dx = player_state.x - x
	return math.sqrt( dy*dy + dx*dx )
end

function core.get_closest_item_cell(state, player_idx)
	local player_state = state.players[player_idx]
	local y, x = math.floor(player_state.y), math.floor(player_state.x)

	if in_range_coords(state, y, x) then
		local item_idx = get_interact_in_cell_idx(state, player_idx, y, x)

		if item_idx ~= nil then
			return { y = y, x = x }
		end
	end

	local min_dist = nil
	local closest_cell = nil
	for _, dir in ipairs(DIRS) do
		local y2 = y + dir.y
		local x2 = x + dir.x
		if not in_range_coords(state, y2, x2) then
			goto next_dir
		end
		local item_idx = get_interact_in_cell_idx(state, player_idx, y2, x2)

		if item_idx ~= nil then
			local dist = calc_dist(player_state, y2, x2)
			if min_dist == nil or dist < min_dist then
				min_dist = dist
				closest_cell = { y = y2, x = x2 }
			end
		end
		::next_dir::
	end

	return closest_cell
end

function core.get_patient_pos(patient_info)
	if patient_info.held_by == nil then
		return { y = patient_info.y, x = patient_info.x }
	else
		return { y = patient_info.held_by.y,
		         x = patient_info.held_by.x }
	end
end

function core.get_cells_to_highlight(state)
	local cells_to_highlight = {}

	local items_to_highlight = {}

	for _, patient_info in ipairs(state.patients) do
		if patient_info.requires_help and patient_info.held_by == nil then
			if not patient_info.needs_revealed or 
			   patient_info.needs_type == core.NEEDS_BROKEN_BONE then
				
				local pt = core.get_patient_pos(patient_info)
				if pt.y == nil or pt.x == nil then
					error(string.format("received nil coords, %s", patient_info.held_by) )
				end
				table.insert(cells_to_highlight, pt)
			else
				for _, item in ipairs(NEEDS_TO_ITEMS_MAP[patient_info.needs_type]) do
					items_to_highlight[item] = true
				end
			end
		end
	end

	for y, row in pairs(state.cells) do
		for x, cell in pairs(row) do
			for _, item in ipairs(cell) do
				if items_to_highlight[item.id] then
					table.insert(cells_to_highlight, { y = y, x = x })
					goto next_cell
				end
			end
			::next_cell::
		end
	end

	return cells_to_highlight
end

local function get_item_idx_can_be_picked_up(state, cell)
	for cell_item_idx, item_info in ipairs(state.cells[cell.y][cell.x]) do
		if item_id_can_be_picked_up(item_info.id) then
			return cell_item_idx
		end
	end
	return nil
end

function core.pick_up_item(state, player_idx)
	local cell = core.get_closest_item_cell(state, player_idx)
	if cell == nil then
		return false
	else
		local cell_pick_up_item_idx = get_item_idx_can_be_picked_up(state, cell)
		state.players[player_idx].holding = table.remove(state.cells[cell.y][cell.x], cell_pick_up_item_idx)
		
	end
end

function core.drop_item(state, player_idx, drop_pt)
	local player_state = state.players[player_idx]
	if drop_pt == nil then
		drop_pt = {
			y = math.floor(player_state.y),
			x = math.floor(player_state.x),
		}
	end
	local cell = state.cells[drop_pt.y][drop_pt.x]
	table.insert(cell, player_state.holding)
	player_state.holding = nil
end

local function id_is_patient(info_id)
	return info_id == core.ITEM_ID_PATIENT_IN_BED or
	       info_id == core.ITEM_ID_PATIENT_IN_BED_FLIPPED
end

local function get_patient_in_cell(state, cell)
	for _, info in ipairs(state.cells[cell.y][cell.x]) do
		if id_is_patient(info.id) then
			return info
		end
	end
	return nil
end

local function needs_type_to_using_action(needs_type)
	local map = {
		[core.NEEDS_LOW_FLUIDS]   = core.USING_ACTION_LOW_FLUIDS,
		[core.NEEDS_LOW_OXYGEN]   = core.USING_ACTION_DEFIB,
		[core.NEEDS_NO_HEARTBEAT] = core.USING_ACTION_VENTILATOR,
	}
	return map[needs_type]
end

function empty_bed_in_cell(state, cell_pos)
	local cell = state.cells[cell_pos.y][cell_pos.x]
	local bed_present = false
	local patient_present = false
	for _, item_info in ipairs(cell) do
		if core.is_bed(item_info) then
			bed_present = true
		elseif core.is_patient(item_info) then
			patient_present = true
		end
	end
	return bed_present and not patient_present
end

function core.use_start(state, player_idx)
	local player_state = state.players[player_idx]
	local nearest_item_cell = core.get_closest_item_cell(state, player_idx)

	if player_state.holding == nil and
		nearest_item_cell ~= nil and
		get_item_idx_can_be_picked_up(state, nearest_item_cell) then
		return core.pick_up_item(state, player_idx)
	end

	local patient_info = nil
	
	if nearest_item_cell ~= nil then
		patient_info = get_patient_in_cell(state, nearest_item_cell)
	end

	
	local can_help = false
	local use_time = nil

	-- if the player is holding a patient and near a bed
	if player_state.holding ~= nil and
	   core.is_patient(player_state.holding) and
	   nearest_item_cell ~= nil and
	   empty_bed_in_cell(state, nearest_item_cell) then
		can_help = true
		player_state.using_action = core.USING_ACTION_PUT_PATIENT_IN_BED
		player_state.patient_drop_pos = { y = nearest_item_cell.y, x = nearest_item_cell.x }
		use_time = TIME_TO_PICK_UP_PATIENT
	-- if the player is near a patient who requires aid
	elseif patient_info ~= nil and patient_info.requires_help then
		if not patient_info.needs_revealed then
			can_help = true
			player_state.helping_patient = patient_info
			player_state.using_action    = core.USING_ACTION_REVEAL_NEEDS
			use_time = TIME_TO_REVEAL_NEEDS
		else
			if patient_info.needs_type ~= core.NEEDS_BROKEN_BONE and
			   player_state.holding ~= nil and
			   ary_contains(NEEDS_TO_ITEMS_MAP[patient_info.needs_type], player_state.holding.id) then
				can_help = true
				player_state.helping_patient = patient_info
				player_state.using_action    = needs_type_to_using_action(patient_info.needs_type)
				use_time = NEEDS_TO_USE_TIME_MAP[patient_info.needs_type]
			end
		end
	end

	if not can_help and patient_info ~= nil and
	   (player_state.holding == nil or not core.is_patient(player_state.holding)) then
		-- can move any patient, whether they need help or not
		can_help = true
		player_state.helping_patient = patient_info
		player_state.using_action    = core.USING_ACTION_PICK_UP_PATIENT
		use_time = TIME_TO_PICK_UP_PATIENT
	end



	if can_help then
		player_state.is_using     = true
		player_state.use_progress = 0
		player_state.use_time     = use_time
		return true
	else
		return false
	end
end

function core.use_stop(state, player_idx)
	local player_state = state.players[player_idx]
	player_state.is_using     = false
	player_state.use_progress = 0
	player_state.helping_patient = nil
	player_state.using_action    = nil
end

local function get_patient_item_pos(patient_info)
	return {
		y = patient_info.y - 1,
		x = patient_info.x + 1,
	}
end

local function get_patient_cell_idx(state, patient_info)
	local cell = state.cells[patient_info.y][patient_info.x]
	for idx, item_in_cell in ipairs(cell) do
		if item_in_cell == patient_info then
			return idx
		end
	end
	return nil
end

local function bed_fixes_needs(bed, needs_type)
	if bed.fixes_needs == nil then
		return false
	end
	for _, bed_fixes in ipairs(bed.fixes_needs) do
		if bed_fixes == needs_type then
			return true
		end
	end
	return false
end

local function patient_put_in_bed(state, patient_info)
	local cell = state.cells[patient_info.y][patient_info.x]
	local bed = nil
	for _, item_info in ipairs(cell) do
		if core.is_bed(item_info) then
			bed = item_info
			break
		end
	end

	patient_info.in_bed = bed
	if bed_fixes_needs(bed, patient_info.needs_type) then
		local fix_time = NEED_TO_BED_FIX_TIME_MS[patient_info.needs_type]
		patient_info.orig_fix_time = fix_time
		patient_info.fix_time      = fix_time
	end
end

function core.on_use_complete_func(state, player_idx, events)
	local player_state = state.players[player_idx]
	local patient_info = player_state.helping_patient
	local using_action = player_state.using_action
	core.use_stop(state, player_idx)

	if using_action == core.USING_ACTION_PUT_PATIENT_IN_BED then
		local patient = player_state.holding
		core.drop_item(state, player_idx, player_state.patient_drop_pos)
		patient.y = player_state.patient_drop_pos.y
		patient.x = player_state.patient_drop_pos.x
		patient.held_by = nil
		player_state.patient_drop_pos = nil
		patient_put_in_bed(state, patient)
	elseif using_action == core.USING_ACTION_PICK_UP_PATIENT then
		if player_state.holding ~= nil then
			core.drop_item(state, player_idx)
		end
		local patient_cell_idx = get_patient_cell_idx(state, patient_info)
		table.remove(state.cells[patient_info.y][patient_info.x], patient_cell_idx)
		player_state.holding = patient_info
		patient_info.held_by = player_state
		patient_info.y = nil
		patient_info.x = nil
		patient_info.fix_time = nil
	elseif patient_info.requires_help then
		if not patient_info.needs_revealed then
			if using_action == core.USING_ACTION_REVEAL_NEEDS then
				patient_info.needs_revealed = true
			end
		else
			if needs_type_to_using_action(patient_info.needs_type) == using_action then
				patient_info.requires_help  = false
				patient_info.needs_revealed = false
				if ITEMS_DROPPED_ON_USE_MAP[player_state.holding.id] then
					core.drop_item(state, player_idx, get_patient_item_pos(patient_info))
				end

				table.insert(events, {
					event = core.EVT_PATIENT_CURED,
					patient = patient_info,
				})

			end
		end
	end
end

return core
local draw = {}

local core       = require("games/hospital/hospital_core")
local draw_more = require("libs/draw/draw_more")
local alex_c_api = require("alex_c_api")

draw.INPUT_TYPE_KEYBOARD = 1
draw.INPUT_TYPE_TOUCH    = 2

local ANIM_TYPE_FLOAT_TEXT = 1

local TIME_LEFT_BG_COLOUR      = '#66666666'
local TIME_LEFT_FG_GOOD_COLOUR = '#008800aa'
local TIME_LEFT_FG_MED_COLOUR  = '#ffff00ff'
local TIME_LEFT_FG_BAD_COLOUR  = '#ff0000ff'
local TIME_LEFT_FG_BAD_COLOUR2 = '#bb5500ff'

local FIX_TIME_PROGRSS_BAR_BG_COLOUR = '#66ff6666'
local FIX_TIME_PROGRSS_BAR_FG_COLOUR = '#22ff22cc'

local HIGHLIGHT_COLOUR     = '#ffff00'
local CONTROLS_TEXT_COLOUR = '#000000'
local CONTROLS_TEXT_SIZE = 12

local TIME_LEFT_ICON_WIDTH = 10
local PADDING = 3

local PLAYER_HIGHLIGHT_COLOURS = {
	{ fill = "#20a4a966", stroke = "#0000ff99" },
	{ fill = "#a72ea566", stroke = "#ff008899" },
	{ fill = "#774a1e66", stroke = "#f7aa5e99" },
	{ fill = "#c5202066", stroke = "#ff000099" },
}

local animations = {}

local highlight_line_size = 5

local TILE_SIZE = 25
local SCREEN_ORIGIN = {
	y = 480/2,
	x = 480/2,
}

local draw_pt_order = nil

local UI_PADDING = 10
local DIRPAD_SIZE = 170
local DIRPAD_SIZE_Y = DIRPAD_SIZE
local DIRPAD_SIZE_X = DIRPAD_SIZE
local dirpad_pos_y  = nil
local dirpad_pos_x  = nil

local THUMB_BUTTONS_SIZE = 150
local THUMB_BUTTONS_SIZE_Y = THUMB_BUTTONS_SIZE
local THUMB_BUTTONS_SIZE_X = THUMB_BUTTONS_SIZE
local thumb_buttons_pos_y = nil
local thumb_buttons_pos_x = nil

local screen_width  = nil
local screen_height = nil



local function point(y, x)
	return { y = y, x = x }
end

-- "cart" (cartesian) meaning the game space, convert it to
-- an isometric grid (how it's drawn)
local function cart_to_iso(pt)
    local x = (pt.x - pt.y)
    local y = (pt.x + pt.y)/2
    return point(y,x)
end

local function iso_to_cart(pt)
    local x = (2*pt.y + pt.x)/2
    local y = (2*pt.y - pt.x)/2
    return point(y,x)
end

local function game_pt_to_gfx_pt(pt, ui_state)
	if pt.x == nil or pt.y == nil then
		error("nil pt.x or y", 2)
	end
	pt = point(pt.y, pt.x)
	pt.y = pt.y + ui_state.offset_y
	pt.x = pt.x + ui_state.offset_x
    pt = point(pt.y*TILE_SIZE, pt.x*TILE_SIZE)
    pt = cart_to_iso(pt)
    pt = point(pt.y + SCREEN_ORIGIN.y, pt.x + SCREEN_ORIGIN.x)
    return pt
end

local function get_doctor_img_id(player_idx)
	local map = {
		[1] = 'hospital_doctor1',
		[2] = 'hospital_doctor2',
		[3] = 'hospital_doctor3',
		[4] = 'hospital_doctor4',
	}
	local img_id = map[player_idx]
	if img_id == nil then
		error(string.format("Could not find doctor img_id for %d", player_idx))
	end
	return img_id
end

local function generate_draw_pt_order(y_size, x_size)
	local pt_order = {}
	for y=0,y_size-1 do
		local x = 0
		while y >= 0 and x < x_size do
			table.insert(pt_order, { y = y, x = x })
			y = y - 1
			x = x + 1
		end
	end

	for x=0,x_size-1 do
		local y = y_size-1
		while y >= 0 and x < x_size do
			table.insert(pt_order, { y = y, x = x })
			y = y - 1
			x = x + 1
		end
	end
	return pt_order
end

function draw.init(width, height, game_params)

	screen_width  = width
	screen_height = height

	thumb_buttons_pos_y = height - THUMB_BUTTONS_SIZE_Y - UI_PADDING
	thumb_buttons_pos_x = width  - THUMB_BUTTONS_SIZE_X - UI_PADDING

	dirpad_pos_y  = height - DIRPAD_SIZE_Y - UI_PADDING
	dirpad_pos_x  = UI_PADDING

	local ui_state = {
		dirpad_touch_id   = nil,
		use_btn_touch_id  = nil,
		drop_btn_touch_id = nil,
	}

	--draw_pt_order = generate_draw_pt_order(game_params.y_size, game_params.x_size)
	draw_pt_order = generate_draw_pt_order(game_params.y_size, 15) -- TODO FIX THIS TODO TODO TODO
	return ui_state
end

function draw.set_input_type(ui_state, input_type)
	ui_state.input_type = input_type
end

local function get_item_img_id(item_id)
	local map = {
		[core.ITEM_ID_PATIENT_IN_BED] = "hospital_patient_in_bed",
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = "hospital_patient_in_bed_flipped",
		[core.ITEM_ID_BED]        = "hospital_bed",
		[core.ITEM_ID_BED_FLIPPED]= "hospital_bed_flipped",
		[core.ITEM_ID_IV_BAG]     = "hospital_iv_bag",
		[core.ITEM_ID_DEFIB]      = "hospital_defib",
		[core.ITEM_ID_VENTILATOR] = "hospital_ventilator",
		[core.ITEM_ID_XRAY_SHEET] = "hospital_xray_sheet",
		[core.ITEM_ID_XRAY_SOURCE] = "hospital_xray_source",

	}
	local img_id = map[item_id]
	if img_id == nil then
		error(string.format("Could not find image id for item id %s", item_id))
	end
	return img_id
end

local function get_item_size(item_id)
	local sizes = {
		[core.ITEM_ID_PLAYER]         = { x= 1.5*TILE_SIZE,  y= 2*TILE_SIZE },
		[core.ITEM_ID_BED]            = { x= 2.9*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_BED_FLIPPED]    = { x= 2.9*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_PATIENT_IN_BED] = { x= 2.0*TILE_SIZE,  y= 1.5*TILE_SIZE },
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = { x= 2.0*TILE_SIZE,  y= 1.5*TILE_SIZE },
		[core.ITEM_ID_IV_BAG]         = { x= 2*TILE_SIZE,    y= 3*TILE_SIZE },
		[core.ITEM_ID_VENTILATOR]     = { x= 1.8*TILE_SIZE,  y= 2.2*TILE_SIZE },
		[core.ITEM_ID_XRAY_SHEET]     = { x= 2.0*TILE_SIZE,  y= 3.0*TILE_SIZE },
		[core.ITEM_ID_XRAY_SOURCE]    = { x= 2.0*TILE_SIZE,  y= 3.0*TILE_SIZE },
		--[core.ITEM_ID_OXYGEN_TANK]    = { x= 2*TILE_SIZE,    y= 3*TILE_SIZE },
		[core.ITEM_ID_DEFIB]          = { x= 2*TILE_SIZE,    y= 2*TILE_SIZE },
	}
	local size = sizes[item_id]
	if size == nil then
		error(string.format("could not find size for id %s", item_id))
	end
	return size
end

local function get_item_offset(item_id)
	local offsets = {
		[core.ITEM_ID_PLAYER] =         { x= 0.50, y= 0.80 },
		[core.ITEM_ID_BED] =            { x= 0.35, y= 0.55 },
		[core.ITEM_ID_BED_FLIPPED] =    { x= 0.35, y= 0.55 },
		[core.ITEM_ID_PATIENT_IN_BED] = { x= 0.35, y= 0.90 },
		[core.ITEM_ID_PATIENT_IN_BED_FLIPPED] = { x= 0.35, y= 0.90 },
		[core.ITEM_ID_IV_BAG] =   { x= 0.6,  y= 0.7  },
		[core.ITEM_ID_VENTILATOR] =     { x= 0.50, y= 0.55 },
		[core.ITEM_ID_XRAY_SHEET] =     { x= 0.60, y= 0.60 },
		[core.ITEM_ID_XRAY_SOURCE] =    { x= 0.50, y= 0.68 },
		--[core.ITEM_ID_OXYGEN_TANK] =    { x= 0.45, y= 0.65 },
		--[core.ITEM_ID_FLOOR_TILE] =       { x= 0.50, y= 0.00 },
		--[core.ITEM_ID_FLOOR_HIGHLIGHT] =  { x= 0.50, y= 0.00 },
		[core.ITEM_ID_DEFIB] =  { x= 0.55, y= 0.50 },
		--[core.ITEM_ID_PATIENT_NEEDS_ICON] =  { x= 0.0, y= 1.5 },
		--[core.ITEM_ID_TUT_NEED_ACTION] =     { x= 0.5, y= 1.5 },
		--[core.ITEM_ID_FIXER_ICON] =          { x= 0.5, y= 1.5 },
		--[core.ITEM_ID_PROGRESS_CIRCLE] =     { x= 0.55, y= 2.20 },
		--[core.ITEM_ID_PATIENT_HEALTH_INDICATORS] =  { x= 0.55, y= 2.20 },
		--[core.ITEM_ID_PATIENT_IND_ICON] =  { x= 0.0*TILE_SIZE, y= 0.0*TILE_SIZE },
	}
	local offset = offsets[item_id]
	if offset == nil then
		error(string.format("could not find offset for id %s", item_id))
	end
	return offset
end

local function draw_item(state, ui_state, item_info, pt)
	local gfx_pt = game_pt_to_gfx_pt(point(pt.y, pt.x), ui_state)
	local size = get_item_size(item_info.id)
	local offset = get_item_offset(item_info.id)
	gfx_pt.y = gfx_pt.y - size.y*offset.y
	gfx_pt.x = gfx_pt.x - size.x*offset.x
	draw_more.draw_graphic_ul(get_item_img_id(item_info.id),
	                        math.floor(gfx_pt.y), math.floor(gfx_pt.x),
	                        math.floor(size.x), math.floor(size.y))
end

local function draw_using_progress(state, ui_state, player_idx)
	local player_state = state.players[player_idx]
	local gfx_pt = game_pt_to_gfx_pt(point(player_state.y, player_state.x), ui_state)
	local size   = { x = 2.5*TILE_SIZE,   y = 0.5*TILE_SIZE }
	local offset = { x = 0.5, y = 4.00 }
	local draw_pt = point(gfx_pt.y - offset.y*size.y,
	                      gfx_pt.x - offset.x*size.x);


	local progress = player_state.use_progress/100.0
	alex_c_api.draw_rect(PLAYER_HIGHLIGHT_COLOURS[player_idx].fill,
	                     math.floor(draw_pt.y), math.floor(draw_pt.x),
	                     math.floor(draw_pt.y + size.y), math.floor(draw_pt.x + size.x))

	alex_c_api.draw_rect(PLAYER_HIGHLIGHT_COLOURS[player_idx].stroke,
	                     math.floor(draw_pt.y), math.floor(draw_pt.x),
	                     math.floor(draw_pt.y + size.y), math.floor(draw_pt.x + progress*size.x))

end

local function draw_player(state, ui_state, item_info)
	local player_state = state.players[item_info.player_idx]
	local gfx_pt = game_pt_to_gfx_pt(point(player_state.y, player_state.x), ui_state)
	local size   = { x = 1.5*TILE_SIZE,   y = 2*TILE_SIZE }
	local offset = { x = 0.50, y = 0.80 }

	local draw_pt = point(gfx_pt.y - offset.y*size.y,
	                      gfx_pt.x - offset.x*size.x);

	draw_more.draw_graphic_ul(get_doctor_img_id(item_info.player_idx),
	                        math.floor(draw_pt.y), math.floor(draw_pt.x),
	                        math.floor(size.x),    math.floor(size.y))

	if player_state.holding ~= nil then
		draw_item(state, ui_state, player_state.holding, player_state)
	end

	if player_state.is_using then
		draw_using_progress(state, ui_state, item_info.player_idx)
	end
end

local function do_nothing(arg1, arg2, arg3)
end

local draw_funcs = {
	[core.ITEM_ID_BED_SEGMENT_2] = do_nothing,
	[core.ITEM_ID_PLAYER] = draw_player,
}

local function draw_items(state, ui_state, player)
	for _, pt in ipairs(draw_pt_order) do
		if state.cells[pt.y][pt.x] == nil then
			goto next_pt
		end
		for _, item_info in ipairs(state.cells[pt.y][pt.x]) do
			local draw_func = draw_funcs[item_info.id]
			if draw_func ~= nil then
				draw_func(state, ui_state, item_info)
			else
				draw_item(state, ui_state, item_info, pt)
			end
		end
		::next_pt::
	end
end

local function patient_to_needs_img_id(patient_info)
	local needs_to_img_id_map = {
		[core.NEEDS_LOW_FLUIDS]   = 'hospital_ui_patient_needs_low_fluids',
		[core.NEEDS_LOW_OXYGEN]   = 'hospital_ui_patient_needs_low_oxygen',
		[core.NEEDS_NO_HEARTBEAT] = 'hospital_ui_patient_needs_no_heartbeat',
		[core.NEEDS_BROKEN_BONE]  = 'hospital_ui_patient_needs_broken_bone',
	}
	if not patient_info.needs_revealed then
		return 'hospital_ui_patient_needs_attention'
	else
		return needs_to_img_id_map[patient_info.needs_type]
	end

end

local function get_time_left_colour(portion)
	if portion > 0.7 then
		return TIME_LEFT_FG_GOOD_COLOUR
	elseif portion > 0.4 then
		return TIME_LEFT_FG_MED_COLOUR
	else
		-- blinking animation
		local time_ms = alex_c_api.get_time_ms()
		if math.floor(time_ms/200) % 2 == 1 then
			return TIME_LEFT_FG_BAD_COLOUR
		else
			return TIME_LEFT_FG_BAD_COLOUR2
		end
	end
end

local function draw_ui_layer_patient(state, ui_state, player, patient)
	if patient.requires_help then
		local pos_pt = patient
		if patient.held_by ~= nil then
			pos_pt = patient.held_by
		end
           local gfx_pt = game_pt_to_gfx_pt(pos_pt, ui_state)
		gfx_pt.y = math.floor(gfx_pt.y - 4.0*TILE_SIZE)
		gfx_pt.x = math.floor(gfx_pt.x)
		local size = { x = math.floor(TILE_SIZE*2.0), y = math.floor(TILE_SIZE*2.5) }
		draw_more.draw_graphic_ul('hospital_ui_patient_needs_bg', 
		                        gfx_pt.y, gfx_pt.x,
		                        size.x, size.y)
		local needs_img_id = patient_to_needs_img_id(patient)
		draw_more.draw_graphic_ul(needs_img_id,
		                        gfx_pt.y, gfx_pt.x,
		                        size.x, size.y)
		if patient.needs_revealed then
		local portion = patient.time_left / patient.orig_time_left
			alex_c_api.draw_rect(TIME_LEFT_BG_COLOUR,
			                     gfx_pt.y,
			                     gfx_pt.x - TIME_LEFT_ICON_WIDTH - PADDING,
			                     gfx_pt.y + size.y,
			                     gfx_pt.x - PADDING)

			alex_c_api.draw_rect(get_time_left_colour(portion),
			                     gfx_pt.y + math.floor((1-portion) * size.y),
			                     gfx_pt.x - TIME_LEFT_ICON_WIDTH - PADDING,
			                     gfx_pt.y + size.y,
			                     gfx_pt.x - PADDING)
		end

		if patient.fix_time ~= nil then
			-- TODO draw a little green cross icon
			local cross_size = {
				y = 10,
				x = 10,
			}

			local fix_bar_pos = {
				y = gfx_pt.y,
				x = gfx_pt.x - 2*TIME_LEFT_ICON_WIDTH - 2*PADDING,
			}
			local fix_bar_size = {
				y = size.y,
				x = TIME_LEFT_ICON_WIDTH,
			}
			draw_more.draw_graphic_ul('hospital_ui_green_cross',
			                        math.floor(fix_bar_pos.y - cross_size.y - PADDING),
			                        math.floor(fix_bar_pos.x),
			                        math.floor(cross_size.y),
			                        math.floor(cross_size.x))
			local portion = patient.fix_time / patient.orig_fix_time
			alex_c_api.draw_rect(FIX_TIME_PROGRSS_BAR_BG_COLOUR,
			                     fix_bar_pos.y,
			                     fix_bar_pos.x,
			                     fix_bar_pos.y + fix_bar_size.y,
			                     fix_bar_pos.x + fix_bar_size.x)
			alex_c_api.draw_rect(FIX_TIME_PROGRSS_BAR_FG_COLOUR,
			                     fix_bar_pos.y + math.floor(portion*size.y),
			                     fix_bar_pos.x,
			                     fix_bar_pos.y + fix_bar_size.y,
			                     fix_bar_pos.x + fix_bar_size.x)
		end
	end
end

local function draw_ui_layer(state, ui_state, player)
	local highlight_needs_types = {}
	for _, patient in ipairs(state.patients) do
		if patient.requires_help and patient.needs_revealed then
			highlight_needs_types[patient.needs_type] = true
		end
	end

	for y=0, state.y_size-1 do
		for x=0, state.x_size-1 do
			for _, item in ipairs(state.cells[y][x]) do
				local items_needs_type = core.get_item_needs_type(item.id)
				if highlight_needs_types[item_needs_type] then
					-- TODO draw fixer icon
				end
			end
		end
	end
			                        
	for _, patient in ipairs(state.patients) do
		draw_ui_layer_patient(state, ui_state, player, patient)
	end

end

local function draw_highlight_floor_cell(ui_state, colour, y, x)
	local padding = 0.1
	local ia = game_pt_to_gfx_pt(point(y - padding,x - padding), ui_state)
	local ib = game_pt_to_gfx_pt(point(y+1+padding,x+0-padding), ui_state)
	local ic = game_pt_to_gfx_pt(point(y+1+padding,x+1+padding), ui_state)
	local id = game_pt_to_gfx_pt(point(y+0-padding,x+1+padding), ui_state)
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ia.y), math.floor(ia.x),
	                     math.floor(ib.y), math.floor(ib.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ib.y), math.floor(ib.x),
	                     math.floor(ic.y), math.floor(ic.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(ic.y), math.floor(ic.x),
	                     math.floor(id.y), math.floor(id.x))
	alex_c_api.draw_line(colour, highlight_line_size,
	                     math.floor(id.y), math.floor(id.x),
	                     math.floor(ia.y), math.floor(ia.x))
end

local function draw_touch_input()
	draw_more.draw_graphic_ul('hospital_ui_dirpad',
	                        dirpad_pos_y,  dirpad_pos_x,
	                        DIRPAD_SIZE_Y, DIRPAD_SIZE_X)

	draw_more.draw_graphic_ul('hospital_ui_thumb_buttons',
	                        thumb_buttons_pos_y,  thumb_buttons_pos_x,
	                        THUMB_BUTTONS_SIZE_Y, THUMB_BUTTONS_SIZE_X)
end

local function draw_keyboard_input()
	alex_c_api.draw_text('[Z]: Pick up / use', CONTROLS_TEXT_COLOUR,
	                     screen_height - 50, 10, CONTROLS_TEXT_SIZE, 1)
	alex_c_api.draw_text('[X]: Drop', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, 10, CONTROLS_TEXT_SIZE, 1)
	alex_c_api.draw_text('[Arrows]: Move', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, screen_width - 10, CONTROLS_TEXT_SIZE, -1)
end

local function draw_unknown_input()
	alex_c_api.draw_text('Touch screen or use keyboard to select input', CONTROLS_TEXT_COLOUR,
	                     screen_height - 20, math.floor(screen_width/2), CONTROLS_TEXT_SIZE, 0)
end

local function draw_animations(animations)
	for _, anim in ipairs(animations) do
		if anim.anim_type == ANIM_TYPE_FLOAT_TEXT then
			alex_c_api.draw_text(anim.text, anim.text_colour,
			                     math.floor(anim.y), math.floor(anim.x),
			                     anim.font_size, 0)
		else
			error("unhandled anim type", anim.anim_type)
		end
	end
end

function draw.draw_state(state, ui_state, player)
	alex_c_api.draw_clear()

	if state == nil then
		return
	end

	local player_state = state.players[player]

	ui_state.offset_y = -player_state.y
	ui_state.offset_x = -player_state.x

    for y, row in pairs(state.cells) do
    	for x, cell in pairs(row) do

            local ia = game_pt_to_gfx_pt(point(y,x), ui_state)
            draw_more.draw_graphic_ul('hospital_floor_tile',
			                        math.floor(ia.y), math.floor(ia.x - TILE_SIZE),
			                        2*TILE_SIZE, TILE_SIZE);
		end
	end

	for _, cell in ipairs(core.get_cells_to_highlight(state, player)) do
		if cell.y == nil or cell.x == nil then
			error("cell has nil coords")
		end
		draw_highlight_floor_cell(ui_state, HIGHLIGHT_COLOUR,
		                          cell.y, cell.x)
	end

	for player_idx, _ in ipairs(state.players) do
		local highlight_cell = core.get_closest_item_cell(state, player_idx)
		if highlight_cell ~= nil then
			draw_highlight_floor_cell(ui_state, PLAYER_HIGHLIGHT_COLOURS[player_idx].stroke,
			                          highlight_cell.y, highlight_cell.x)
		end
	end

	draw_items(state, ui_state, player)
	draw_ui_layer(state, ui_state, player)
	draw_animations(animations)

	if ui_state.input_type == draw.INPUT_TYPE_TOUCH then
		draw_touch_input()
	elseif ui_state.input_type == draw.INPUT_TYPE_KEYBOARD then
		draw_keyboard_input()
	else
		draw_unknown_input()
	end

	alex_c_api.draw_refresh()
end

local function sign(x)
	if x >= 0 then return 1
	else return -1 end
end

local function get_dirpad_vec(touch)
	local centre_y = math.floor(dirpad_pos_y + DIRPAD_SIZE_Y/2)
	local centre_x = math.floor(dirpad_pos_x + DIRPAD_SIZE_X/2)

	local vec_y = ((touch.y - centre_y)*1.0/(DIRPAD_SIZE/2))
	local vec_x = ((touch.x - centre_x)*1.0/(DIRPAD_SIZE/2))

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	if mag > 1.0 then
		vec_y = vec_y / mag
		vec_x = vec_x / mag
	end

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	return { y = vec_y, x = vec_x}
end

local function touch_in_dirpad(pos)
	local centre_y = math.floor(dirpad_pos_y + DIRPAD_SIZE_Y/2)
	local centre_x = math.floor(dirpad_pos_x + DIRPAD_SIZE_X/2)

	local dy = (pos.y - centre_y)
	local dx = (pos.x - centre_x)

	return (math.abs(dy) <= DIRPAD_SIZE_Y/2 and
	        math.abs(dx) <= DIRPAD_SIZE_X/2)
end

local function touch_in_use_btn(pos)
	local top    = thumb_buttons_pos_y
	local bottom = thumb_buttons_pos_y + THUMB_BUTTONS_SIZE_Y
	local left   = thumb_buttons_pos_x
	local right  = thumb_buttons_pos_x + THUMB_BUTTONS_SIZE_X

	return top  <= pos.y and pos.y <= bottom and
	       left <= pos.x and pos.x <= right and
	       (pos.y - top) >= (pos.x - left)
end

local function touch_in_drop_btn(pos)
	local top    = thumb_buttons_pos_y
	local bottom = thumb_buttons_pos_y + THUMB_BUTTONS_SIZE_Y
	local left   = thumb_buttons_pos_x
	local right  = thumb_buttons_pos_x + THUMB_BUTTONS_SIZE_X

	return top  <= pos.y and pos.y <= bottom and
	       left <= pos.x and pos.x <= right and
	       (pos.y - top) < (pos.x - left)
end

function draw.touches_to_actions(state, ui_state, evt_id, touches)
	local actions = {}
	for _, touch in ipairs(touches) do
		if evt_id == 'touchstart' and ui_state.dirpad_touch_id == nil and touch_in_dirpad(touch) then
			ui_state.dirpad_touch_id = touch.id
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.dirpad_touch_id == touch.id then
			ui_state.dirpad_touch_id = nil
			local action = {
				action = core.ACTION_DIR_PAD_POS_CHANGE,
				vec_y = 0,
				vec_x = 0,
			}
			table.insert(actions, action)
		end
		if ui_state.dirpad_touch_id == touch.id then
			local vec = get_dirpad_vec(touch)
			local action = {
				action = core.ACTION_DIR_PAD_POS_CHANGE,
				vec_y = vec.y,
				vec_x = vec.x
			}
			table.insert(actions, action)
		end

		if evt_id == 'touchstart' and ui_state.use_btn_touch_id == nil and touch_in_use_btn(touch) then
			ui_state.use_btn_touch_id = touch.id
			table.insert(actions, { action = core.ACTION_USE_BTN_DOWN })
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.use_btn_touch_id == touch.id then
			ui_state.use_btn_touch_id = nil
			table.insert(actions, { action = core.ACTION_USE_BTN_RELEASE })
		end

		if evt_id == 'touchstart' and ui_state.drop_btn_touch_id == nil and touch_in_drop_btn(touch) then
			ui_state.drop_btn_touch_id = touch.id
			table.insert(actions, { action = core.ACTION_DROP_BTN_DOWN })
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and ui_state.drop_btn_touch_id == touch.id then
			ui_state.drop_btn_touch_id = nil
			table.insert(actions, { action = core.ACTION_DROP_BTN_RELEASE })
		end
	end
	return actions
end

function draw.add_animations_for_events(state, ui_state, events)
	for _, event in ipairs(events) do
		if event.event == core.EVT_PATIENT_NEED_EXPIRED then
			local pt = event.patient
			local gfx_pt = game_pt_to_gfx_pt(event.patient, ui_state)
			table.insert(animations, {
				anim_type = ANIM_TYPE_FLOAT_TEXT,
				text        = '-100',
				text_colour = '#ff0000ff',
				font_size   = 16,
				orig_y = gfx_pt.y,
				orig_x = gfx_pt.x,

				y = gfx_pt.y,
				x = gfx_pt.x,

				dst_y = gfx_pt.y - 70,
				dst_x = gfx_pt.x,

				orig_time_left = 3000,
				time_left = 3000,
			})
		elseif event.event == core.EVT_PATIENT_CURED then
			local pt = event.patient
			local gfx_pt = game_pt_to_gfx_pt(event.patient, ui_state)
			table.insert(animations, {
				anim_type = ANIM_TYPE_FLOAT_TEXT,
				text      = '+10',
				text_colour = '#008800cc',
				font_size   = 16,

				orig_y = gfx_pt.y,
				orig_x = gfx_pt.x,

				y = gfx_pt.y,
				x = gfx_pt.x,

				dst_y = gfx_pt.y - 70,
				dst_x = gfx_pt.x,

				orig_time_left = 3000,
				time_left = 3000,
			})
		else
			error("unhandled event", event.event)
		end
	end
end

function draw.update_animations(state, dt)
	for _, anim in ipairs(animations) do
		local dy = (anim.dst_y - anim.orig_y)*1.0/anim.orig_time_left
		local dx = (anim.dst_x - anim.orig_x)*1.0/anim.orig_time_left

		anim.y = anim.y + dy * dt
		anim.x = anim.x + dx * dt
		anim.time_left = anim.time_left - dt
	end

	local i=1
	while i <= #animations do
		if animations[i].time_left <= 0 then
			table.remove(animations, i)
		else
			i = i + 1
		end
	end
end


return draw

local core = require("games/hospital/hospital_core")
local draw = require("games/hospital/hospital_draw")
local serialize = require("games/hospital/hospital_serialize")

local wait_for_players = require("libs/multiplayer/wait_for_players")

local alex_c_api = require("alex_c_api")

--[[
	TODO:
	* fix cursor, make it always go towards closest cell...
      right now it's hard to select something to the top left of you if
	  there's something else (perhaps a full cell away) to the bottom right
	* implement multiplayer
	* implement score, right now I just hardcoded +10 and -100 in animations,
	  but the sum isn't tracked anywhere
	* fix arrow keys as client, didn't work on calc.alexbarry.net
	* I saw "player 'all' joined" as host on calc.alexbarry.net

	* need to fix delay on client when joining a mobile host... it's unplayable
	* missing some things from serializiation like the "time to fix" level, and animations



--]]

local players = {
	[1] = "You",
}
local player = 1
local is_client = false
local player_name_to_idx = {}

local FPS = 20
local dt = math.floor(1000.0/FPS)
local keys_down = {}

local screen_width  = 480
local screen_height = 480
local player = 1
local game_params = {
	y_size = 10,
	x_size = 10,
	num_players = 1,
}

local ui_state = draw.init(screen_width, screen_height, game_params)
local state = nil

function draw_board()
	if state == nil then
		return
	end

	draw.update_animations(state, dt)

	-- TODO need to handle animations for client players
	if not is_client then
		local events = core.update_state(state, dt)
		draw.add_animations_for_events(state, ui_state, events)
	end

	draw.draw_state(state, ui_state, player)
	send_state_updates_if_host()
end

local function handle_actions_host(actions, player)
	if state == nil then
		return
	end
	for _, action in ipairs(actions) do
		if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
			core.handle_player_dirpad_update(state, player, action.vec_y, action.vec_x)
		elseif action.action == core.ACTION_USE_BTN_DOWN then
			core.handle_player_use_btn(state, player, true)
		elseif action.action == core.ACTION_USE_BTN_RELEASE then
			core.handle_player_use_btn(state, player, false)
		elseif action.action == core.ACTION_DROP_BTN_DOWN then
			core.handle_player_drop_btn(state, player, true)
		elseif action.action == core.ACTION_DROP_BTN_RELEASE then
			core.handle_player_drop_btn(state, player, false)
		end
	end
end



local function handle_recv_action(src, msg)
	local src_player_idx = player_name_to_idx[src]
	if src_player_idx == nil then
		error("unexpected player src " .. src)
	end
	local m = msg:gmatch("(%d),(.*)")
	if m == nil then
		error(string.format("invalid action msg recvd %s", msg))
	end
	local action_type, payload = m()
	action_type = tonumber(action_type)

	local action = {
		action = action_type,
	}

	if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
		local m2 = payload:gmatch("(-?%d*),(-?%d*)")
		if m2 == nil then
			error(string.format("invalid action dir pad pos msg payload recvd: %s", payload))
		end
		local vec_y_int, vec_x_int = m2()
		vec_y_int = tonumber(vec_y_int)
		vec_x_int = tonumber(vec_x_int)
		action.vec_y = vec_y_int*1.0/1000
		action.vec_x = vec_x_int*1.0/1000
	end

	handle_actions_host({action}, src_player_idx)
	
end

-- Could also throttle this to not send the same position more than once in a row,
-- or within some factor or something
--
-- TODO need to make sure this doesn't happen for keypresses
local last_dirpad_update_time = nil
local MIN_DIRPAD_POS_UPDATE_PERIOD_MS = 50
local function handle_actions_client(actions, player)
	for _, action in ipairs(actions) do
		local payload = ""
		if action.action == core.ACTION_DIR_PAD_POS_CHANGE then
			local curr_time = alex_c_api.get_time_ms()
			if action.vec_y ~= 0 and action.vec_x ~= 0 and
			   last_dirpad_update_time ~= nil and
			   curr_time - last_dirpad_update_time < MIN_DIRPAD_POS_UPDATE_PERIOD_MS then
				goto next_action
			end
			last_dirpad_update_time = curr_time
			payload = string.format("%d,%d", math.floor(action.vec_y*1000),
			                                 math.floor(action.vec_x*1000))
		end
		local msg = string.format("action:%d,%s", action.action, payload)
		alex_c_api.send_message("all", msg)
		::next_action::
	end
end

local function handle_actions(actions, player)
	if is_client then
		handle_actions_client(actions, player)
	else
		handle_actions_host(actions, player)
	end
end



function handle_touch_evt(evt_id, changed_touches)
	draw.set_input_type(ui_state, draw.INPUT_TYPE_TOUCH)
	local actions = draw.touches_to_actions(state, ui_state, evt_id, changed_touches)
	handle_actions(actions, player)
end

local movement_keys = {
	["ArrowUp"]    = true,
	["ArrowLeft"]  = true,
	["ArrowRight"] = true,
	["ArrowDown"]  = true,
	["KeyH"]       = true,
	["KeyJ"]       = true,
	["KeyK"]       = true,
	["KeyL"]       = true,
}

function handle_key_evt(evt_id, key_code)
	local handled = false
	draw.set_input_type(ui_state, draw.INPUT_TYPE_KEYBOARD)
	local prev_state = keys_down[key_code]
	if evt_id == 'keydown' then
		keys_down[key_code] = true
	elseif evt_id == 'keyup' then
		keys_down[key_code] = false
	else
		error(string.format("Unhandled key_evt \"%s\"", evt_id))
	end
	if prev_state == keys_down[key_code] then
		-- Even if we don't act on a movement key here, don't
		-- let the browser scroll if the user is holding the key down.
		return movement_keys[key_code]
	end

	local vec_y = 0
	local vec_x = 0

	if keys_down["ArrowUp"] or keys_down["KeyK"] then
		vec_y = -1
	elseif keys_down["ArrowDown"] or keys_down["KeyJ"] then
		vec_y = 1
	end

	if keys_down["ArrowLeft"] or keys_down["KeyH"] then
		vec_x = -1
	elseif keys_down["ArrowRight"] or keys_down["KeyL"] then
		vec_x = 1
	end

	local mag = math.sqrt(vec_y*vec_y + vec_x*vec_x)

	if mag > 0 then
		vec_y = vec_y / mag
		vec_x = vec_x / mag
	end

	if movement_keys[key_code] then
		handle_actions({{
			-- TODO move this to core
			action = core.ACTION_DIR_PAD_POS_CHANGE,
			vec_y = vec_y,
			vec_x = vec_x,
		}}, player)
		handled = true
	end

	if key_code == 'KeyZ' then
		if evt_id == 'keydown' then
			handle_actions({{
				action = core.ACTION_USE_BTN_DOWN,
			}}, player)
		elseif evt_id == 'keyup' then
			handle_actions({{
				action = core.ACTION_USE_BTN_RELEASE,
			}}, player)
		else
			error(string.format("unhandled evt_id = %s", evt_id))
		end
		handled = true
	end

	if key_code == 'KeyX' then
		if evt_id == 'keydown' then
			handle_actions({{
				action = core.ACTION_DROP_BTN_DOWN,
			}}, player)
		elseif evt_id == 'keyup' then
			handle_actions({{
				action = core.ACTION_DROP_BTN_RELEASE,
			}}, player)
		else
			error(string.format("unhandled evt_id = %s", evt_id))
		end
		handled = true
	end

	return handled
end

function new_game(player_count)
	game_params.num_players = player_count
	state = core.init(game_params)
end

function send_state_updates_if_host()
	if is_client then
		return
	end

	if state == nil then
		return
	end

	for dst_player, player_name in pairs(players) do
		if dst_player == player then
			goto next_player
		end
		local state_msg = "state:" .. serialize.serialize_state(state)
		alex_c_api.send_message(player_name, state_msg)
		::next_player::
	end
end



local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false
	new_game(#players)
	send_state_updates_if_host()
	draw_board()
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- no need to draw board here, a state update should soon follow
end

function handle_msg_received(src, msg)

	local handled = wait_for_players.handle_msg_received(src, msg)
	if handled then
		return
	end
	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "state" then
		if not is_client then
			error("Received state as host")
		end
		state = serialize.deserialize_state(payload)
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	elseif header == "action" then
		handle_recv_action(src, payload)
	else
		error(string.format("Unhandled message %s", header))
	end

	send_state_updates_if_host()
	draw_board()
end 

function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end
end

function start_game()
	alex_c_api.enable_evt('touch')
	alex_c_api.enable_evt('key')
	alex_c_api.set_timer_update_ms(math.floor(dt))

	wait_for_players.init(players, player, start_host_game, start_client_game)
end
local serialize = {}

local core = require("games/hospital/hospital_core")
local utils = require("libs/utils")
local serialize_lib = require("libs/serialize/serialize")

local function get_patient_info_idx(state, item_info)
	for idx, patient_info in ipairs(state.patients) do
		if patient_info == item_info then
			return idx
		end
	end
	return nil
end

local function deserialize_patient_info(state, bytes)
	local info = {}
	info.id             = serialize_lib.deserialize_byte(bytes)
	info.y              = serialize_lib.deserialize_byte(bytes)
	info.x              = serialize_lib.deserialize_byte(bytes)
	info.requires_help  = serialize_lib.deserialize_bool(bytes)
	info.needs_revealed = serialize_lib.deserialize_bool(bytes)
	info.needs_type     = serialize_lib.deserialize_byte(bytes)
	local time_left_s32 = serialize_lib.deserialize_s32(bytes)
	if time_left_s32 == 0x7fffffff then
		info.time_left = nil
	else
		info.time_left      = time_left_s32
	end
	local orig_time_left_s32 = serialize_lib.deserialize_s32(bytes)
	if orig_time_left_s32 ~= 0x7fffffff then
		info.orig_time_left = orig_time_left_s32
	else
		info.orig_time_left = nil
	end
	local held_by_player_idx = serialize_lib.deserialize_byte(bytes)
	if held_by_player_idx == nil then
		info.held_by = nil
	else
		info.held_by = state.players[held_by_player_idx]
	end

	return info
end

local function get_player_idx(state, player_state)
	if player_state == nil then
		return nil
	end
	for idx, player in ipairs(state.players) do
		if player == player_state then
			return idx
		end
	end
	error("could not find player in states")
end

local function serialize_patient_info(state, patient_info)
	local output = ""
	output = output .. serialize_lib.serialize_byte(patient_info.id)
	output = output .. serialize_lib.serialize_byte(patient_info.y)
	output = output .. serialize_lib.serialize_byte(patient_info.x)
	output = output .. serialize_lib.serialize_bool(patient_info.requires_help)
	output = output .. serialize_lib.serialize_bool(patient_info.needs_revealed)
	output = output .. serialize_lib.serialize_byte(patient_info.needs_type)
	if patient_info.time_left ~= nil then
		output = output .. serialize_lib.serialize_s32( math.floor(patient_info.time_left))
	else
		output = output .. serialize_lib.serialize_s32( 0x7fffffff )
	end
	if patient_info.orig_time_left ~= nil then
		output = output .. serialize_lib.serialize_s32( patient_info.orig_time_left)
	else
		output = output .. serialize_lib.serialize_s32( 0x7fffffff )
	end

	output = output .. serialize_lib.serialize_byte(get_player_idx(state, patient_info.held_by))
		
	return output
end

local function deserialize_player_info(bytes)
	local info = {}
	info.id            = core.ITEM_ID_PLAYER
	info.y             = serialize_lib.deserialize_s32(bytes)*1.0/1000
	info.x             = serialize_lib.deserialize_s32(bytes)*1.0/1000
	info.vel_y         = serialize_lib.deserialize_s32(bytes)*1.0/1000/1000
	info.vel_x         = serialize_lib.deserialize_s32(bytes)*1.0/1000/1000
	info.use_btn_down  = serialize_lib.deserialize_bool(bytes)
	info.drop_btn_down = serialize_lib.deserialize_bool(bytes)
	local holding_id   = serialize_lib.deserialize_byte(bytes)
	if holding_id == nil then
		info.holding = nil
	else
		info.holding = { id = holding_id }
	end
	info.is_using      = serialize_lib.deserialize_bool(bytes)
	info.use_progress  = serialize_lib.deserialize_byte(bytes)
	local use_time_byte = serialize_lib.deserialize_byte(bytes)
	if use_time_byte == 0xff then
		info.use_time = nil
	else
		info.use_time      = use_time_byte
	end
	return info
end

local function serialize_player_info(player_info)
	local output = ""
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.y*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.x*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.vel_y*1000*1000))
	output = output .. serialize_lib.serialize_s32( math.floor(player_info.vel_x*1000*1000))
	output = output .. serialize_lib.serialize_bool(player_info.use_btn_down)
	output = output .. serialize_lib.serialize_bool(player_info.drop_btn_down)
	local holding_id = nil
	if player_info.holding ~= nil then
		holding_id = player_info.holding.id
	end
	output = output .. serialize_lib.serialize_byte(holding_id)
	output = output .. serialize_lib.serialize_bool(player_info.is_using)
	output = output .. serialize_lib.serialize_byte(math.floor(player_info.use_progress))
	if player_info.use_time ~= nil then
		output = output .. serialize_lib.serialize_byte(math.floor(player_info.use_time))
	else
		output = output .. serialize_lib.serialize_byte(0xff)
	end
	return output
end

local function serialize_cell(state, cell)
	local output = ""
	output = output .. serialize_lib.serialize_byte(#cell)
	local debug_type = nil
	for _, item_info in ipairs(cell) do
		output = output .. serialize_lib.serialize_byte(item_info.id)
		if core.is_patient(item_info) then
			local patient_idx = get_patient_info_idx(state, item_info)
			output = output .. serialize_lib.serialize_byte(patient_idx)
			debug_type = "patient"
		elseif core.is_player(item_info) then
			local player_idx = item_info.player_idx
			output = output .. serialize_lib.serialize_byte(player_idx)
			debug_type = "player"
		else
			debug_type = "none"
		end
	end
	local s = ""
	for _, item_info in ipairs(cell) do
		s = s .. string.format("%d, ", item_info.id)
	end
	--print(string.format("serialized cell into %d bytes, had %d items (%s) (%s) (%s)", #output, #cell, debug_type, s, utils.binstr_to_hr_str(output)))
	return output
end

local function deserialize_cell(state, bytes)
	local start_byte_count = #bytes
	local cell = {}
	local item_count = serialize_lib.deserialize_byte(bytes)
	local debug_type = "nil"
	for i=1,item_count do
		local item_id = serialize_lib.deserialize_byte(bytes)
		local item_info = {
			id = item_id,
		}
		if core.is_patient(item_info) then
			local patient_idx = serialize_lib.deserialize_byte(bytes)
			if not(1 <= patient_idx and patient_idx <= #state.patients) then
				error(string.format("expected patient idx, received %s, have " ..
				      " only %d patient states", patient_idx, #state.patients))
			end
			debug_type = "patient"
			item_info = state.patients[patient_idx]
		elseif core.is_player(item_info) then
			local player_idx = serialize_lib.deserialize_byte(bytes)
			if not(1 <= player_idx and player_idx <= #state.players) then
				error(string.format("expected player idx, received %s, have " ..
				      " only %d player states", player_idx, #state.players))
			end
			debug_type = "player"
			item_info = state.players[player_idx]
			item_info.id = item_id
			item_info.player_idx = player_idx
		else
			debug_type = "none"
		end
		table.insert(cell, item_info)
	end
	--print(string.format("deserialized cell from %d bytes, contained %d items (%s)", start_byte_count - #bytes, item_count, debug_type))
	return cell
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(state.y_size)
	output = output .. serialize_lib.serialize_byte(state.x_size)

	output = output .. serialize_lib.serialize_s32(state.new_sickness_period)
	output = output .. serialize_lib.serialize_s32_nilable(state.time_to_new_sickness)
	output = output .. serialize_lib.serialize_byte(state.new_sickness_count)

	output = output .. serialize_lib.serialize_byte(#state.players)
	for _, player in ipairs(state.players) do
		output = output .. serialize_player_info(player)
	end
	output = output .. serialize_lib.serialize_byte(#state.patients)
	for _, patient in ipairs(state.patients) do
		output = output .. serialize_patient_info(state, patient)
	end
	local cells_serialized = ""
	local non_empty_cell_count = 0
	for y, row in pairs(state.cells) do
		for x, cell in pairs(row) do
			if state.cells[y][x] ~= nil then
				cells_serialized = cells_serialized .. serialize_lib.serialize_byte(y)
				cells_serialized = cells_serialized .. serialize_lib.serialize_byte(x)
				cells_serialized = cells_serialized .. serialize_cell(state, state.cells[y][x])
				non_empty_cell_count = non_empty_cell_count + 1
			end
		end
	end
	output = output .. serialize_lib.serialize_16bit(non_empty_cell_count)
	output = output .. cells_serialized
	--print(string.format("serialized %d non empty cells into %d bytes", non_empty_cell_count, #cells_serialized))
	--print(string.format("serialized into %d bytes", #output))
	return output
end

function serialize.deserialize_state(byte_str)
	local bytes = serialize_lib.bytestr_to_byteary(byte_str)
	--print(string.format("deserializing %d bytes", #bytes))
	local state = {}
	state.y_size = serialize_lib.deserialize_byte(bytes)
	state.x_size = serialize_lib.deserialize_byte(bytes)

	state.new_sickness_period  = serialize_lib.deserialize_s32(bytes)
	state.time_to_new_sickness = serialize_lib.deserialize_s32_nilable(bytes)
	state.new_sickness_count   = serialize_lib.deserialize_byte(bytes)

	local player_count = serialize_lib.deserialize_byte(bytes)
	state.players  = {}
	for i=1,player_count do
		state.players[i] = deserialize_player_info(bytes)
	end

	local patient_count = serialize_lib.deserialize_byte(bytes)
	state.patients = {}
	for i=1,patient_count do
		--print("deserializing patient " .. i)
		state.patients[i] = deserialize_patient_info(state, bytes)
	end

	state.cells = {}

	local non_empty_cell_count = serialize_lib.deserialize_16bit(bytes)
	--print("deserializing " .. non_empty_cell_count .. " cells from " .. #bytes .. " remaining bytes" )
	for i=1,non_empty_cell_count do
		--print("i=" .. i ..", remaining bytes: " .. utils.binary_to_hr_str(bytes))
		local y = serialize_lib.deserialize_byte(bytes)
		local x = serialize_lib.deserialize_byte(bytes)
		if state.cells[y] == nil then
			state.cells[y] = {}
		end
		state.cells[y][x] = deserialize_cell(state, bytes)
	end

	if #bytes > 0 then
		error(string.format("received %d leftover bytes when deserializing", #bytes))
	end
	
	return state
end

return serialize
local life = {}

local dirs = {
	{ y =  0, x =  1},
	{ y =  0, x = -1},
	{ y =  1, x =  0},
	{ y = -1, x =  0},


	{ y =  1, x = -1},
	{ y =  1, x =  1},
	{ y = -1, x = -1},
	{ y = -1, x =  1},
}

function add_pts(arg1, arg2)
	return { y = (arg1.y + arg2.y), x = (arg1.x + arg2.x) }
end


function life.new_board(y_size, x_size)
	local board = {}
	for y=1,y_size do
		board[#board+1] = {}
		for x=1,x_size do
			board[y][#board[y]+1] = 0
		end
	end
	return board
end

function life.new_state(y_size, x_size)
	local state = {
		boards = {
			life.new_board(y_size, x_size),
			life.new_board(y_size, x_size),
		},
		board_idx = 1,
	}
	return state
end

function life.get_active_board(state)
	return state.boards[state.board_idx]
end

function in_range(board, pt)
	return (1 <= pt.x and pt.x <= #board[1] and
	        1 <= pt.y and pt.y <= #board)
end

function count_neighbours(board, pos)
	local count = 0
	for _, dir in ipairs(dirs) do
		local pt2 = add_pts(pos, dir)
		if not in_range(board, pt2) then
			goto next_dir
		end

		if board[pt2.y][pt2.x] ~= 0 then
			count = count + 1
		end

		::next_dir::
	end

	return count
end

function life.update_board(in_board, out_board)
	for y=1,#in_board do
		for x=1,#in_board[y] do
			local neighbour_count = count_neighbours(in_board, {y=y, x=x})
			--if neighbour_count > 0 then
			--	print(string.format("{y=%2d, x=%2d} found neighbour count %d", y,x,neighbour_count))
			--end
			if in_board[y][x] ~= 0 and 2 <= neighbour_count and neighbour_count <= 3 then
				out_board[y][x] = 1
			elseif in_board[y][x] == 0 and neighbour_count == 3 then
				out_board[y][x] = 1
			else
				out_board[y][x] = 0
			end
		end
	end
end

function life.update_state(state)
	local src_board_idx = state.board_idx
	local dst_board_idx
	if src_board_idx == 1 then
		dst_board_idx = 2
	else
		dst_board_idx = 1
	end

	life.update_board(state.boards[src_board_idx], state.boards[dst_board_idx])

	state.board_idx = dst_board_idx
end

function life.toggle_cell_board(board, y, x)
	if not in_range(board, {y=y, x=x}) then
		return
	end
	
	local val = board[y][x]
	if val == 0 then
		val = 1
	else
		val = 0
	end

	board[y][x] = val
end

function life.toggle_cell_state(state, cell_pos_pt)
	local board = life.get_active_board(state)
	life.toggle_cell_board(board, cell_pos_pt.y, cell_pos_pt.x)
end

function life.clear_board(state)
	local board = life.get_active_board(state)
	for y=1,#board do
		for x=1,#board[y] do
			board[y][x] = 0
		end
	end
end

function bool_to_int(b)
	if b then return 1
	else return 0 end
end

function life.random_board(state)
	local board = life.get_active_board(state)
	for y=1,#board do
		for x=1,#board[y] do
			board[y][x] = bool_to_int(math.random(0,10) <= 3)
		end
	end
end

return life
local alex_c_api = require("alex_c_api")

local lua_draw = {}

local cell_size_y = nil
local cell_size_x = nil

local present_colour = '#000000'
local absent_colour  = '#ffffff'

if alex_c_api.get_user_colour_pref() == "dark" then
	present_colour = '#888888'
	absent_colour  = '#000000'
end

function lua_draw.init(cell_size)
	cell_size_y = cell_size
	cell_size_x = cell_size
end

function lua_draw.draw_board(board)
	alex_c_api.draw_clear()
	for y=1,#board do
		for x=1,#board[y] do
			local fill_colour
			if board[y][x] ~= 0 then
				fill_colour = present_colour
			else
				fill_colour = absent_colour
			end
			alex_c_api.draw_rect(fill_colour,
			                     (y-1)*cell_size_y, (x-1)*cell_size_x,
			                      y *  cell_size_y,  x *  cell_size_x)
		end
	end
	alex_c_api.draw_refresh()
end

function lua_draw.coords_to_cell_idx(coords_y, coords_x)
	return { y = 1 + math.floor(coords_y/cell_size_y),
	         x = 1 + math.floor(coords_x/cell_size_x) }
end

return lua_draw
local life_core = require("games/life/life_core")
local life_draw = require("games/life/life_draw")
local alex_c_api = require("alex_c_api")

local BTN_ID_TOGGLE_PLAY_PAUSE = "toggle_play_pause"
local BTN_ID_STEP              = "step"
local BTN_ID_RANDOM            = "random"
local BTN_ID_CLEAR             = "clear"

local cell_size = 10
local board_width = 480
local board_height = 480
--local cells_y = 40
--local cells_x = 30
local cells_y = math.floor(board_height/cell_size)
local cells_x = math.floor(board_width/cell_size)

local state = nil
local is_drawing = true

function draw_board_internal()
	life_core.update_state(state)
	life_draw.draw_board(life_core.get_active_board(state))
end

function draw_board()
	if is_drawing then
		draw_board_internal()
	end
end

function handle_user_clicked(y_coords, x_coords)
	local cell_pos = life_draw.coords_to_cell_idx(y_coords, x_coords)
	life_core.toggle_cell_state(state, cell_pos)
	life_draw.draw_board(life_core.get_active_board(state))
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_STEP then
		life_core.update_state(state)
		life_draw.draw_board(life_core.get_active_board(state))
	elseif btn_id == BTN_ID_TOGGLE_PLAY_PAUSE then
		is_drawing = not is_drawing
	elseif btn_id == BTN_ID_RANDOM then
		life_core.random_board(state)
		life_draw.draw_board(life_core.get_active_board(state))
	elseif btn_id == BTN_ID_CLEAR then
		life_core.clear_board(state)
		life_draw.draw_board(life_core.get_active_board(state))
	else
		print(string.format("Unhandled btn_id \"%s\"", btn_id))
	end
end

function get_state()
	-- TODO it wouldn't be unreasonable to implement importing/exporting state for this, but
	-- since it's more of a tech demo than a game, I don't want to bother
	-- with it right now.
	return nil
end

life_draw.init(cell_size)

function start_game()
	alex_c_api.create_btn(BTN_ID_TOGGLE_PLAY_PAUSE, "Play/pause", 1)
	alex_c_api.create_btn(BTN_ID_STEP,              "Step",       1)
	alex_c_api.create_btn(BTN_ID_RANDOM,            "Random",     1)
	alex_c_api.create_btn(BTN_ID_CLEAR,             "Clear",      1)
	
	state = life_core.new_state(cells_y, cells_x)
	
	alex_c_api.set_timer_update_ms(math.floor(1000/20))
end

local core = {}

local MINE_PORTION = 0.20

local CELL_COUNT_BORDER_PADDING = 6

local dirs = {
	{y = 0, x = 1},
	{y = 1, x = 1},
	{y = 1, x = 0},
	{y = 1, x =-1},
	{y = 0, x =-1},
	{y =-1, x =-1},
	{y =-1, x = 0},
	{y =-1, x = 1},
}


local MIN_MAX_ZOOM_FACT = 3

core.MOVE_FLAG_CELL    = 1
core.MOVE_CLICK_CELL   = 2

core.RC_SUCCESS      =  0
core.RC_OUT_OF_RANGE = -1
core.RC_INVALID_MOVE = -2

local FLAG_MINE_SUCCESS_SCORE =   10
local FLAG_MINE_FAIL_SCORE    =  -30
local REVEAL_MINE_SCORE       = -100
local REVEAL_CELL_SCORE       =    1


-- TODO this should be in the draw file only
-- apparently I wrote this game before I was used to properly separating the UI and the game logic
core.cell_size = 35

local function in_range(state, y, x)
	return 1 <= y and y <= state.game.height and
	       1 <= x and x <= state.game.width
end

function core.get_touching_mine_count(state)

	for y=1,state.game.height do
		for x=1,state.game.width do
			local count = 0
			for _,dir in ipairs(dirs) do
				local y2 = y + dir.y
				local x2 = x + dir.x
				if not in_range(state, y2, x2) then
					goto next_dir
				end

				if state.game.board[y2][x2].has_mine then
					count = count + 1
				end
				::next_dir::
			end
			state.game.board[y][x].touching_mine_count = count
		end
	end
	
end

function core.new_player_state()
	local player_state = {
		offset_y = 0,
		offset_x = 0,
		zoom_fact = 1.0,
		score    = 0,
	}
	return player_state
end


function core.new_state(player_count, game_height, game_width, cell_size)
	local state = {
		game = {
			width = game_width,
			height = game_height,
			board = {},
			cells_unrevealed = nil,
			mines_unrevealed = nil,
		},
		players = {},
		cell_size = cell_size,
	}

	for y=1,game_height do
		state.game.board[y] = {}
		for x=1,game_width do
			state.game.board[y][x] = {}
			state.game.board[y][x].has_mine = (math.random() <= MINE_PORTION)
			state.game.board[y][x].revealed = false
			state.game.board[y][x].flagged_by_player = nil
			state.game.board[y][x].touching_mine_count = nil
		end
	end

	for i=1,player_count do
		state.players[i] = core.new_player_state()
	end

	core.calc_state_vals(state)

	return state
end

function core.calc_state_vals(state)
	core.get_touching_mine_count(state)
	core.calc_cells_unrevealed(state)
	core.calc_mines_unrevealed(state)
end

function core.calc_cells_unrevealed(state)
	local cells_unrevealed = 0
	for y=1,state.game.height do
		for x=1,state.game.width do
			local cell = state.game.board[y][x]
			if not cell.revealed and not cell.flagged_by_player then
				cells_unrevealed = cells_unrevealed + 1
			end
		end
	end
	state.game.cells_unrevealed = cells_unrevealed
end

function core.calc_mines_unrevealed(state)
	local mines_unrevealed = 0
	for y=1,state.game.height do
		for x=1,state.game.width do
			local cell = state.game.board[y][x]
			if cell.has_mine and not cell.revealed and not cell.flagged_by_player then
				mines_unrevealed = mines_unrevealed + 1
			end
		end
	end
	state.game.mines_unrevealed = mines_unrevealed
end


function core.is_game_over(state)
	return state.game.cells_unrevealed == 0
end
	

local function clip_min_max(val, min_val, max_val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end

function core.get_zoom_fact(state, player)
	return state.players[player].zoom_fact
end
function core.set_zoom_fact(state, player, zoom_fact)
	state.players[player].zoom_fact = clip_min_max(zoom_fact, 1/MIN_MAX_ZOOM_FACT, MIN_MAX_ZOOM_FACT)
end

function core.handle_move(state, player, move, y, x)
	if move == core.MOVE_FLAG_CELL then
		return core.flag_cell(state, player, y, x)
	elseif move == core.MOVE_CLICK_CELL then
		return core.clicked_cell(state, player, y, x)
	else
		error(string.format("unhandled move type %s", move))
	end
end

local function in_ary(ary, y, x)
	if ary[y] == nil then
		return false
	else
		return ary[y][x] ~= nil
	end
end


-- I think what I need here is the width of the view-- how 
-- many mines fit in the view window
local function get_max_y_offset(state)
	return (state.game.height - CELL_COUNT_BORDER_PADDING) * core.cell_size 
end

local function get_max_x_offset(state)
	return (state.game.width  - CELL_COUNT_BORDER_PADDING) * core.cell_size
end

function core.adjust_offset(state, player, offset_y, offset_x)
	state.players[player].offset_y = clip_min_max(offset_y,
	                                             -core.cell_size*CELL_COUNT_BORDER_PADDING,
	                                             get_max_y_offset(state))
	state.players[player].offset_x = clip_min_max(offset_x,
	                                             -core.cell_size*CELL_COUNT_BORDER_PADDING,
	                                             get_max_x_offset(state))
end

function core.reveal_cell(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	if state.game.board[y][x].revealed then
		return core.RC_SUCCESS
	end

	local to_visit = {
		{ y = y, x = x }
	}
	local visited = {}

	while #to_visit > 0 do
		local pos = table.remove(to_visit)

		if not in_range(state, pos.y, pos.x) or
		   in_ary(visited, pos.y, pos.x) then
			goto next_cell
		end


		if not state.game.board[pos.y][pos.x].revealed then
			state.game.cells_unrevealed = state.game.cells_unrevealed - 1
		end
		state.game.board[pos.y][pos.x].revealed = true
		local score_change = 0
		if state.game.board[pos.y][pos.x].has_mine then
			score_change = REVEAL_MINE_SCORE
			state.game.mines_unrevealed = state.game.mines_unrevealed - 1
		else
			score_change = REVEAL_CELL_SCORE
		end
		state.players[player].score = state.players[player].score + score_change

		if visited[pos.y] == nil then
			visited[pos.y] = {}
		end
		visited[pos.y][pos.x] = true

		if state.game.board[pos.y][pos.x].touching_mine_count > 0 or
		   state.game.board[pos.y][pos.x].has_mine then
			goto next_cell
		end

		for _, dir in ipairs(dirs) do
			local y2 = pos.y + dir.y
			local x2 = pos.x + dir.x
			if in_range(state, y2, x2) and
			   not in_ary(visited, y2, x2) and
			   not state.game.board[y2][x2].has_mine then
				table.insert(to_visit, {y=y2, x=x2})
			end
		end
		::next_cell::
	end

	return core.RC_SUCCESS
end

function core.flag_cell(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	if state.game.board[y][x].revealed then
		return core.RC_INVALID_MOVE
	end

	-- in single player, remove your own flag, if desired
	if #state.players == 1 and state.game.board[y][x].flagged_by_player == player then
		state.game.board[y][x].flagged_by_player = nil
		state.players[player].score = state.players[player].score - FLAG_MINE_SUCCESS_SCORE
		state.game.cells_unrevealed = state.game.cells_unrevealed + 1
		state.game.mines_unrevealed = state.game.mines_unrevealed + 1
	-- can only flag unflagged cells
	elseif state.game.board[y][x].flagged_by_player == nil then
		if state.players == 1 then
			state.game.board[y][x].flagged_by_player = player
		else
			local score_change
			if state.game.board[y][x].has_mine == true then
				state.game.board[y][x].flagged_by_player = player
				score_change = FLAG_MINE_SUCCESS_SCORE
				state.game.mines_unrevealed = state.game.mines_unrevealed - 1
			else
				state.game.board[y][x].revealed = true
				score_change = FLAG_MINE_FAIL_SCORE
				-- TODO need to communicate this state to the user, so animations can be shown
			end
			state.game.cells_unrevealed = state.game.cells_unrevealed - 1
			state.players[player].score = state.players[player].score + score_change
		end
	end

	return core.RC_SUCCESS
end

function core.reveal_neighbours(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end
	if not state.game.board[y][x].revealed then
		return
	end

	local flags_or_revealed_mines_nearby = 0

	for _, dir in ipairs(dirs) do
		local y2 = y + dir.y
		local x2 = x + dir.x

		if in_range(state, y2, x2) then
			local cell = state.game.board[y2][x2]
			if cell.revealed and cell.has_mine or
			   cell.flagged_by_player ~= nil then
				flags_or_revealed_mines_nearby = flags_or_revealed_mines_nearby + 1
			end
		end
	end

	if flags_or_revealed_mines_nearby >= state.game.board[y][x].touching_mine_count then
		for _, dir in ipairs(dirs) do
			local y2 = y + dir.y
			local x2 = x + dir.x

			if in_range(state, y2, x2) then
				local cell = state.game.board[y2][x2]
				if not( cell.revealed and cell.has_mine or
				   cell.flagged_by_player ~= nil) then
					core.reveal_cell(state, player, y2, x2)
				end
			end
		end
	end
	
	return core.RC_SUCCESS
end

function core.clicked_cell(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	if state.game.board[y][x].revealed then
		core.reveal_neighbours(state, player, y, x)
	elseif state.game.board[y][x].flagged_by_player == nil then
		core.reveal_cell(state, player, y, x)
	end


	return core.RC_SUCCESS
end


return core

local draw = {}

local alex_c_api = require("alex_c_api")
local draw_more = require("libs/draw/draw_more")
local draw_celebration_anim = require("libs/draw/draw_celebration_anim")

local cell_size = 35

local MINE_COUNT_TO_IMG_ID_MAP = {
	[0] = 'minesweeper_box_empty',
	[1] = 'minesweeper_box1',
	[2] = 'minesweeper_box2',
	[3] = 'minesweeper_box3',
	[4] = 'minesweeper_box4',
	[5] = 'minesweeper_box5',
	[6] = 'minesweeper_box6',
	[7] = 'minesweeper_box7',
	[8] = 'minesweeper_box8',
}

local FLAGGED_TO_IMG_ID_MAP = {
	[1] = 'minesweeper_box_flagged_red',
	[2] = 'minesweeper_box_flagged_blue',
}

local BACKGROUND_COLOUR = '#bbbbbb'
local TEXT_COLOUR       = '#000000'
--local TEXT_BACKGROUND_COLOUR = '#ffffffbb'
local TEXT_BACKGROUND_COLOUR = '#bbbbbbbb'
local TEXT_FONT_SIZE    = 18

draw.draw_flag_flash = false

local board_width  = nil
local board_height = nil

local g_victory_anim_timer = nil
local anim_state = draw_celebration_anim.new_state({
})

local function cell_to_img_id(cell)
	if not cell.revealed then
		if cell.flagged_by_player == nil then
			return 'minesweeper_box_unclicked'
		else
			local flag_img = FLAGGED_TO_IMG_ID_MAP[cell.flagged_by_player]
			if flag_img == nil then
				error(string.format("flagged_by_player %s not found in map", cell.flagged_by_player)) 
			end
			return flag_img
		end
	elseif cell.has_mine then
		return 'minesweeper_mine'
	else
		local img_id = MINE_COUNT_TO_IMG_ID_MAP[cell.touching_mine_count]
		if img_id == nil then
			error(string.format("touching_mine_count %s not found in map", cell.touching_mine_count))
		end
		return img_id
	end
end

function draw.init(board_width_arg, board_height_arg, cell_size_arg)
	board_width  = board_width_arg
	board_height = board_height_arg
	cell_size    = cell_size_arg
end

function draw.update(dt_ms)
	draw_celebration_anim.update(anim_state, dt_ms/1000.0)
end

function draw.draw_state(state, player)
	alex_c_api.draw_clear()
	if state == nil or state.game == nil then
		return
	end
	alex_c_api.draw_rect(BACKGROUND_COLOUR, 0, 0, board_width, board_height)
	-- TODO only draw cells that are (partially or fully) visible
	for y, row in ipairs(state.game.board) do
		for x, cell in ipairs(row) do
			local offset_y = state.players[player].offset_y
			local offset_x = state.players[player].offset_x

			local pos_y = (y-1)*cell_size - offset_y
			local pos_x = (x-1)*cell_size - offset_x

			local zoom_fact = state.players[player].zoom_fact

			pos_y = math.floor(pos_y * zoom_fact)
			pos_x = math.floor(pos_x * zoom_fact)

			local actual_cell_size = math.floor(cell_size * zoom_fact)

			local in_range = true
			if pos_y + actual_cell_size <= 0 or
			   pos_x + actual_cell_size <= 0 or
			   pos_y >= board_height or
			   pos_x >= board_width then
				in_range = false
			end

			if in_range then
				draw_more.draw_graphic_ul(cell_to_img_id(cell),
				                        pos_y, pos_x,
				                        actual_cell_size, actual_cell_size)
			end
		end
	end

	local text_height = 30
	local player_text_width  = 165
	local text_padding = 10
	alex_c_api.draw_rect(TEXT_BACKGROUND_COLOUR,
	                     board_height - #state.players*text_height - text_padding,
	                     board_width  - player_text_width - text_padding,
	                     board_height, board_width)
	for i=0,#state.players-1 do
		local player_idx = #state.players - i
		alex_c_api.draw_text(string.format("Player %d: %4d", player_idx, state.players[player_idx].score),
		                     TEXT_COLOUR,
		                     board_height - i * text_height - text_padding,
							 board_width - text_padding,
		                     TEXT_FONT_SIZE,
		                     -1)
		                     
	end

	local mines_text_width = 115
	alex_c_api.draw_rect(TEXT_BACKGROUND_COLOUR,
	                     board_height - text_height - text_padding,
	                     0,
	                     board_height, mines_text_width + text_padding)
	alex_c_api.draw_text(string.format("Mines: %3d", state.game.mines_unrevealed),
	                     TEXT_COLOUR,
	                     board_height - text_padding,
	                     text_padding,
	                     TEXT_FONT_SIZE,
	                     alex_c_api.TEXT_ALIGN_LEFT)

	if draw.draw_flag_flash then
		alex_c_api.draw_rect('#ffffff88', 0, 0, 480, 480)
		draw.draw_flag_flash = false
	end
	draw_celebration_anim.draw(anim_state)
	alex_c_api.draw_refresh()
end

function draw.pos_to_cell_coords(state, player, pos_y, pos_x)
	local zoom_fact = state.players[player].zoom_fact
	return {
		y = 1 + math.floor((state.players[player].offset_y + pos_y/zoom_fact)/cell_size),
		x = 1 + math.floor((state.players[player].offset_x + pos_x/zoom_fact)/cell_size),
	}
end

function draw.victory_animation(fps)
	print("setting timer")
	if g_victory_anim_timer ~= nil then
		error(string.format("victory_animation: anim_timer is not nil"))
	end
	g_victory_anim_timer = alex_c_api.set_timer_update_ms(1000/fps)
	draw_celebration_anim.fireworks_display(anim_state, {
		colour_pref = "light",
		on_finish = function ()
			if g_victory_anim_timer == nil then
				alex_c_api.set_status_err("warning: g_victory_anim_timer is nil on anim complete")
			else
				alex_c_api.delete_timer(g_victory_anim_timer)
				g_victory_anim_timer = nil
			end
			--print("animation finished! Resuming timer")
			--alex_c_api.set_timer_update_ms(0)
			--alex_c_api.set_timer_update_ms(1000/60)
		end,
	})
end



return draw

local core      = require("games/minesweeper/minesweeper_core")
local draw      = require("games/minesweeper/minesweeper_draw")
local serialize = require("games/minesweeper/minesweeper_serialize")

local wait_for_players = require("libs/multiplayer/wait_for_players")

local alex_c_api = require("alex_c_api")

-- TODO add:
--    * vibrate phone when flag has appeared? Show red circle so user knows when flag appears
--      even if it is covered by their finger?
--
-- TODO for multiplayer:
--    * TODO add a graphic for "cell is loading". For now it is probably fine to just leave it as unclicked because
--      of the low latency. (Actually, even on my LAN, I see a decent bit of latency when hosting on my phone and
--      using my laptop as a client.)
--    * animate points appearing over where you click 


-- maximum y or x distance that a player can move their finger/mouse before their gesture is no longer
-- interpreted as a click
local MAX_CLICK_MOVE = 2

local game_size_y = 20
local game_size_x = 20

local player = 1
local player_count = 1
local cell_size = core.cell_size
-- TODO initialize player state but not game state
local state = core.new_state(player_count, game_size_y, game_size_x, cell_size)
local win_anim_shown = false
local state_set = false
local g_session_id = alex_c_api.get_new_session_id()
--local state = nil
local user_input_down = false
local user_input_down_timer_fired = false
local user_input_down_time = nil
local user_input_moved = false

-- These are only set on touchdown
local user_input_pos_y = nil
local user_input_pos_x = nil

-- These are updated on touchdown and touchmove events
local user_input_pos_move_y = nil
local user_input_pos_move_x = nil

local user_input2_pos_move_y = nil
local user_input2_pos_move_x = nil
local user_init_touch_dist  = nil
local user_offset_y = 0
local user_offset_x = 0
local active_touch  = nil
local active_touch2 = nil

local players = {
	[1] = "You",
}
local player = 1
local is_client = false
local player_name_to_idx = {}

local GAME_OPT_NEW_GAME = "game_opt_new_game"


local USER_INPUT_DOWN_TIME_THRESHOLD_MS = 300


local function handle_move_client(state, player, move, y, x)
	local msg = string.format("move:%d,%d,%d,%d", player, move, y, x)
	-- TODO only message the host in the future?
	alex_c_api.send_message("all", msg)
	return core.RC_SUCCESS
end

local function handle_move(state, player, move, y, x)
	local rc = nil
	if is_client then
		rc = handle_move_client(state, player, move, y, x)
	else
		rc = core.handle_move(state, player, move, y, x)
	end
	local state_serialized = serialize.serialize_state(state)
	if move == core.MOVE_FLAG_CELL then
		draw.draw_flag_flash = true
	end
	alex_c_api.save_state(g_session_id, state_serialized)

	if core.is_game_over(state) and not win_anim_shown then
		print('alex showing victory animation')
		win_anim_shown = true
		draw.victory_animation(60)
	end
end

local function check_for_input_time_done()
	if not user_input_down then
		return
	end

	local time_diff = alex_c_api.get_time_ms() - user_input_down_time
	if user_input_down and 
	   time_diff >= USER_INPUT_DOWN_TIME_THRESHOLD_MS and
		not user_input_moved and
		not user_input_down_timer_fired then
		user_input_down_timer_fired = true
		local cell_coords = draw.pos_to_cell_coords(state, player, user_input_pos_y, user_input_pos_x)
		handle_move(state, player, core.MOVE_FLAG_CELL, cell_coords.y, cell_coords.x)
		send_state_updates_if_host()
		draw_board()
	end
end

-- TODO change draw_board to some "update_evt" or something
function draw_board(dt_ms)
	if dt_ms ~= nil then
		draw.update(dt_ms)
	end
	draw.draw_state(state, player)
	check_for_input_time_done()
end

local function handle_user_input_down(pos_y, pos_x)
		user_input_down_time = alex_c_api.get_time_ms()
		user_input_down = true
		user_input_moved = false
		user_input_down_timer_fired = false
		user_input_pos_y = pos_y
		user_input_pos_x = pos_x
		user_input_pos_move_y = pos_y
		user_input_pos_move_x = pos_x
		user_offset_y = state.players[player].offset_y
		user_offset_x = state.players[player].offset_x
end

local function handle_user_input_release(pos_y, pos_x, cancel)
	if not cancel and not user_input_moved and not user_input_down_timer_fired then
		local cell_coords = draw.pos_to_cell_coords(state, player, pos_y, pos_x)
		local time_diff = alex_c_api.get_time_ms() - user_input_down_time
		local move_type = nil
		if time_diff <= USER_INPUT_DOWN_TIME_THRESHOLD_MS then
			move_type = core.MOVE_CLICK_CELL
		else
			move_type = core.MOVE_FLAG_CELL
		end
		handle_move(state, player, move_type, cell_coords.y, cell_coords.x)
		draw_board()
		send_state_updates_if_host()
	end
	user_input_down = false
	user_input_down_timer_fired = false
end

function handle_mouse_evt(evt_id, pos_y, pos_x)
	if evt_id == alex_c_api.MOUSE_EVT_DOWN then
		handle_user_input_down(pos_y, pos_x)
	elseif evt_id == alex_c_api.MOUSE_EVT_UP then
		handle_user_input_release(pos_y, pos_x, false)
	elseif evt_id == alex_c_api.MOUSE_EVT_LEAVE then
		handle_user_input_release(pos_y, pos_x, true)
	elseif evt_id == alex_c_api.MOUSE_EVT_ALT_DOWN then
		local cell_coords = draw.pos_to_cell_coords(state, player, pos_y, pos_x)
		handle_move(state, player, core.MOVE_FLAG_CELL, cell_coords.y, cell_coords.x)
	else
		print(string.format('unhandled evt_id %s', evt_id))
	end
end

local function handle_user_input_move(pos_y, pos_x)
	if user_input_down and (
	      math.abs(user_input_pos_y - pos_y) > MAX_CLICK_MOVE or
	      math.abs(user_input_pos_x - pos_x) > MAX_CLICK_MOVE) then
		user_input_moved = true
	end
	if user_input_down then
		local offset_adj_y = user_input_pos_y - pos_y
		local offset_adj_x = user_input_pos_x - pos_x
		user_input_pos_move_y = pos_y
		user_input_pos_move_x = pos_x
		core.adjust_offset(state, player,
			math.floor(user_offset_y + offset_adj_y),
			math.floor(user_offset_x + offset_adj_x))
		draw_board()
	end
end

function handle_mousemove(pos_y, pos_x)
	handle_user_input_move(pos_y, pos_x)
end

function handle_user_clicked()
end

local function get_touch_dist()
	local dy = user_input2_pos_move_y - user_input_pos_move_y
	local dx = user_input2_pos_move_x - user_input_pos_move_x
	return math.sqrt(dy*dy + dx*dx)
end

function handle_touch_evt(evt_id, changed_touches)
	for _, touch in ipairs(changed_touches) do
		if evt_id == 'touchstart' then
			if active_touch == nil then
				active_touch = touch.id
				handle_user_input_down(touch.y, touch.x)
			elseif active_touch2 == nil then
				active_touch2 = touch.id
				user_input_moved = true
				user_input2_pos_move_y = touch.y
				user_input2_pos_move_x = touch.x
				user_init_touch_dist = get_touch_dist()
				init_zoom = core.get_zoom_fact(state, player)
			end
		elseif evt_id == 'touchmove' then

			if active_touch == touch.id then
				handle_user_input_move(touch.y, touch.x)
			end

			if active_touch2 ~= nil then
				if active_touch2 == touch.id then
					user_input2_pos_move_y = touch.y
					user_input2_pos_move_x = touch.x
				end
				local touch_dist_fact = get_touch_dist() / user_init_touch_dist
				local zoom_fact = init_zoom * touch_dist_fact
				--alex_c_api.set_status_msg(
				--     string.format("Touch dist fact is %.3f, dist=%.0f, orig=%.0f",
				--                   touch_dist_fact, get_touch_dist(), user_init_touch_dist))
				core.set_zoom_fact(state, player, zoom_fact)
			end

		elseif evt_id == 'touchend' or
		       evt_id == 'touchcancel' then
			local is_cancel = (evt_id == 'touchcancel')
			if active_touch == touch.id then
				handle_user_input_release(touch.y, touch.x, is_cancel)
				active_touch = nil
			elseif active_touch2 == touch.id then
				active_touch2 = nil
			end
		end
	end
end

function handle_wheel_changed(dy, dx)
	print(string.format("handle_wheel(dy=%s, dx=%s)", dy, dx))

	local zoom_fact = core.get_zoom_fact(state, player)

	zoom_fact = zoom_fact + -dy/114 * 0.1

	core.set_zoom_fact(state, player, zoom_fact)

	draw_board()
end

function send_state_updates_if_host()
	print("send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
	if is_client and not wait_for_players.is_host_tentative() then
		print("return 1 send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
		return
	end

	if state == nil then
		print("return 2 send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
		return
	end

	for dst_player, player_name in pairs(wait_for_players.players_tentative()) do
		if dst_player == player then
			goto next_player
		end
		print("Sending state update")
		local state_msg = "state:" .. serialize.serialize_client_game_state(state, dst_player)
		alex_c_api.send_message(player_name, state_msg)
		::next_player::
	end
end

function new_game(player_count)
	print(string.format("Starting game with %d players", player_count))
	state = core.new_state(player_count, game_size_y, game_size_x, cell_size)
	win_anim_shown = false
	g_session_id = alex_c_api.get_new_session_id()
end


local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false

	if not state_set then
		new_game(#players)
	end
	send_state_updates_if_host()
	draw_board()
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- TODO only initialize player_state here?
	state = core.new_state(#players, 20, 20, cell_size)
	-- no need to draw board here, a state update should soon follow
end

function handle_msg_received(src, msg)

	local handled = wait_for_players.handle_msg_received(src, msg)

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if handled and header ~= "joined" then
		return
	end

	if header == "state" then
		--if not is_client and not wait_for_players.is_host_tentative() then
		--	error("Received state as host")
		--end
		serialize.deserialize_client_game_state(state, payload)
	elseif header == "joined" then
		print("player_joined")
		send_state_updates_if_host()
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	elseif header == "move" then
		if not is_client then
			local m2 = payload:gmatch("(%d+),(%d+),(%d+),(%d+)")
			if m2 == nil then
				error(string.format("invalid move payload %s", payload))
			end
			local player_str, move_type_str, y_str, x_str = m2()
			local player    = tonumber(player_str)
			local move_type = tonumber(move_type_str)
			local y         = tonumber(y_str)
			local x         = tonumber(x_str)

			if player ~= player_name_to_idx[src] then
				error(string.format("received move for player idx %s from player_name %s (%d)",
				      player, src, player_name_to_idx[src]))
			end
			handle_move(state, player, move_type, y, x)
			send_state_updates_if_host()
		end
	else
		error(string.format("Unhandled message %s", header))
	end

	send_state_updates_if_host()
	draw_board()
end


function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end
end

function handle_game_option_evt(game_opt_id, value)
	if game_opt_id == GAME_OPT_NEW_GAME then
		new_game(#players)
		draw_board()
	end
end

function get_state()
	return serialize.serialize_state(state)
end

-- TODO need proper state saving

draw.init(480, 480, cell_size)

function start_game(session_id, state_serialized)
	if state_serialized ~= nil then
		g_session_id = session_id
		state = serialize.deserialize_state(state_serialized)
		state_set = true
	else
		local last_sess_id = alex_c_api.get_last_session_id()
		if last_sess_id ~= nil then
			state_serialized = alex_c_api.get_saved_state_offset(last_sess_id, 0) 
			g_session_id = last_sess_id
			state = serialize.deserialize_state(state_serialized)
			state_set = true
		end
	end
	wait_for_players.init(players, player, start_host_game, start_client_game)

	alex_c_api.enable_evt("mouse_move")
	alex_c_api.enable_evt("mouse_updown")
	alex_c_api.enable_evt("mouse_alt_updown")
	alex_c_api.enable_evt("touch")
	alex_c_api.enable_evt("wheel")

	alex_c_api.add_game_option(GAME_OPT_NEW_GAME, {
		type  = alex_c_api.OPTION_TYPE_BTN,
		label = "New Game"
	})

	-- Kind of sucks that I only need this timer for measuring touch/mouse down time.
	-- Would be ideal if I could just set a 300 ms one off timer?
	alex_c_api.set_timer_update_ms(50)

end
local serialize = {}

local bit_pack = require("libs/serialize/bit_pack")
local core = require("games/minesweeper/minesweeper_core")

serialize.VERSION = 1
local serialize_lib = require("libs/serialize/serialize")

local function serialize_cell_for_client(cell)
	if not cell.revealed then
		if cell.flagged_by_player == nil then return 0
		else return 10 + cell.flagged_by_player end
	else
		if cell.has_mine then return 10
		else
			if cell.touching_mine_count > 0 then
				return cell.touching_mine_count
			else
				return 9
			end
		end
	end
end

local function client_deserialize_cell(bytes)
	local byte = table.remove(bytes, 1)
	byte = string.byte(byte)
	local cell = {
		revealed = false,
		has_mine = false,
		flagged_by_player = nil,
		touching_mine_count = nil,
	}
	if byte == 0 then
		-- pass
	elseif 11 <= byte and byte <= 14 then
		cell.flagged_by_player = byte - 10
	elseif byte == 10 then
		cell.revealed = true
		cell.has_mine = true
	elseif byte == 9 then
		cell.revealed = true
		cell.touching_mine_count = 0
	elseif 1 <= byte and byte <= 8 then
		cell.revealed = true
		cell.touching_mine_count = byte
	else
		error(string.format("unexpected serialized cell byte=%s", byte))
	end

	return cell
end

function serialize.serialize_client_game_state(state, player)
	local game_state = state.game
	local output = ""
	output = output .. serialize_lib.serialize_byte(#state.players)
	output = output .. serialize_lib.serialize_16bit(game_state.width)
	output = output .. serialize_lib.serialize_16bit(game_state.height)
	for i=1,#state.players do
		local player_state = state.players[i]
		output = output .. serialize_lib.serialize_s32(player_state.score)
	end
	for y=1,game_state.height do
		for x=1,game_state.width do
			local serialized_cell = serialize_cell_for_client(game_state.board[y][x])
			output = output .. serialize_lib.serialize_byte(serialized_cell)
		end
	end
	return output
end

function serialize.deserialize_client_game_state(state, bytes)
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local game_state = state.game
	local player_count      = serialize_lib.deserialize_byte(bytes)
	game_state.width        = serialize_lib.deserialize_16bit(bytes)
	game_state.height       = serialize_lib.deserialize_16bit(bytes)
	for i=1,player_count do
		if state.players[i] == nil then
			error(string.format("player idx %d not in map when len %d", i, #state.players))
		end
		state.players[i].score = serialize_lib.deserialize_s32(bytes)
	end
	game_state.board = {}
	for y=1,game_state.height do
		game_state.board[y] = {}
		for x=1,game_state.width do
			game_state.board[y][x] = client_deserialize_cell(bytes)
		end
	end
	return game_state
end

local function serialize_cell_concise(cell)
	local val = 0
	if cell.flagged_by_player ~= nil then val = val | 0x4 end
	if cell.revealed                 then val = val | 0x2 end
	if cell.has_mine                 then val = val | 0x1 end

	return val
end

local function deserialize_cell_concise(val)
	local cell = {}
	cell.flagged_by_player = (val & 0x4) > 0
	if cell.flagged_by_player then
		cell.flagged_by_player = 1
	else
		cell.flagged_by_player = nil
	end
	cell.revealed          = (val & 0x2) > 0
	cell.has_mine          = (val & 0x1) > 0
	return cell
end

local function serialize_cells_concise(cells)
	local cells_3bits = {} 
	for y=1,#cells do
		for x=1,#cells[1] do
			table.insert(cells_3bits, serialize_cell_concise(cells[y][x]))
		end
	end

	return bit_pack.pack(cells_3bits, 3)
end

local function deserialize_cells_concise(cells_bytes)
	local cells = {}
	for y=1,#cells_bytes do
		local row = {}
		for x=1,#cells_bytes[1] do
			table.insert(row, deserialize_cell_concise(cells_bytes[y][x]))
		end
		table.insert(cells, row)
	end
	return cells
end

local function unflatten(cells_flat, height, width)
	local cells = {}
	for y=1,height do
		local row = {}
		for x=1,width do
			table.insert(row, cells_flat[(y-1)*width + x] )
		end
		table.insert(cells, row)
	end
	return cells
end


function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(serialize.VERSION)
	output = output .. serialize_lib.serialize_byte(state.game.height)
	output = output .. serialize_lib.serialize_byte(state.game.width)
	output = output .. serialize_lib.serialize_bytes(serialize_cells_concise(state.game.board))
	return output
end

function serialize.deserialize_state(bytes)
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local state = {
		game = {},
	}
	local version = serialize_lib.deserialize_byte(bytes)
	if version ~= serialize.VERSION then
		error(string.format("Can only deserialize state version %d, found %d", serialize.VERSION, version))
	end
	state.game.height = serialize_lib.deserialize_byte(bytes)
	state.game.width  = serialize_lib.deserialize_byte(bytes)

	local cells_flat_bytes_packed = serialize_lib.deserialize_bytes(bytes)
	local cells_flat_serialized = bit_pack.unpack(cells_flat_bytes_packed, 3)
	local cells_bytes = unflatten(cells_flat_serialized, state.game.height, state.game.width)
	state.game.board = deserialize_cells_concise(cells_bytes)

	core.calc_state_vals(state)

	state.players = {
		core.new_player_state(),
	}

	return state
end

return serialize

local draw = {}

local alex_c_api = require("alex_c_api")
local draw_more = require("libs/draw/draw_more")
local draw_celebration_anim = require("libs/draw/draw_celebration_anim")

draw.BTN_ID_UNDO = "btn_undo"
draw.BTN_ID_REDO = "btn_redo"

local cell_size = 35

local MINE_COUNT_TO_IMG_ID_MAP = {
	[0] = 'minesweeper_box_empty',
	[1] = 'minesweeper_box1',
	[2] = 'minesweeper_box2',
	[3] = 'minesweeper_box3',
	[4] = 'minesweeper_box4',
	[5] = 'minesweeper_box5',
	[6] = 'minesweeper_box6',
	[7] = 'minesweeper_box7',
	[8] = 'minesweeper_box8',
}

local FLAGGED_TO_IMG_ID_MAP = {
	[1] = 'minesweeper_box_flagged_red',
	[2] = 'minesweeper_box_flagged_blue',
}

local BACKGROUND_COLOUR = '#bbbbbb'
local TEXT_COLOUR       = '#000000'
--local TEXT_BACKGROUND_COLOUR = '#ffffffbb'
local TEXT_BACKGROUND_COLOUR = '#bbbbbbbb'
local TEXT_FONT_SIZE    = 18

draw.draw_flag_flash = false

local board_width  = nil
local board_height = nil

local g_victory_anim_timer = nil
local anim_state = draw_celebration_anim.new_state({
})

local function cell_to_img_id(cell)
	if not cell.revealed then
		if cell.flagged_by_player == nil then
			return 'minesweeper_box_unclicked'
		else
			local flag_img = FLAGGED_TO_IMG_ID_MAP[cell.flagged_by_player]
			if flag_img == nil then
				error(string.format("flagged_by_player %s not found in map", cell.flagged_by_player)) 
			end
			return flag_img
		end
	elseif cell.has_mine then
		return 'minesweeper_mine'
	else
		local img_id = MINE_COUNT_TO_IMG_ID_MAP[cell.touching_mine_count]
		if img_id == nil then
			error(string.format("touching_mine_count %s not found in map", cell.touching_mine_count))
		end
		return img_id
	end
end

function draw.init(board_width_arg, board_height_arg, cell_size_arg)
	board_width  = board_width_arg
	board_height = board_height_arg
	cell_size    = cell_size_arg

	alex_c_api.create_btn(draw.BTN_ID_UNDO, "Undo", 1)
	alex_c_api.create_btn(draw.BTN_ID_REDO, "Redo", 1)
end

function draw.update(dt_ms)
	draw_celebration_anim.update(anim_state, dt_ms/1000.0)
end

function draw.draw_state(state, player)
	alex_c_api.draw_clear()
	if state == nil or state.game == nil then
		return
	end
	alex_c_api.draw_rect(BACKGROUND_COLOUR, 0, 0, board_width, board_height)
	-- TODO only draw cells that are (partially or fully) visible
	for y, row in ipairs(state.game.board) do
		for x, cell in ipairs(row) do
			local offset_y = state.players[player].offset_y
			local offset_x = state.players[player].offset_x

			local pos_y = (y-1)*cell_size - offset_y
			local pos_x = (x-1)*cell_size - offset_x

			local zoom_fact = state.players[player].zoom_fact

			pos_y = math.floor(pos_y * zoom_fact)
			pos_x = math.floor(pos_x * zoom_fact)

			local actual_cell_size = math.floor(cell_size * zoom_fact)

			local in_range = true
			if pos_y + actual_cell_size <= 0 or
			   pos_x + actual_cell_size <= 0 or
			   pos_y >= board_height or
			   pos_x >= board_width then
				in_range = false
			end

			if in_range then
				draw_more.draw_graphic_ul(cell_to_img_id(cell),
				                        pos_y, pos_x,
				                        actual_cell_size, actual_cell_size)
			end
		end
	end

	local text_height = 30
	local player_text_width  = 165
	local text_padding = 10
	alex_c_api.draw_rect(TEXT_BACKGROUND_COLOUR,
	                     board_height - #state.players*text_height - text_padding,
	                     board_width  - player_text_width - text_padding,
	                     board_height, board_width)
	for i=0,#state.players-1 do
		local player_idx = #state.players - i
		alex_c_api.draw_text(string.format("Player %d: %4d", player_idx, state.players[player_idx].score),
		                     TEXT_COLOUR,
		                     board_height - i * text_height - text_padding,
							 board_width - text_padding,
		                     TEXT_FONT_SIZE,
		                     -1)
		                     
	end

	local mines_text_width = 115
	alex_c_api.draw_rect(TEXT_BACKGROUND_COLOUR,
	                     board_height - text_height - text_padding,
	                     0,
	                     board_height, mines_text_width + text_padding)
	alex_c_api.draw_text(string.format("Mines: %3d", state.game.mines_unrevealed),
	                     TEXT_COLOUR,
	                     board_height - text_padding,
	                     text_padding,
	                     TEXT_FONT_SIZE,
	                     alex_c_api.TEXT_ALIGN_LEFT)

	if draw.draw_flag_flash then
		alex_c_api.draw_rect('#ffffff88', 0, 0, 480, 480)
		draw.draw_flag_flash = false
	end
	draw_celebration_anim.draw(anim_state)
	alex_c_api.draw_refresh()
end

function draw.pos_to_cell_coords(state, player, pos_y, pos_x)
	local zoom_fact = state.players[player].zoom_fact
	return {
		y = 1 + math.floor((state.players[player].offset_y + pos_y/zoom_fact)/cell_size),
		x = 1 + math.floor((state.players[player].offset_x + pos_x/zoom_fact)/cell_size),
	}
end

function draw.victory_animation(fps)
	print("setting timer")
	if g_victory_anim_timer ~= nil then
		error(string.format("victory_animation: anim_timer is not nil"))
	end
	g_victory_anim_timer = alex_c_api.set_timer_update_ms(1000/fps)
	draw_celebration_anim.fireworks_display(anim_state, {
		colour_pref = "light",
		on_finish = function ()
			if g_victory_anim_timer == nil then
				alex_c_api.set_status_err("warning: g_victory_anim_timer is nil on anim complete")
			else
				alex_c_api.delete_timer(g_victory_anim_timer)
				g_victory_anim_timer = nil
			end
			--print("animation finished! Resuming timer")
			--alex_c_api.set_timer_update_ms(0)
			--alex_c_api.set_timer_update_ms(1000/60)
		end,
	})
end



return draw

local core = {}

core.INIT_ZOOM_FACT = 0.5

local CELL_COUNT_BORDER_PADDING = 6

local dirs = {
	{y = 0, x = 1},
	{y = 1, x = 1},
	{y = 1, x = 0},
	{y = 1, x =-1},
	{y = 0, x =-1},
	{y =-1, x =-1},
	{y =-1, x = 0},
	{y =-1, x = 1},
}

core.DEFAULT_MINE_PORTION = 0.1


local MIN_MAX_ZOOM_FACT = 3

core.MOVE_FLAG_CELL    = 1
core.MOVE_CLICK_CELL   = 2

core.RC_SUCCESS      =  0
core.RC_OUT_OF_RANGE = -1
core.RC_INVALID_MOVE = -2
core.RC_CAN_NOT_AUTO_REVEAL = -3

local FLAG_MINE_SUCCESS_SCORE =   10
local FLAG_MINE_FAIL_SCORE    =  -30
local REVEAL_MINE_SCORE       = -100
local REVEAL_CELL_SCORE       =    1


-- TODO this should be in the draw file only
-- apparently I wrote this game before I was used to properly separating the UI and the game logic
core.cell_size = 35

local function in_range(state, y, x)
	return 1 <= y and y <= state.game.height and
	       1 <= x and x <= state.game.width
end

-- TODO rename this to "update"
function core.get_touching_mine_count(state)

	for y=1,state.game.height do
		for x=1,state.game.width do
			local count = 0
			for _,dir in ipairs(dirs) do
				local y2 = y + dir.y
				local x2 = x + dir.x
				if not in_range(state, y2, x2) then
					goto next_dir
				end

				if state.game.board[y2][x2].has_mine then
					count = count + 1
				end
				::next_dir::
			end
			state.game.board[y][x].touching_mine_count = count
		end
	end
	
end

function core.new_player_state()
	local player_state = {
		offset_y = 0,
		offset_x = 0,
		zoom_fact = core.INIT_ZOOM_FACT,
		score    = 0,
	}
	return player_state
end

function core.copy_player_ui_states(state)
	local ui_states = {}
	for _, player in ipairs(state.players) do
		table.insert(ui_states, {
			offset_y = player.offset_y,
			offset_x = player.offset_x,
			zoom_fact = player.zoom_fact,
		})
	end
	return ui_states
end

function core.apply_player_ui_states(state, ui_states)
	for player_idx, player in ipairs(state.players) do
		player.offset_y  = ui_states[player_idx].offset_y
		player.offset_x  = ui_states[player_idx].offset_x
		player.zoom_fact = ui_states[player_idx].zoom_fact
	end
end

local function copy_cell(cell)
	local new_cell = {
		has_mine            = cell.has_mine,
		revealed            = cell.revealed,
		flagged_by_player   = cell.flagged_by_player,
		touching_mine_count = cell.touching_mine_count,
	}
	return new_cell
end

function core.new_state(player_count, game_height, game_width, cell_size, mine_portion)
	local state = {
		game = {
			width = game_width,
			height = game_height,
			board = {},
			cells_unrevealed = nil,
			mines_unrevealed = nil,
		},
		players = {},
		cell_size = cell_size,
	}

	for y=1,game_height do
		state.game.board[y] = {}
		for x=1,game_width do
			state.game.board[y][x] = {}
			state.game.board[y][x].has_mine = (math.random() <= mine_portion)
			state.game.board[y][x].revealed = false
			state.game.board[y][x].flagged_by_player = nil
			state.game.board[y][x].touching_mine_count = nil
		end
	end

	for i=1,player_count do
		state.players[i] = core.new_player_state()
	end

	core.calc_state_vals(state)

	return state
end

function core.calc_state_vals(state)
	core.get_touching_mine_count(state)
	core.calc_cells_unrevealed(state)
	core.calc_mines_unrevealed(state)
end

function core.calc_cells_unrevealed(state)
	local cells_unrevealed = 0
	for y=1,state.game.height do
		for x=1,state.game.width do
			local cell = state.game.board[y][x]
			if not cell.revealed and not cell.flagged_by_player then
				cells_unrevealed = cells_unrevealed + 1
			end
		end
	end
	state.game.cells_unrevealed = cells_unrevealed
end

function core.calc_mines_unrevealed(state)
	local mines_unrevealed = 0
	for y=1,state.game.height do
		for x=1,state.game.width do
			local cell = state.game.board[y][x]
			if cell.has_mine and not cell.revealed and not cell.flagged_by_player then
				mines_unrevealed = mines_unrevealed + 1
			end
		end
	end
	state.game.mines_unrevealed = mines_unrevealed
end


function core.is_game_over(state)
	return state.game.cells_unrevealed == 0
end
	

local function clip_min_max(val, min_val, max_val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end

function core.get_zoom_fact(state, player)
	return state.players[player].zoom_fact
end
function core.set_zoom_fact(state, player, zoom_fact)
	state.players[player].zoom_fact = clip_min_max(zoom_fact, 1/MIN_MAX_ZOOM_FACT, MIN_MAX_ZOOM_FACT)
end

function add_pts(arg1, arg2)
	return { y = (arg1.y + arg2.y), x = (arg1.x + arg2.x) }
end

-- TODO there must be a minesweeper version of this already,
-- but I copied it from my "life" game
function count_neighbours(state, pos)
	local count = 0
	for _, dir in ipairs(dirs) do
		local pt2 = add_pts(pos, dir)
		if not in_range(state, pt2.y, pt2.x) then
			goto next_dir
		end

		if state.game.board[pt2.y][pt2.x].has_mine then
			count = count + 1
		end

		::next_dir::
	end

	return count
end

local function copy_board(board)
	local new_board = {}
	for _, row in ipairs(board) do
		local new_row = {}
		for _, cell in ipairs(row) do
			table.insert(new_row, copy_cell(cell))
		end
		table.insert(new_board, new_row)
	end
	return new_board
end

function core.life_increment(state)
	local new_board = copy_board(state.game.board)
	for y=1,#state.game.board do
		for x=1,#state.game.board[y] do
			local prev_mine_state = state.game.board[y][x].has_mine
			local neighbour_count = count_neighbours(state, {y=y, x=x})

			local new_mine_state
			if prev_mine_state and 2 <= neighbour_count and neighbour_count <= 3 then
				new_mine_state = true
			elseif not prev_mine_state and neighbour_count == 3 then
				new_mine_state = true
			else
				new_mine_state = false
			end

			new_board[y][x].has_mine = new_mine_state
			-- when a mine goes away, leave an unrevealed cell in its wake
			-- I'm not sure if this will be too hard yet, or if
			-- it would be better to have separate states for "explicitly revealed by player"
			-- and "was revealed from the start", and only un-reveal the latter
			if prev_mine_state and not new_mine_state then
				new_board[y][x].revealed = false
			end
		end
	end
	state.game.board = new_board
end

-- normally this "autoreveal" happens when the user first reveals
-- an "empty" cell (meaning it has no neighbouring mines).
-- But in "life" mines move around, and I've found it cumbersome
-- to require the user to click the empty cells even though they
-- are guaranteed to be safe (i.e. no flagging/mines nearby are needed)
function core.autoreveal_empty_cells(state, player)
	for y=1,state.game.height do
		for x=1,state.game.width do
			if state.game.board[y][x].revealed then
				if count_neighbours(state, {y=y, x=x}) == 0 then
					core.reveal_neighbours(state, player, y, x)
				end
			end
		end
	end
end

-- Before adding "life", minesweeper wouldn't let you flag cells that
-- don't contain a mine (since in multiplayer, that could become a mess.
-- in single player though, it would be reasonable)
-- 
-- But in "life", the mines move around, and flags no longer contain mines sometimes.
-- So remove the flags
function core.remove_flags_if_no_longer_valid(state)
	for y=1,state.game.height do
		for x=1,state.game.width do
			local cell = state.game.board[y][x]
			if not cell.has_mine and cell.flagged_by_player ~= nil then
				cell.flagged_by_player = nil
				cell.revealed = true
			end
		end
	end
end

local function is_valid_move(move, cell_prev_state, cell_current_state, y, x)
	if move == core.MOVE_FLAG_CELL then
		if not cell_current_state.revealed then
			return true
		end

		if not cell_prev_state.has_mine and cell_current_state.has_mine then
			return true
		end

		return false
	elseif move == core.MOVE_CLICK_CELL then
		return not cell_current_state.revealed
	else
		error(string.format("Unhandled move type %s", move))
	end
end

function core.handle_move(state, player, move, y, x)

	local cell_prev_state = state.game.board[y][x]

	-- kind of a hack, I should modify the life_increment function to 
	-- take in a board, rather than do this
	local state2 = {
		game = {
			height = state.game.height,
			width  = state.game.width,
			board  = copy_board(state.game.board),
		},
	}
	core.life_increment(state2)

	print(string.format("On copy of state, incremented life state and found cell %d %d is revealed=%s, has_mine=%s prev_has_mine=%s (move=%s)", y, x, state2.game.board[y][x].revealed, state2.game.board[y][x].has_mine, cell_prev_state.has_mine, move))

	local rc
	-- if flagging, only support flagging cells that previously were not mines,
	-- and have become one since the life update-- or cells that were unrevealed.
	-- if revealing, only support unrevealed cells
	if is_valid_move(move, cell_prev_state, state2.game.board[y][x], y, x) then
		-- TODO maybe only do this every 10 moves or so
		core.life_increment(state)

		-- I'm not sure if this takes too much of the fun out of it.
		--core.autoreveal_empty_cells(state, player)
		core.get_touching_mine_count(state)
		core.remove_flags_if_no_longer_valid(state)

		-- Update "mine count" and etc, and check if game is now won
		core.calc_state_vals(state)
		if state.game.cells_unrevealed == 0 then
		end

		if move == core.MOVE_FLAG_CELL then
			rc = core.flag_cell(state, player, y, x)
		elseif move == core.MOVE_CLICK_CELL then
			rc = core.clicked_cell(state, player, y, x)
		else
			error(string.format("unhandled move type %s", move))
		end

		if rc ~= core.RC_SUCCESS then
			error(string.format("Received rc %s?", rc))
		end

	end


	return rc
end

local function in_ary(ary, y, x)
	if ary[y] == nil then
		return false
	else
		return ary[y][x] ~= nil
	end
end


-- I think what I need here is the width of the view-- how 
-- many mines fit in the view window
local function get_max_y_offset(state)
	return (state.game.height - CELL_COUNT_BORDER_PADDING) * core.cell_size 
end

local function get_max_x_offset(state)
	return (state.game.width  - CELL_COUNT_BORDER_PADDING) * core.cell_size
end

function core.adjust_offset(state, player, offset_y, offset_x)
	state.players[player].offset_y = clip_min_max(offset_y,
	                                             -core.cell_size*CELL_COUNT_BORDER_PADDING,
	                                             get_max_y_offset(state))
	state.players[player].offset_x = clip_min_max(offset_x,
	                                             -core.cell_size*CELL_COUNT_BORDER_PADDING,
	                                             get_max_x_offset(state))
end

function core.reveal_cell(state, player, y, x)
	if player == nil then
		error("player param is nil")
	end
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	if state.game.board[y][x].revealed then
		return core.RC_SUCCESS
	end

	local to_visit = {
		{ y = y, x = x }
	}
	local visited = {}

	while #to_visit > 0 do
		local pos = table.remove(to_visit)

		if not in_range(state, pos.y, pos.x) or
		   in_ary(visited, pos.y, pos.x) then
			goto next_cell
		end


		if not state.game.board[pos.y][pos.x].revealed then
			state.game.cells_unrevealed = state.game.cells_unrevealed - 1
		end
		state.game.board[pos.y][pos.x].revealed = true
		local score_change = 0
		if state.game.board[pos.y][pos.x].has_mine then
			score_change = REVEAL_MINE_SCORE
			state.game.mines_unrevealed = state.game.mines_unrevealed - 1
		else
			score_change = REVEAL_CELL_SCORE
		end

		-- for the case where cells are revealed initially, on puzzle creation
		if player ~= 0 then
			state.players[player].score = state.players[player].score + score_change
		end

		if visited[pos.y] == nil then
			visited[pos.y] = {}
		end
		visited[pos.y][pos.x] = true

		if state.game.board[pos.y][pos.x].touching_mine_count > 0 or
		   state.game.board[pos.y][pos.x].has_mine then
			goto next_cell
		end

		for _, dir in ipairs(dirs) do
			local y2 = pos.y + dir.y
			local x2 = pos.x + dir.x
			if in_range(state, y2, x2) and
			   not in_ary(visited, y2, x2) and
			   not state.game.board[y2][x2].has_mine then
				table.insert(to_visit, {y=y2, x=x2})
			end
		end
		::next_cell::
	end

	return core.RC_SUCCESS
end

function core.flag_cell(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	--if state.game.board[y][x].revealed then
	--	return core.RC_INVALID_MOVE
	--end

	-- in single player, remove your own flag, if desired
	if #state.players == 1 and state.game.board[y][x].flagged_by_player == player then
		state.game.board[y][x].flagged_by_player = nil
		state.players[player].score = state.players[player].score - FLAG_MINE_SUCCESS_SCORE
		state.game.cells_unrevealed = state.game.cells_unrevealed + 1
		state.game.mines_unrevealed = state.game.mines_unrevealed + 1
	-- can only flag unflagged cells
	elseif state.game.board[y][x].flagged_by_player == nil then
		if state.players == 1 then
			state.game.board[y][x].flagged_by_player = player
		else
			local score_change
			if state.game.board[y][x].has_mine == true then
				state.game.board[y][x].flagged_by_player = player
				score_change = FLAG_MINE_SUCCESS_SCORE
				state.game.mines_unrevealed = state.game.mines_unrevealed - 1
			else
				state.game.board[y][x].revealed = true
				score_change = FLAG_MINE_FAIL_SCORE
				-- TODO need to communicate this state to the user, so animations can be shown
			end
			state.game.cells_unrevealed = state.game.cells_unrevealed - 1
			state.players[player].score = state.players[player].score + score_change
		end

		-- Now that Conway's game of life is introduced,
		-- it is possible to flag cells that were previously revealed, but will
		-- contain a mine on the next life update.
		-- TODO: it would be better to simply make the UI code render revealed and flagged
		-- cells as flagged instead of revealed, but I don't want to
		-- make that change just yet in case it turns out to be more complicated
		if state.game.board[y][x].has_mine then
			state.game.board[y][x].revealed = false
		else
			-- though if the user flagged a cell with no mine,
			-- reveal it anyway
			state.game.board[y][x].revealed = true
		end
	end

	return core.RC_SUCCESS
end

function core.reveal_neighbours(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end
	if not state.game.board[y][x].revealed then
		return
	end

	local flags_or_revealed_mines_nearby = 0

	for _, dir in ipairs(dirs) do
		local y2 = y + dir.y
		local x2 = x + dir.x

		if in_range(state, y2, x2) then
			local cell = state.game.board[y2][x2]
			if cell.revealed and cell.has_mine or
			   cell.flagged_by_player ~= nil then
				flags_or_revealed_mines_nearby = flags_or_revealed_mines_nearby + 1
			end
		end
	end

	if flags_or_revealed_mines_nearby >= state.game.board[y][x].touching_mine_count then
		local activity = false
		for _, dir in ipairs(dirs) do
			local y2 = y + dir.y
			local x2 = x + dir.x

			if in_range(state, y2, x2) then
				local cell = state.game.board[y2][x2]
				print(string.format("cell{y=%d,x=%d}: revealed %s, has_mine %s, flagged_by_player %s", y2, x2, cell.revealed, cell.has_mine, cell.flagged_by_player))
				if not cell.revealed and
				   not cell.has_mine and
				   cell.flagged_by_player == nil then
					core.reveal_cell(state, player, y2, x2)
					activity = true
				end
			end
		end
		if activity then
			return core.RC_SUCCESS
		else
			-- TODO remove
			print(string.format("Can not auto reveal due to no activity"))
		end
	end

	return core.RC_CAN_NOT_AUTO_REVEAL
	
end

function core.clicked_cell(state, player, y, x)
	if not in_range(state, y, x) then
		return core.RC_OUT_OF_RANGE
	end

	if state.game.board[y][x].revealed then
		return core.reveal_neighbours(state, player, y, x)
	elseif state.game.board[y][x].flagged_by_player == nil then
		return core.reveal_cell(state, player, y, x)
	end


end


return core

local core      = require("games/minesweeper_life/minesweeper_life_core")
local draw      = require("games/minesweeper_life/minesweeper_draw")
local serialize = require("games/minesweeper_life/minesweeper_serialize")

local wait_for_players = require("libs/multiplayer/wait_for_players")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local alex_c_api = require("alex_c_api")

-- TODO add:
--    * vibrate phone when flag has appeared? Show red circle so user knows when flag appears
--      even if it is covered by their finger?
--
-- TODO for multiplayer:
--    * TODO add a graphic for "cell is loading". For now it is probably fine to just leave it as unclicked because
--      of the low latency. (Actually, even on my LAN, I see a decent bit of latency when hosting on my phone and
--      using my laptop as a client.)
--    * animate points appearing over where you click 


-- maximum y or x distance that a player can move their finger/mouse before their gesture is no longer
-- interpreted as a click
local MAX_CLICK_MOVE = 2

local game_size_y = 20
local game_size_x = 20

local player = 1
local player_count = 1
local cell_size = core.cell_size
-- TODO initialize player state but not game state
local state = core.new_state(player_count, game_size_y, game_size_x, cell_size, core.DEFAULT_MINE_PORTION)
local win_anim_shown = false
local state_set = false
local g_session_id = alex_c_api.get_new_session_id()
local g_multiplayer_init = false
		
--local state = nil
local user_input_down = false
local user_input_down_timer_fired = false
local user_input_down_time = nil
local user_input_moved = false

-- These are only set on touchdown
local user_input_pos_y = nil
local user_input_pos_x = nil

-- These are updated on touchdown and touchmove events
local user_input_pos_move_y = nil
local user_input_pos_move_x = nil

local user_input2_pos_move_y = nil
local user_input2_pos_move_x = nil
local user_init_touch_dist  = nil
local user_offset_y = 0
local user_offset_x = 0
local active_touch  = nil
local active_touch2 = nil

local players = {
	[1] = "You",
}
local player = 1
local is_client = false
local player_name_to_idx = {}

local GAME_OPT_NEW_GAME = "game_opt_new_game"


local USER_INPUT_DOWN_TIME_THRESHOLD_MS = 300

local POPUP_ID_LEVEL_SEL = "popup_level_sel"

local DIFFICULTY_EASY = 0
local DIFFICULTY_MEDIUM = 1
local DIFFICULTY_HARD = 2

local levels = {
	{ label = "Single moving structure", premade = 1 },
	{ label = "Many moving structures", premade = 5 },
	{ label = "Single High entropy shape", premade = 6 },
	{ label = "Many high entropy shapes", premade = 2 },
	{ label = "Five period oscillator", premade = 3 },
	{ label = "16 period oscillator", premade = 4 },

	{ label = "",   portion = 0.25 },
	{ label = "",   portion = 0.30 },
	{ label = "",   portion = 0.35 },
	{ label = "",   portion = 0.45 },
	{ label = "",   portion = 0.45 },
	{ label = "",   portion = 0.55 },
	{ label = "",   portion = 0.65 },
	{ label = "",   portion = 0.75 },
}

local difficulty_btns = {}
for _, level in ipairs(levels) do
	local output = ""
	if #level.label > 0 then
		output = level.label .. " "
	end
	if level.portion then
		output = output .. string.format("Random (%.0f%% mines)", level.portion*100)
	end

	if level.premade then
		output = output .. string.format("Premade puzzle %d", level.premade)
	end
	table.insert(difficulty_btns, output)
end

local function prompt_level()
	show_buttons_popup.show_popup(POPUP_ID_LEVEL_SEL,
	                           "Select Puzzle Type",
	                           "Select a puzzle type",
	                           difficulty_btns)
end


local function handle_move_client(state, player, move, y, x)
	local msg = string.format("move:%d,%d,%d,%d", player, move, y, x)
	-- TODO only message the host in the future?
	alex_c_api.send_message("all", msg)
	return core.RC_SUCCESS
end

local function handle_move(state, player, move, y, x)
	local rc = nil
	if is_client then
		rc = handle_move_client(state, player, move, y, x)
	else
		rc = core.handle_move(state, player, move, y, x)
	end
	local state_serialized = serialize.serialize_state(state)
	if move == core.MOVE_FLAG_CELL then
		draw.draw_flag_flash = true
	end
	alex_c_api.save_state(g_session_id, state_serialized)

	if core.is_game_over(state) and not win_anim_shown then
		print('alex showing victory animation')
		win_anim_shown = true
		draw.victory_animation(60)
	end
end

local function check_for_input_time_done()
	if not user_input_down then
		return
	end

	local time_diff = alex_c_api.get_time_ms() - user_input_down_time
	if user_input_down and 
	   time_diff >= USER_INPUT_DOWN_TIME_THRESHOLD_MS and
		not user_input_moved and
		not user_input_down_timer_fired then
		user_input_down_timer_fired = true
		local cell_coords = draw.pos_to_cell_coords(state, player, user_input_pos_y, user_input_pos_x)
		handle_move(state, player, core.MOVE_FLAG_CELL, cell_coords.y, cell_coords.x)
		send_state_updates_if_host()
		draw_board()
	end
end

-- TODO change draw_board to some "update_evt" or something
function draw_board(dt_ms)
	if dt_ms ~= nil then
		draw.update(dt_ms)
	end
	draw.draw_state(state, player)
	check_for_input_time_done()
end

local function handle_user_input_down(pos_y, pos_x)
		user_input_down_time = alex_c_api.get_time_ms()
		user_input_down = true
		user_input_moved = false
		user_input_down_timer_fired = false
		user_input_pos_y = pos_y
		user_input_pos_x = pos_x
		user_input_pos_move_y = pos_y
		user_input_pos_move_x = pos_x
		user_offset_y = state.players[player].offset_y
		user_offset_x = state.players[player].offset_x
end

local function handle_user_input_release(pos_y, pos_x, cancel)
	if not cancel and not user_input_moved and not user_input_down_timer_fired then
		local cell_coords = draw.pos_to_cell_coords(state, player, pos_y, pos_x)
		local time_diff = alex_c_api.get_time_ms() - user_input_down_time
		local move_type = nil
		if time_diff <= USER_INPUT_DOWN_TIME_THRESHOLD_MS then
			move_type = core.MOVE_CLICK_CELL
		else
			move_type = core.MOVE_FLAG_CELL
		end
		handle_move(state, player, move_type, cell_coords.y, cell_coords.x)
		draw_board()
		send_state_updates_if_host()
	end
	user_input_down = false
	user_input_down_timer_fired = false
end

function handle_mouse_evt(evt_id, pos_y, pos_x)
	if evt_id == alex_c_api.MOUSE_EVT_DOWN then
		handle_user_input_down(pos_y, pos_x)
	elseif evt_id == alex_c_api.MOUSE_EVT_UP then
		handle_user_input_release(pos_y, pos_x, false)
	elseif evt_id == alex_c_api.MOUSE_EVT_LEAVE then
		handle_user_input_release(pos_y, pos_x, true)
	elseif evt_id == alex_c_api.MOUSE_EVT_ALT_DOWN then
		local cell_coords = draw.pos_to_cell_coords(state, player, pos_y, pos_x)
		handle_move(state, player, core.MOVE_FLAG_CELL, cell_coords.y, cell_coords.x)
	else
		print(string.format('unhandled evt_id %s', evt_id))
	end
end

local function handle_user_input_move(pos_y, pos_x)
	if user_input_down and (
	      math.abs(user_input_pos_y - pos_y) > MAX_CLICK_MOVE or
	      math.abs(user_input_pos_x - pos_x) > MAX_CLICK_MOVE) then
		user_input_moved = true
	end
	if user_input_down then
		local offset_adj_y = user_input_pos_y - pos_y
		local offset_adj_x = user_input_pos_x - pos_x
		user_input_pos_move_y = pos_y
		user_input_pos_move_x = pos_x
		core.adjust_offset(state, player,
			math.floor(user_offset_y + offset_adj_y),
			math.floor(user_offset_x + offset_adj_x))
		draw_board()
	end
end

function handle_mousemove(pos_y, pos_x)
	handle_user_input_move(pos_y, pos_x)
end

function handle_user_clicked()
end

local function get_touch_dist()
	local dy = user_input2_pos_move_y - user_input_pos_move_y
	local dx = user_input2_pos_move_x - user_input_pos_move_x
	return math.sqrt(dy*dy + dx*dx)
end

function handle_touch_evt(evt_id, changed_touches)
	for _, touch in ipairs(changed_touches) do
		if evt_id == 'touchstart' then
			if active_touch == nil then
				active_touch = touch.id
				handle_user_input_down(touch.y, touch.x)
			elseif active_touch2 == nil then
				active_touch2 = touch.id
				user_input_moved = true
				user_input2_pos_move_y = touch.y
				user_input2_pos_move_x = touch.x
				user_init_touch_dist = get_touch_dist()
				init_zoom = core.get_zoom_fact(state, player)
			end
		elseif evt_id == 'touchmove' then

			if active_touch == touch.id then
				handle_user_input_move(touch.y, touch.x)
			end

			if active_touch2 ~= nil then
				if active_touch2 == touch.id then
					user_input2_pos_move_y = touch.y
					user_input2_pos_move_x = touch.x
				end
				local touch_dist_fact = get_touch_dist() / user_init_touch_dist
				local zoom_fact = init_zoom * touch_dist_fact
				--alex_c_api.set_status_msg(
				--     string.format("Touch dist fact is %.3f, dist=%.0f, orig=%.0f",
				--                   touch_dist_fact, get_touch_dist(), user_init_touch_dist))
				core.set_zoom_fact(state, player, zoom_fact)
			end

		elseif evt_id == 'touchend' or
		       evt_id == 'touchcancel' then
			local is_cancel = (evt_id == 'touchcancel')
			if active_touch == touch.id then
				handle_user_input_release(touch.y, touch.x, is_cancel)
				active_touch = nil
			elseif active_touch2 == touch.id then
				active_touch2 = nil
			end
		end
	end
end

function handle_wheel_changed(dy, dx)
	print(string.format("handle_wheel(dy=%s, dx=%s)", dy, dx))

	local zoom_fact = core.get_zoom_fact(state, player)

	zoom_fact = zoom_fact + -dy/114 * 0.1

	core.set_zoom_fact(state, player, zoom_fact)

	draw_board()
end

function send_state_updates_if_host()
	print("send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
	if is_client and not wait_for_players.is_host_tentative() then
		print("return 1 send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
		return
	end

	if state == nil then
		print("return 2 send_state_updates_if_host", is_client, wait_for_players.is_host_tentative(),  state)
		return
	end

	for dst_player, player_name in pairs(wait_for_players.players_tentative()) do
		if dst_player == player then
			goto next_player
		end
		print("Sending state update")
		local state_msg = "state:" .. serialize.serialize_client_game_state(state, dst_player)
		alex_c_api.send_message(player_name, state_msg)
		::next_player::
	end
end

function apply_shape(state, shape, y, x)
	for dy=0,#shape-1 do
		for dx=0,#shape[1]-1 do
			if y+dy < state.game.height and
			   x+dx < state.game.width then
				state.game.board[y+dy][x+dx].has_mine = (shape[1+dy][1+dx] > 0)
			end
		end
	end

end

function new_game(player_count, level)
	print(string.format("Starting game with %d players, level %d", player_count, level))
	local puzzle_info = levels[level+1]
	if not puzzle_info.premade then
		local mine_portion = puzzle_info.portion
		print(string.format("Initializing game with mine portion %.0f%% (level idx %d)", mine_portion*100, level))
		alex_c_api.set_status_msg(string.format("Initializing game with mine portion %.0f%%", mine_portion*100))
		state = core.new_state(player_count, game_size_y, game_size_x, cell_size, mine_portion)
	elseif puzzle_info.premade == 1 or puzzle_info.premade == 5 then
		state = core.new_state(player_count, game_size_y, game_size_x, cell_size, 0)
		local shape1 = {
			{ 1, 0, 0},
			{ 0, 1, 1},
			{ 1, 1, 0},
		}

		if puzzle_info.premade == 1 then
			apply_shape(state, shape1, 2, 2)
		elseif puzzle_info.premade == 5 then
			local delta = 5
			for i=0,8 do
				for y=1,game_size_y,delta do
					apply_shape(state, shape1, y + delta*i, 2 + delta*i)
				end
			end
	
			local shape2 = {
				{ 0, 1, 1},
				{ 1, 1, 0},
				{ 0, 0, 1},
			}
	
			local delta = 5
			for i=0,8 do
				apply_shape(state, shape2, 2 + delta*i, 16 + delta*i)
				apply_shape(state, shape2, 2 + delta*i, 11 + delta*i)
			end
		end

		core.reveal_cell(state, 0, game_size_y, game_size_x)

		core.get_touching_mine_count(state)
	elseif puzzle_info.premade == 2 or puzzle_info.premade == 6 then
		state = core.new_state(player_count, 30, 30, cell_size, 0)
		shape = {
			{ 0, 1, 1},
			{ 1, 1, 0},
			{ 0, 1, 0},
		}

		if puzzle_info.premade == 6 then
				apply_shape(state, shape, 13, 13)
		elseif puzzle_info.premade == 2 then
			for y=4,state.game.height,8 do
				for x=4,state.game.width,8 do
					apply_shape(state, shape, y, x)
				end
			end
		end

		core.reveal_cell(state, 0, 30, 1)

		core.get_touching_mine_count(state)
	elseif puzzle_info.premade == 3 then
		state = core.new_state(player_count, game_size_y, game_size_x, cell_size, 0)
		shape = {
			{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0 },
			{ 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0 },
			{ 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1 },
			{ 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0 },
			{ 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0 },
			{ 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
		}

		apply_shape(state, shape, 3, 3)

		--core.reveal_cell(state, 0, game_size_y, game_size_x)

		core.get_touching_mine_count(state)

		alex_c_api.set_status_msg("Spoiler: See https://conwaylife.appspot.com/pattern/average for this pattern")
	elseif puzzle_info.premade == 4 then
		state = core.new_state(player_count, game_size_y, game_size_x, cell_size, 0)
		shape = {
			{ 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 },
			{ 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0 },
			{ 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
			{ 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1 },
			{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1 },
			{ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0 },
			{ 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0 },
			{ 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
			{ 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
		}

		apply_shape(state, shape, 2, 2)

		core.reveal_cell(state, 0, game_size_y, game_size_x)

		core.get_touching_mine_count(state)

		alex_c_api.set_status_msg("Spoiler: see https://conwaylife.appspot.com/pattern/achimsp16 for this pattern")
	else
		error(string.format("Unhandled premade index %s", puzzle_info.premade))
	end
	win_anim_shown = false
	g_session_id = alex_c_api.get_new_session_id()
end


local function start_host_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as host")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = false

	if not state_set then
		prompt_level()
	end
	send_state_updates_if_host()
	draw_board()
end

local function start_client_game(players_arg, player_arg, player_name_to_idx_arg)
	print("Starting game as client")
	players = players_arg
	player  = player_arg
	player_name_to_idx = player_name_to_idx_arg
	is_client = true
	-- TODO only initialize player_state here?
	state = core.new_state(#players, 20, 20, cell_size, core.DEFAULT_MINE_PORTION) -- TODO hacky to include mine portion here, this should never be used...
	-- no need to draw board here, a state update should soon follow
end

function handle_msg_received(src, msg)

	local handled = wait_for_players.handle_msg_received(src, msg)

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if handled and header ~= "joined" then
		return
	end

	if header == "state" then
		--if not is_client and not wait_for_players.is_host_tentative() then
		--	error("Received state as host")
		--end
		serialize.deserialize_client_game_state(state, payload)
	elseif header == "joined" then
		print("player_joined")
		send_state_updates_if_host()
	elseif header == "player_joined" or
	       header == "player_left" then
		-- ignore I guess?
	elseif header == "move" then
		if not is_client then
			local m2 = payload:gmatch("(%d+),(%d+),(%d+),(%d+)")
			if m2 == nil then
				error(string.format("invalid move payload %s", payload))
			end
			local player_str, move_type_str, y_str, x_str = m2()
			local player    = tonumber(player_str)
			local move_type = tonumber(move_type_str)
			local y         = tonumber(y_str)
			local x         = tonumber(x_str)

			if player ~= player_name_to_idx[src] then
				error(string.format("received move for player idx %s from player_name %s (%d)",
				      player, src, player_name_to_idx[src]))
			end
			handle_move(state, player, move_type, y, x)
			send_state_updates_if_host()
		end
	else
		error(string.format("Unhandled message %s", header))
	end

	send_state_updates_if_host()
	draw_board()
end


function handle_popup_btn_clicked(popup_id, btn_idx)
	local handled = wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if handled then
		return
	end

	if popup_id == POPUP_ID_LEVEL_SEL then
		new_game(#players, btn_idx)
		alex_c_api.hide_popup()

		if not g_multiplayer_init then
			wait_for_players.init(players, player, start_host_game, start_client_game)
		end
	else
		error(string.format("Unhandled popup id %s", popup_id))
	end
end

function handle_game_option_evt(game_opt_id, value)
	if game_opt_id == GAME_OPT_NEW_GAME then
		--new_game(#players)
		prompt_level()
		draw_board()
	end
end

local function load_state_offset(offset)
	local ui_states = core.copy_player_ui_states(state)
	local state_serialized = alex_c_api.get_saved_state_offset(g_session_id, offset) 
	if state_serialized ~= nil then
		state = serialize.deserialize_state(state_serialized)
		core.apply_player_ui_states(state, ui_states)
		draw.draw_state(state, player)
	end
end

function handle_btn_clicked(btn_id)
	if btn_id == draw.BTN_ID_UNDO then
		load_state_offset(-1)
	elseif btn_id == draw.BTN_ID_REDO then
		load_state_offset(1)
	end
end

function get_state()
	return serialize.serialize_state(state)
end

-- TODO need proper state saving

draw.init(480, 480, cell_size)

function start_game(session_id, state_serialized)
	if state_serialized ~= nil then
		g_session_id = session_id
		state = serialize.deserialize_state(state_serialized)
		state_set = true
	else
		local last_sess_id = alex_c_api.get_last_session_id()
		if last_sess_id ~= nil then
			state_serialized = alex_c_api.get_saved_state_offset(last_sess_id, 0) 
			g_session_id = last_sess_id
			state = serialize.deserialize_state(state_serialized)
			state_set = true
		end
	end

	if state_serialized ~= nil then
		wait_for_players.init(players, player, start_host_game, start_client_game)
		g_multiplayer_init = true
	else
		prompt_level()
	end

	alex_c_api.enable_evt("mouse_move")
	alex_c_api.enable_evt("mouse_updown")
	alex_c_api.enable_evt("mouse_alt_updown")
	alex_c_api.enable_evt("touch")
	alex_c_api.enable_evt("wheel")

	alex_c_api.add_game_option(GAME_OPT_NEW_GAME, {
		type  = alex_c_api.OPTION_TYPE_BTN,
		label = "New Game"
	})

	-- Kind of sucks that I only need this timer for measuring touch/mouse down time.
	-- Would be ideal if I could just set a 300 ms one off timer?
	alex_c_api.set_timer_update_ms(50)

end
local serialize = {}

local bit_pack = require("libs/serialize/bit_pack")
local core = require("games/minesweeper_life/minesweeper_life_core")

serialize.VERSION = 1
local serialize_lib = require("libs/serialize/serialize")

local function serialize_cell_for_client(cell)
	if not cell.revealed then
		if cell.flagged_by_player == nil then return 0
		else return 10 + cell.flagged_by_player end
	else
		if cell.has_mine then return 10
		else
			if cell.touching_mine_count > 0 then
				return cell.touching_mine_count
			else
				return 9
			end
		end
	end
end

local function client_deserialize_cell(bytes)
	local byte = table.remove(bytes, 1)
	byte = string.byte(byte)
	local cell = {
		revealed = false,
		has_mine = false,
		flagged_by_player = nil,
		touching_mine_count = nil,
	}
	if byte == 0 then
		-- pass
	elseif 11 <= byte and byte <= 14 then
		cell.flagged_by_player = byte - 10
	elseif byte == 10 then
		cell.revealed = true
		cell.has_mine = true
	elseif byte == 9 then
		cell.revealed = true
		cell.touching_mine_count = 0
	elseif 1 <= byte and byte <= 8 then
		cell.revealed = true
		cell.touching_mine_count = byte
	else
		error(string.format("unexpected serialized cell byte=%s", byte))
	end

	return cell
end

function serialize.serialize_client_game_state(state, player)
	local game_state = state.game
	local output = ""
	output = output .. serialize_lib.serialize_byte(#state.players)
	output = output .. serialize_lib.serialize_16bit(game_state.width)
	output = output .. serialize_lib.serialize_16bit(game_state.height)
	for i=1,#state.players do
		local player_state = state.players[i]
		output = output .. serialize_lib.serialize_s32(player_state.score)
	end
	for y=1,game_state.height do
		for x=1,game_state.width do
			local serialized_cell = serialize_cell_for_client(game_state.board[y][x])
			output = output .. serialize_lib.serialize_byte(serialized_cell)
		end
	end
	return output
end

function serialize.deserialize_client_game_state(state, bytes)
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local game_state = state.game
	local player_count      = serialize_lib.deserialize_byte(bytes)
	game_state.width        = serialize_lib.deserialize_16bit(bytes)
	game_state.height       = serialize_lib.deserialize_16bit(bytes)
	for i=1,player_count do
		if state.players[i] == nil then
			error(string.format("player idx %d not in map when len %d", i, #state.players))
		end
		state.players[i].score = serialize_lib.deserialize_s32(bytes)
	end
	game_state.board = {}
	for y=1,game_state.height do
		game_state.board[y] = {}
		for x=1,game_state.width do
			game_state.board[y][x] = client_deserialize_cell(bytes)
		end
	end
	return game_state
end

local function serialize_cell_concise(cell)
	local val = 0
	if cell.flagged_by_player ~= nil then val = val | 0x4 end
	if cell.revealed                 then val = val | 0x2 end
	if cell.has_mine                 then val = val | 0x1 end

	return val
end

local function deserialize_cell_concise(val)
	local cell = {}
	cell.flagged_by_player = (val & 0x4) > 0
	if cell.flagged_by_player then
		cell.flagged_by_player = 1
	else
		cell.flagged_by_player = nil
	end
	cell.revealed          = (val & 0x2) > 0
	cell.has_mine          = (val & 0x1) > 0
	return cell
end

local function serialize_cells_concise(cells)
	local cells_3bits = {} 
	for y=1,#cells do
		for x=1,#cells[1] do
			table.insert(cells_3bits, serialize_cell_concise(cells[y][x]))
		end
	end

	return bit_pack.pack(cells_3bits, 3)
end

local function deserialize_cells_concise(cells_bytes)
	local cells = {}
	for y=1,#cells_bytes do
		local row = {}
		for x=1,#cells_bytes[1] do
			table.insert(row, deserialize_cell_concise(cells_bytes[y][x]))
		end
		table.insert(cells, row)
	end
	return cells
end

local function unflatten(cells_flat, height, width)
	local cells = {}
	for y=1,height do
		local row = {}
		for x=1,width do
			table.insert(row, cells_flat[(y-1)*width + x] )
		end
		table.insert(cells, row)
	end
	return cells
end


function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(serialize.VERSION)
	output = output .. serialize_lib.serialize_byte(state.game.height)
	output = output .. serialize_lib.serialize_byte(state.game.width)
	output = output .. serialize_lib.serialize_bytes(serialize_cells_concise(state.game.board))
	return output
end

function serialize.deserialize_state(bytes)
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local state = {
		game = {},
	}
	local version = serialize_lib.deserialize_byte(bytes)
	if version ~= serialize.VERSION then
		error(string.format("Can only deserialize state version %d, found %d", serialize.VERSION, version))
	end
	state.game.height = serialize_lib.deserialize_byte(bytes)
	state.game.width  = serialize_lib.deserialize_byte(bytes)

	local cells_flat_bytes_packed = serialize_lib.deserialize_bytes(bytes)
	local cells_flat_serialized = bit_pack.unpack(cells_flat_bytes_packed, 3)
	local cells_bytes = unflatten(cells_flat_serialized, state.game.height, state.game.width)
	state.game.board = deserialize_cells_concise(cells_bytes)

	core.calc_state_vals(state)

	state.players = {
		core.new_player_state(),
	}

	return state
end

return serialize
local core = {}

core.ACTION_CHECK = "check"
core.ACTION_CALL  = "call"
core.ACTION_RAISE = "raise"
core.ACTION_FOLD  = "fold"

core.RC_SUCCESS       =  0
core.RC_BET_TOO_SMALL = -1

function core.action_to_string(action)
	if action.action == core.ACTION_RAISE then
		return string.format("(%s: %d)", action.action, action.param)
	else
		return string.format("(%s)", action.action)
	end
end

function core.rc_to_string(rc)
	local rc_strings = {
		[core.RC_SUCCESS]       = "Success",
		[core.RC_BET_TOO_SMALL] = "Bet too small",
	}
	return rc_strings[rc]
end

function core.add_player(state, name, chips)
	local player_state = {
		name   = name,
		chips  = chips,
		bet    = 0,
		folded = false,

		-- To be displayed in UI
		last_action = nil,
		last_bet    = nil,
	}
	table.insert(state.players, player_state)
end

function core.get_pot_string(pots)
	if #pots == 0 then return "0"
	else
		-- TODO This is a placeholder.
		-- I don't think it will actually be a list of integers like this,
		-- but I don't know what it will look like yet.
		-- I assume each side pot would need a list of players eligible to receive it.
		-- I don't actually know the rules... if someone goes all-in and creates a side pot, and wins,
		-- who gets the other pots? Are they returned?
		local s = ""
		if #pots > 1 then s = s .. "{" end
		for pot_idx, pot in ipairs(pots) do
			if pot_idx ~= 1 then
				s = s .. ', '
			end
			s = s .. pot
		end
		if #pots > 1 then s = s .. "}" end
		return s
	end
end

function core.new_state()
	local state = {
		pots        = {0},
		players     = {},
		min_bet     = 0,
		player_turn = 1,
		last_player_min_bet = nil,
	}

	return state
end

function core.print_state(state)
	print(string.format("players (len: %d) = {", #state.players))
	for player_idx, player_state in ipairs(state.players) do
		print(string.format("[%d] = { name: \"%s\", chips: %d, bet: %d, folded: %s }",
		                    player_idx, player_state.name,
		                    player_state.chips, player_state.bet, player_state.folded))
	end
	print("}")
end

local function get_player_name(state, player_idx)
	if state.players[player_idx] == nil then
		error(string.format("Player %s not found", player_idx), 2)
	end

	return string.format("%d (\"%s\")", player_idx, state.players[player_idx].name)
end

local function handle_player_bet(state, player_idx, bet)
	print(string.format("Player %s making bet %d", get_player_name(state, player_idx), bet))
	
	local action
	if bet < state.min_bet then
		return core.RC_BET_TOO_SMALL
	elseif bet == 0 then
		action = core.ACTION_CHECK
	elseif bet == state.min_bet then
		action = core.ACTION_CALL
	elseif bet > state.min_bet then
		action = core.ACTION_RAISE
	else
		-- I don't think this is possible unless bet is negative or something
		error(string.format("could not handle bet=%s, state.min_bet=%s", bet, state.min_bet))
	end

	local player_state = state.players[player_idx]
	local bet_increase = bet -- TODO should change this to "bet_increase"?
	player_state.bet         = player_state.bet + bet
	player_state.chips       = player_state.chips - bet
	player_state.last_action = action
	player_state.last_bet    = bet

	state.min_bet = bet
	-- TODO figure out how to handle side pots
	print(string.format("pots: %d, %s", #state.pots, state.pots))
	state.pots[1] = state.pots[1] + bet_increase
	if action == core.ACTION_RAISE then
		state.last_player_min_bet = player_idx
	end

	return core.RC_SUCCESS
end

local function next_player(state)
	print(string.format("Advancing to next player, after player %s", get_player_name(state, state.player_turn)))

	for _=1,#state.players do
		state.player_turn = (state.player_turn % #state.players) + 1

		if state.players[state.player_turn].folded then
			print(string.format("Skipping player %d (%s), as they folded",
			                    state.player_turn, state.players[state.player_turn].name))
			goto next_player
		else
			break
		end

		::next_player::
	end
	if state.players[state.player_turn].folded then
		-- TODO handle case where everyone has folded
	end
	print(string.format("Now it is player's turn: %s", get_player_name(state, state.player_turn)))

	-- TODO need something to call attention to the case where everyone has bet,
	-- to tell dealer to draw another card
end

function core.handle_action(state, action)
	if action.action == core.ACTION_CHECK then
		local rc = handle_player_bet(state, state.player_turn, 0)
		if rc ~= core.RC_SUCCESS then
			return rc
		end
		next_player(state)
	elseif action.action == core.ACTION_CALL then
		local rc = handle_player_bet(state, state.player_turn, state.min_bet)
		if rc ~= core.RC_SUCCESS then
			return rc
		end
		next_player(state)
	elseif action.action == core.ACTION_RAISE then
		local bet = action.param
		local rc = handle_player_bet(state, state.player_turn, bet)
		if rc ~= core.RC_SUCCESS then
			return rc
		end
		next_player(state)
	elseif action.action == core.ACTION_FOLD then
		print(string.format("Player %s has folded", get_player_name(state, state.player_turn)))
		state.players[state.player_turn].folded = true
		state.players[state.player_turn].last_action = core.ACTION_FOLD
		state.players[state.player_turn].last_bet    = 0
		next_player(state)
	else
		error(string.format("Unhandled action type %s", action.action))
		-- TODO notify remote player (client)
	end

	return core.RC_SUCCESS
end

return core
-- Author: Alex Barry (github.com/alexbarry)
--
--[[

Should support both:
* "local" multiplayer (where a single user is using this app to track all players' bets/pots), or
* network multiplayer (where all players are using this app on their phones/computers and entering their own bets)


Expected sequence for network multiplayer:
* new player starts app, acts as host
* sends message to all, asking for state if anyone is host
* if receives a message from someone claiming to be a host, change to client, and load received state

TODO:
* need to show raising as relative to min bet
	* when raising, need to set "min bet" in keypad UI
* show dashed line above person who last raised

--]]
local alex_c_api  = require("alex_c_api")
local ui = require("games/poker_chips/poker_chips_ui")
local core = require("games/poker_chips/poker_chips_core")
local serialize = require("games/poker_chips/poker_chips_serialize")

local wait_for_players = require("libs/multiplayer/wait_for_players")
--local two_player = require("libs/multiplayer/two_player")


local player = 1

local players = {
	[1] = "You",
}


local SHOW_TEST_DATA = true


local state = {
	game = nil,
	ui   = nil,
}
state.game = core.new_state()

function get_player()
	-- TODO handle network multiplayer
	return state.game.player_turn
end

if SHOW_TEST_DATA then
	core.add_player(state.game, "Alex",    135)
	core.add_player(state.game, "Conor",   205)
	core.add_player(state.game, "Justin",   55)
	core.add_player(state.game, "Nick",    175)
	core.add_player(state.game, "Marc",    100)
	core.add_player(state.game, "Liam",    335)
	core.add_player(state.game, "Pranav",  220)
	core.add_player(state.game, "Shubham",  95)
end

core.print_state(state.game)

state.ui = ui.init()
ui.update(state.ui, state.game, get_player())

function draw_board() 
	ui.draw(state.ui)
end

local function update_state()
	for _, player in pairs(players) do
		if player == "You" then goto next_player end
		local serialized_state = serialize.serialize_state(state.game)
		print(string.format("Broadcasting state to player \"%s\", bytes %d", player, #serialized_state))
		alex_c_api.send_message(player, "state:" .. serialized_state)
		::next_player::
	end

end

function handle_user_string_input(str_input, is_cancelled)
	print(string.format("handle_user_string_input(str_input=\"%s\", is_cancelled=%q)", str_input, is_cancelled))
	alex_c_api.set_status_msg(string.format("handle_user_string_input(str_input=\"%s\", is_cancelled=%q)", str_input, is_cancelled))
end

function handle_user_clicked(y_pos, x_pos)
	local actions = ui.handle_user_clicked(state.ui, y_pos, x_pos)
	for _, action in ipairs(actions) do
		alex_c_api.set_status_msg(string.format("Received action %s", core.action_to_string(action)))
		local rc = core.handle_action(state.game, action)
		if rc ~= core.RC_SUCCESS then
			if rc == core.RC_BET_TOO_SMALL then
				alex_c_api.set_status_err(string.format("Your bet (%d) is lower than the minimum bet (%d)", action.param, state.game.min_bet))
			else
				alex_c_api.set_status_err(core.rc_to_string(rc))
			end
		else
			update_state()
			if action.on_success_callback ~= nil then
				action.on_success_callback()
			end
		end
	end
	ui.update(state.ui, state.game, get_player())
	ui.draw(state.ui)
end


function handle_popup_btn_clicked(popup_id, btn_idx)
	if wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx) then
		-- handled
	else
		error(string.format("Unhandled popup_id=%s, btn_idx=%s", popup_id, btn_idx))
	end
end


function handle_msg_received(src, msg)
	if wait_for_players.handle_msg_received(src, msg) then
		return
	end

	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "state" then
		print(string.format("Received state from \"%s\", bytes %d", src, #payload))
		local received_state = serialize.deserialize_state(payload)
		state.game = received_state
		ui.update(state.ui, state.game, get_player())
		draw_board()
	else
		error(string.format("Unhandled message: %s", header))
	end

end

function start_host_game()
	-- TODO
end

function start_client_game()
	-- TODO
end

function start_game()
	wait_for_players.init(players, player, start_host_game, start_client_game)
end
local serialize = {}

local serialize_lib = require("libs/serialize/serialize")

local function serialize_player_state(player_state)
	local output = ""
	output = output .. serialize_lib.serialize_string(player_state.name)
	output = output .. serialize_lib.serialize_s32(player_state.chips)
	output = output .. serialize_lib.serialize_s32(player_state.bet)
	output = output .. serialize_lib.serialize_bool(player_state.folded)
	output = output .. serialize_lib.serialize_string(player_state.last_action)
	output = output .. serialize_lib.serialize_s32_nilable(player_state.last_bet)

	return output
end

local function deserialize_player_state(bytes)
	local player_state = {}
	player_state.name        = serialize_lib.deserialize_string(bytes)
	player_state.chips       = serialize_lib.deserialize_s32(bytes)
	player_state.bet         = serialize_lib.deserialize_s32(bytes)
	player_state.folded      = serialize_lib.deserialize_bool(bytes)
	player_state.last_action = serialize_lib.deserialize_string(bytes)
	player_state.last_bet    = serialize_lib.deserialize_s32_nilable(bytes)

	return player_state
end

local function serialize_pots(pots)
	local output = ""
	output = output .. serialize_lib.serialize_byte(#pots)
	for _, pot in ipairs(pots) do
		output = output .. serialize_lib.serialize_s32(pot)
	end
	return output
end

local function deserialize_pots(bytes)
	local pots = {}
	local pot_count = serialize_lib.deserialize_byte(bytes)
	for i=1,pot_count do
		pots[i] = serialize_lib.deserialize_s32(bytes)
	end
	return pots
end

function serialize.deserialize_state(bytes_str)
	local bytes = serialize_lib.bytestr_to_byteary(bytes_str)
	print("deserializing " .. #bytes .. " bytes")
	local state = {}
	state.pots = deserialize_pots(bytes)
	local player_count = serialize_lib.deserialize_byte(bytes)
	state.players = {}
	for i=1,player_count do
		state.players[i] = deserialize_player_state(bytes)
	end
	state.min_bet             = serialize_lib.deserialize_s32(bytes)
	state.player_turn         = serialize_lib.deserialize_byte(bytes)

	if #bytes ~= 0 then
		error(string.format("%d bytes leftover after deserializing", #bytes))
	end


	return state
end

function serialize.serialize_state(state)
	local output = ""
	output = output .. serialize_pots(state.pots)
	output = output .. serialize_lib.serialize_byte(#state.players)
	for _, player_state in ipairs(state.players) do
		output = output .. serialize_player_state(player_state)
	end
	output = output .. serialize_lib.serialize_s32(state.min_bet)
	output = output .. serialize_lib.serialize_byte(state.player_turn)

	return output
end

return serialize
-- Author: Alex Barry (github.com/alexbarry)
local ui = {}

local alex_c_api = require("alex_c_api")
local ui_pane_bet_input   = require("games/poker_chips/ui/bet_input")
local ui_pane_control     = require("games/poker_chips/ui/control")
local ui_pane_view_others = require("games/poker_chips/ui/view_others")
local core = require("games/poker_chips/poker_chips_core")

local ui_params = {
	board_height = 480,
	board_width  = 480,
	margin = 20,
	padding             = 5,
	big_padding         = 15,
	BTN_TEXT_SIZE       = 24,
	BTN_BG_COLOUR       = '#ccccffaa',
	BTN_FG_COLOUR       = '#000000',
	BTN_FG_COLOUR_FADED = '#aaaaaa',
	BTN_OUTLINE_COLOUR  = '#000000',
	BTN_OUTLINE_WIDTH   = 1,
	BTN_TEXT_SIZE       = 24,
	info_text_size      = 18,

}

local function add_action(ui_state, action)
	table.insert(ui_state.actions, action)
end

local function init_control_menu()
end

function ui.init()
	local ui_state = {
		panes = {},
		actions = {},
	}

	ui_state.panes.view_others = ui_pane_view_others.init(ui_params, {
		move_to_control_state = function ()
			ui_state.active_state = ui_state.panes.control
		end,
	})

	ui_state.panes.bet_input = ui_pane_bet_input.init(ui_params, {
		move_to_control_state = function ()
			ui_state.active_state = ui_state.panes.control
		end,
		move_to_view_others_state = function ()
			ui_state.active_state = ui_state.panes.view_others
		end,

		add_action = function (action)
			add_action(ui_state, action)
		end,
	})

	ui_state.panes.control   = ui_pane_control.init(ui_params, {
		move_to_raise_state = function ()
			ui_state.active_state = ui_state.panes.bet_input
		end,
		move_to_view_others_state = function ()
			ui_state.active_state = ui_state.panes.view_others
		end,
		add_action = function (action)
			add_action(ui_state, action)
		end,
	})
	ui_state.active_state = ui_state.panes.view_others
	return ui_state
end

function ui.draw(ui_state)
	alex_c_api.draw_clear()
	ui_state.active_state.draw(ui_state.active_state)
end

function ui.update(ui_state, game_state, player_idx)
	print("ui.update called")
	for _, pane in pairs(ui_state.panes) do
		pane.update(pane, game_state, player_idx)
	end
end

function ui.handle_user_clicked(ui_state, y_pos, x_pos)
	ui_state.active_state.handle_user_clicked(ui_state.active_state, y_pos, x_pos)
	local actions = ui_state.actions
	ui_state.actions = {}
	return actions
end

return ui
-- Author: Alex Barry (github.com/alexbarry)
local bet_input = {}

local soft_numpad = require("libs/ui/soft_numpad")
local buttons = require("libs/ui/buttons")

local core = require("games/poker_chips/poker_chips_core")

local alex_c_api  = require("alex_c_api")


local g_ui_params = nil

local BTN_ID_ADJ_MINUS_5 = "adjust_minus5"
local BTN_ID_ADJ_MINUS_1 = "adjust_minus1"
local BTN_ID_ADJ_PLUS_1  = "adjust_plus1"
local BTN_ID_ADJ_PLUS_5  = "adjust_plus5"

local BTN_ID_SUBMIT_BET  = "submit_bet"
local BTN_ID_BACK        = "back"

BTN_ADJ_ID_TO_AMOUNT = {
	[BTN_ID_ADJ_MINUS_5] = -5,
	[BTN_ID_ADJ_MINUS_1] = -1,
	[BTN_ID_ADJ_PLUS_1]  =  1,
	[BTN_ID_ADJ_PLUS_5]  =  5,
}

local function get_numpad_val(numpad_val)
	if #numpad_val == 0 then return 0
	else
		return tonumber(numpad_val)
	end
end

local function adjust_bet(bet_input_state, inc)
	local bet_val = get_numpad_val(soft_numpad.get_val(bet_input_state.numpad))
	bet_val = tonumber(bet_val) + inc
	-- TODO need to get numpad val, or update numpad val here
	if bet_val < 0 then
		bet_val = 0
	elseif bet_val > bet_input_state.max_bet then
		bet_val = bet_input_state.max_bet
	end

	soft_numpad.set_val(bet_input_state.numpad, bet_val)
end

local function new_button(buttons_state, params)
	if params.callback == nil then
		error(string.format("missing callback"), 2)
	end
	buttons.new_button(buttons_state, {
		id             = params.id,
		text           = params.text,
		bg_colour      = g_ui_params.BTN_BG_COLOUR,
		fg_colour      = g_ui_params.BTN_FG_COLOUR,
		outline_colour = g_ui_params.BTN_OUTLINE_COLOUR,
		outline_width  = g_ui_params.BTN_OUTLINE_WIDTH,
		btn_shape      = params.btn_shape,
		shape_param    = params.shape_param,
		text_size      = g_ui_params.BTN_TEXT_SIZE,
		padding        = g_ui_params.padding,
		y_start        = params.y_start,
		x_start        = params.x_start,
		y_end          = params.y_end,
		x_end          = params.x_end,
		callback       = params.callback,

	})
end


local function bet_input_button_pressed(bet_input_state, btn_id)
	if BTN_ADJ_ID_TO_AMOUNT[btn_id] then
		local inc = BTN_ADJ_ID_TO_AMOUNT[btn_id]
		adjust_bet(bet_input_state, inc)
	elseif btn_id == BTN_ID_SUBMIT_BET then
		bet_input_state.add_action({
			action              = core.ACTION_RAISE,
			param               = get_numpad_val(soft_numpad.get_val(bet_input_state.numpad)),
			on_success_callback = function () 
				soft_numpad.set_val(bet_input_state.numpad, "")
				bet_input_state.move_to_view_others_state()	
			end,
			})
	elseif btn_id == BTN_ID_BACK then
		bet_input_state.move_to_control_state()
	end
	bet_input_state.draw(bet_input_state)
end

function bet_input.init(ui_params, bet_input_params)
	g_ui_params = ui_params
	top_info_height = 50
	num_button_rows = 7
	local button_y_size = math.floor((g_ui_params.board_height - 2*g_ui_params.margin - top_info_height - g_ui_params.big_padding)/num_button_rows)
	
	local BACK_BUTTON_WIDTH = 135

	local ADJUST_BUTTON_Y_START = g_ui_params.margin + top_info_height
	local CENTRE_MONEY_INDICATOR_WIDTH = 150
	local CENTRE_MONEY_INDICATOR_X_MIDDLE = math.floor(g_ui_params.board_width/2)
	local ADJUST_BUTTON_HEIGHT = 75
	local ADJUST_BUTTON_HEIGHT = button_y_size
	
	local BET_BUTTON_HEIGHT = button_y_size
	
	
	local NUMPAD_Y_START     = ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT + g_ui_params.big_padding
	local NUMPAD_Y_END       = g_ui_params.board_height - g_ui_params.margin - BET_BUTTON_HEIGHT
	
	
	local BTN_SUBMIT_BET_Y_START = NUMPAD_Y_END + g_ui_params.padding
	local BTN_SUBMIT_BET_Y_END   = g_ui_params.board_height - g_ui_params.margin

	local bet_input_state = {
		-- TODO
		max_bet = 100,
		chips   = 135,
		pots     =  {30},
		move_to_control_state     = bet_input_params.move_to_control_state,
		move_to_view_others_state = bet_input_params.move_to_view_others_state,
		add_action                = bet_input_params.add_action,
	}
	bet_input_state.numpad = soft_numpad.init({
		y_start = NUMPAD_Y_START,
		y_end   = NUMPAD_Y_END,

		x_start = g_ui_params.margin,
		x_end   = g_ui_params.board_width - g_ui_params.margin,

		btn_bg_colour  = g_ui_params.BTN_BG_COLOUR,
		btn_fg_colour  = g_ui_params.BTN_FG_COLOUR,
		outline_colour = g_ui_params.BTN_OUTLINE_COLOUR,
		outline_width  = g_ui_params.BTN_OUTLINE_WIDTH,
	})

	local callback = function (btn_id)
		bet_input_button_pressed(bet_input_state, btn_id)
	end

	local adjust_button_width = math.floor((g_ui_params.board_width-2*g_ui_params.margin - CENTRE_MONEY_INDICATOR_WIDTH)/4)
	bet_input_state.buttons = buttons.new_state()

	new_button(bet_input_state.buttons, {
		id   = BTN_ID_BACK,
		text = 'Back',
		y_start = g_ui_params.margin,
		y_end   = g_ui_params.margin + top_info_height - g_ui_params.padding,
		x_start = g_ui_params.margin,
		x_end   = g_ui_params.margin + BACK_BUTTON_WIDTH,

		callback    = callback,
	})

	--buttons.new_button(bet_input_state.buttons, {
	new_button(bet_input_state.buttons, {
		id   = BTN_ID_ADJ_MINUS_5,
		text = '-5',
		y_start = ADJUST_BUTTON_Y_START,
		y_end   = ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT,
		x_start = g_ui_params.margin,
		x_end   = g_ui_params.margin + adjust_button_width,

		btn_shape   = buttons.BTN_SHAPE_TRIANGLE,
		shape_param = true,
		callback    = callback,
	})
	new_button(bet_input_state.buttons, {
		id   = BTN_ID_ADJ_MINUS_1,
		text = '-1',
		y_start = ADJUST_BUTTON_Y_START,
		y_end   = ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT,
		x_start = g_ui_params.margin + adjust_button_width + g_ui_params.padding,
		x_end   = g_ui_params.margin + 2*adjust_button_width + g_ui_params.padding,

		btn_shape   = buttons.BTN_SHAPE_TRIANGLE,
		shape_param = true,
		callback    = callback,
	})
	new_button(bet_input_state.buttons, {
		id   = BTN_ID_ADJ_PLUS_1,
		text = '+1',
		y_start = ADJUST_BUTTON_Y_START,
		y_end   = ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT,
		x_start = g_ui_params.board_width - g_ui_params.margin - 2*adjust_button_width - 2*g_ui_params.padding,
		x_end   = g_ui_params.board_width - g_ui_params.margin -   adjust_button_width - 2*g_ui_params.padding,

		btn_shape   = buttons.BTN_SHAPE_TRIANGLE,
		shape_param = false,
		callback    = callback,
	})
	new_button(bet_input_state.buttons, {
		id   = BTN_ID_ADJ_PLUS_5,
		text = '+5',
		y_start = ADJUST_BUTTON_Y_START,
		y_end   = ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT,
		x_start = g_ui_params.board_width - g_ui_params.margin - adjust_button_width - g_ui_params.padding,
		x_end   = g_ui_params.board_width - g_ui_params.margin - 0*adjust_button_width - g_ui_params.padding,

		btn_shape   = buttons.BTN_SHAPE_TRIANGLE,
		shape_param = false,
		callback    = callback,
	})

	new_button(bet_input_state.buttons, {
		id   = BTN_ID_SUBMIT_BET,
		text = 'Submit bet',
		y_start = BTN_SUBMIT_BET_Y_START,
		y_end   = BTN_SUBMIT_BET_Y_END,
		x_start = g_ui_params.margin,
		x_end   = g_ui_params.board_width - g_ui_params.margin,
		callback    = callback,
	})
	bet_input_state.draw = function (bet_input_state)
		soft_numpad.draw(bet_input_state.numpad)
		buttons.draw(bet_input_state.buttons)
		local numpad_val = get_numpad_val(soft_numpad.get_val(bet_input_state.numpad))
		local bet_val_str = string.format("$%s", numpad_val)
		local text_size = 18
		local text_y_start = math.floor(ADJUST_BUTTON_Y_START + ADJUST_BUTTON_HEIGHT/2 + text_size/2)
		alex_c_api.draw_text(bet_val_str, '#000000', text_y_start, CENTRE_MONEY_INDICATOR_X_MIDDLE, text_size, 0)
		alex_c_api.draw_text(string.format("Your chips: $%d", bet_input_state.chips), '#000000',
		                     g_ui_params.margin + text_size, g_ui_params.margin + BACK_BUTTON_WIDTH + g_ui_params.padding, text_size, 1)
		alex_c_api.draw_text(string.format("Pot: %s", core.get_pot_string(bet_input_state.pots)), '#000000',
		                     g_ui_params.margin + text_size, g_ui_params.board_width - g_ui_params.margin, text_size, -1)
	end
	bet_input_state.handle_user_clicked = function(bet_input_state, y_pos, x_pos)
		soft_numpad.on_user_click(bet_input_state.numpad, y_pos, x_pos)
		buttons.on_user_click(bet_input_state.buttons, y_pos, x_pos)
	end

	bet_input_state.update = function (bet_input_state, game_state, player_idx)
		print(string.format("bet_input_state(player_idx=%d)", player_idx))
		bet_input_state.max_bet = game_state.players[player_idx].chips
		bet_input_state.chips   = game_state.players[player_idx].chips
		bet_input_state.pots    = game_state.pots
	end
	return bet_input_state
end

return bet_input
-- Author: Alex Barry (github.com/alexbarry)
local control = {}

local buttons = require("libs/ui/buttons")
local alex_c_api  = require("alex_c_api")

local core = require("games/poker_chips/poker_chips_core")

local BTN_ID_VIEW_OTHERS_CHIPS = "view_others_chips"
local BTN_ID_CHECK  = "check"
local BTN_ID_CALL   = "call"
local BTN_ID_RAISE  = "raise"
local BTN_ID_FOLD   = "fold"

local g_ui_params = nil

local function new_button(buttons_state, params)
	if params.callback == nil then
		error(string.format("missing callback"), 2)
	end
	buttons.new_button(buttons_state, {
		id             = params.id,
		text           = params.text,
		bg_colour      = g_ui_params.BTN_BG_COLOUR,
		fg_colour      = g_ui_params.BTN_FG_COLOUR,
		outline_colour = g_ui_params.BTN_OUTLINE_COLOUR,
		outline_width  = g_ui_params.BTN_OUTLINE_WIDTH,
		btn_shape      = params.btn_shape,
		shape_param    = params.shape_param,
		text_size      = g_ui_params.BTN_TEXT_SIZE,
		padding        = padding,
		y_start        = params.y_start,
		x_start        = params.x_start,
		y_end          = params.y_end,
		x_end          = params.x_end,
		callback       = params.callback,

	})
end

local function btn_pressed(control_state, btn_id)
	if btn_id == BTN_ID_VIEW_OTHERS_CHIPS then
		control_state.move_to_view_others_state()
	elseif btn_id == BTN_ID_CHECK then
		control_state.move_to_view_others_state()
		control_state.add_action({ action = core.ACTION_CHECK })
	elseif btn_id == BTN_ID_CALL then
		control_state.move_to_view_others_state()
		control_state.add_action({ action = core.ACTION_CALL })
	elseif btn_id == BTN_ID_RAISE then
		control_state.move_to_raise_state()
	elseif btn_id == BTN_ID_FOLD then
		control_state.move_to_view_others_state()
		control_state.add_action({ action = core.ACTION_FOLD })
	end
end

local function set_game_state(control_state, game_state, player_idx)
	buttons.set_enabled(control_state.buttons, BTN_ID_CHECK, game_state.min_bet == 0)
	buttons.set_enabled(control_state.buttons, BTN_ID_CALL,  game_state.min_bet > 0)
	local call_text = "Call"
	if game_state.min_bet > 0 then
		call_text = call_text .. string.format(" (+$%d)", game_state.min_bet)
	end
	buttons.set_text(control_state.buttons, BTN_ID_CALL, call_text)
end

function control.init(ui_params, control_params)
	g_ui_params = ui_params
	local control_state = {}
	control_state.buttons = buttons.new_state()
	control_state.move_to_raise_state       = control_params.move_to_raise_state
	control_state.move_to_view_others_state = control_params.move_to_view_others_state 
	control_state.add_action                = control_params.add_action

	local callback = function (btn_id) btn_pressed(control_state, btn_id) end
	local btn_infos = {
		{ id = BTN_ID_VIEW_OTHERS_CHIPS, text = 'View others\' chips', extra_space = g_ui_params.big_padding },
		{ id = BTN_ID_CHECK,             text = 'Check' },
		{ id = BTN_ID_CALL,              text = 'Call'  },
		{ id = BTN_ID_RAISE,             text = 'Raise' },
		{ id = BTN_ID_FOLD,              text = 'Fold'  },
	}
	local y_pos = 100
	local button_height = math.floor((g_ui_params.board_height - y_pos - g_ui_params.big_padding) / 5) - g_ui_params.padding
	for btn_idx, btn_info in ipairs(btn_infos) do
		new_button(control_state.buttons, {
			id   = btn_info.id,
			text = btn_info.text,
			y_start = y_pos,
			y_end   = y_pos + button_height,
			x_start = g_ui_params.margin,
			x_end   = g_ui_params.board_width - g_ui_params.margin,
			callback    = callback,
		})
		y_pos = y_pos + button_height + g_ui_params.padding
		if btn_info.extra_space ~= nil then
			y_pos = y_pos + btn_info.extra_space
		end
	end

	control_state.draw = function (control_state)
		buttons.draw(control_state.buttons)
	end

	control_state.handle_user_clicked = function (control_state, y_pos, x_pos)
		buttons.on_user_click(control_state.buttons, y_pos, x_pos)
	end

	control_state.update = function (control_state, game_state, player_idx)
		set_game_state(control_state, game_state, player_idx)
	end

	return control_state
end

return control
-- Author: Alex Barry (github.com/alexbarry)
local view_others = {}

local buttons = require("libs/ui/buttons")
local draw_more = require("libs/draw/draw_more")
local alex_c_api  = require("alex_c_api")

local core = require("games/poker_chips/poker_chips_core")

local g_ui_params = nil

local BTN_ID_CHOOSE_BET = "choose_bet"

local CURRENT_PLAYER_TEXT_ICON = ">"

local CURRENT_PLAYER_ICON_WIDTH =  20
local PLAYER_NAME_WIDTH         = 175
local PLAYER_ACTION_WIDTH       = 195
local PLAYER_CHIPS_WIDTH        =  50

local function btn_pressed(view_others_state, btn_id)
	if btn_id == BTN_ID_CHOOSE_BET then
		view_others_state.move_to_control_state()
	end
end

local function get_player_status(player_info)
	if player_info.last_action == nil then return ""
	elseif player_info.last_action == core.ACTION_CHECK then return "Check"
	elseif player_info.last_action == core.ACTION_CALL  then return "Call"
	elseif player_info.last_action == core.ACTION_RAISE then return string.format("Raise (+$%s)", player_info.last_bet)
	elseif player_info.last_action == core.ACTION_FOLD  then return "Folded"
	else
		return string.format("Unknown action \"%s\"", player_info.last_action)
	end
		
end

function view_others.init(ui_params, view_others_params)
	g_ui_params = ui_params
	local view_others_state = {
		buttons = buttons.new_state(),
		move_to_control_state = view_others_params.move_to_control_state,
		players = {
--[[
			{ name = "Alex",    action = "Checked",     chips = 135 },
			{ name = "Conor",   action = "Checked",     chips = 205 },
			{ name = "Justin",  action = "Raised +$30", chips =  55 },
			{ name = "Nick",    action = "Called +$30", chips = 175 },
			{ name = "Marc",    action = "Folded",      chips = 100 },
			{ name = "Liam",    action = "",            chips = 335 },
			{ name = "Pranav",  action = "",            chips = 220 },
			{ name = "Shubham", action = "",            chips =  95 },
--]]
		},
		player_turn = 6,
	}

	local button_height = 75

	buttons.new_button(view_others_state.buttons, {
		id              = BTN_ID_CHOOSE_BET,
		text            = "Choose Bet",
		bg_colour       = g_ui_params.BTN_BG_COLOUR,
		fg_colour       = g_ui_params.BTN_FG_COLOUR,
		outline_colour  = g_ui_params.BTN_OUTLINE_COLOUR,
		outline_width   = g_ui_params.BTN_OUTLINE_WIDTH,
		text_size       = g_ui_params.BTN_TEXT_SIZE,
		padding         = g_ui_params.padding,
		y_start         = g_ui_params.board_height - g_ui_params.margin - button_height,
		x_start         = g_ui_params.margin,
		y_end           = g_ui_params.board_height - g_ui_params.margin,
		x_end          = g_ui_params.board_width  - g_ui_params.margin,
		callback       = function (btn_id) btn_pressed(view_others_state, btn_id) end,
	})
	
	view_others_state.draw = function (view_others_state)
		local init_info_offset = g_ui_params.margin + g_ui_params.info_text_size
		local text_size = g_ui_params.info_text_size


		local min_bet_txt = string.format("Minimum Bet: %3d", view_others_state.min_bet)
		alex_c_api.draw_text(min_bet_txt, g_ui_params.BTN_FG_COLOUR,
		                     init_info_offset, g_ui_params.margin,
		                     text_size, 1)

		local pots_strs = string.format("Pot: %3s", core.get_pot_string(view_others_state.pots))
		alex_c_api.draw_text(pots_strs, g_ui_params.BTN_FG_COLOUR,
		                     init_info_offset, g_ui_params.board_width - g_ui_params.margin,
		                     text_size, -1)

		if #view_others_state.players == 0 then
			init_info_offset = init_info_offset + text_size + g_ui_params.margin
	
			alex_c_api.draw_text(string.format("Player count: %d", #view_others_state.players),
			                     g_ui_params.BTN_FG_COLOUR,
			                     init_info_offset, g_ui_params.margin,
			                     text_size, 1)
		end

		buttons.draw(view_others_state.buttons)
		local y_pos = g_ui_params.margin + text_size + init_info_offset
		for i, player_info in ipairs(view_others_state.players) do
			if view_others_state.last_player_min_bet == i then
				local line_y_pos = y_pos - math.floor(g_ui_params.padding/2) - text_size
				draw_more.draw_dashed_line(g_ui_params.BTN_FG_COLOUR, 1, nil, nil,
				                           line_y_pos, g_ui_params.margin,
				                           line_y_pos, g_ui_params.board_width - g_ui_params.margin)
			end 
			local text_colour
			if player_info.folded  then
				text_colour = g_ui_params.BTN_FG_COLOUR_FADED
			else
				text_colour = g_ui_params.BTN_FG_COLOUR
			end
			local x_pos = g_ui_params.margin
			if i == view_others_state.player_turn then
			alex_c_api.draw_text(CURRENT_PLAYER_TEXT_ICON, text_colour,
			                     y_pos, x_pos, text_size, 1)
			end
			x_pos = x_pos + CURRENT_PLAYER_ICON_WIDTH

			alex_c_api.draw_text(player_info.name, text_colour,
			                     y_pos, x_pos, text_size, 1)
			x_pos = x_pos + PLAYER_NAME_WIDTH

			if player_info.last_action ~= nil then
				local status = get_player_status(player_info)
				alex_c_api.draw_text(status, text_colour,
				                     y_pos, x_pos, text_size, 1)
			end
			x_pos = x_pos + PLAYER_ACTION_WIDTH

			x_pos = x_pos + PLAYER_CHIPS_WIDTH
			alex_c_api.draw_text(string.format("%4d", player_info.chips), text_colour,
			                     y_pos, x_pos, text_size, -1)

			y_pos = y_pos + text_size + g_ui_params.padding
		end
	end

	view_others_state.handle_user_clicked = function (view_others_state, pos_y, pos_x)
		buttons.on_user_click(view_others_state.buttons, pos_y, pos_x)
	end

	view_others_state.update = function (view_others_state, game_state)
		print("Updating view others state...")
		view_others_state.min_bet     = game_state.min_bet
		view_others_state.pots        = game_state.pots
		view_others_state.players     = game_state.players
		view_others_state.player_turn = game_state.player_turn
		view_others_state.last_player_min_bet = game_state.last_player_min_bet
		
	end

	return view_others_state
end

return view_others
local core = {}

local cards = require("libs/cards/cards")

core.NUM_PLAY_COLUMNS = 7
core.NUM_GOAL_STACKS = cards.NUM_SUITS


core.ACTION_MOVE = 1
core.ACTION_DECK_NEXT = 2

core.SECTION_PLAY_COLUMN_UNREVEALED = 1
core.SECTION_PLAY_COLUMN_STAGING    = 2
core.SECTION_DECK_UNREVEALED        = 3
core.SECTION_DECK_DRAW              = 4
core.SECTION_DECK_DISCARD           = 5
core.SECTION_GOAL_STACKS            = 6
core.SECTION_LAST                   = core.SECTION_GOAL_STACKS

core.DRAW_TYPE_ONE   = 1
core.DRAW_TYPE_THREE = 3

-- height and width of a square that the user is allowed to move
-- their touch/mouse inside before their gesture is interpreted as
-- moving, rather than just a single click.
local MAX_MOVE_FOR_CLICK = 2

function core.new_state_from_board_state(num_players, board_state)
	local state = board_state
	state.player_count = num_players
	state.players = {}

	for i=1,num_players do
		state.players[i] = {
			y = 0,
			x = 0,

			y_card_offset = 0,
			x_card_offset = 0,
			holding = {},
			holding_src = nil,
			holding_src_col = nil,

			moved = false,
		}
	end
	return state
end

function core.new_board_state(draw_type, params)
	local deck_unrevealed = cards.new_deck()

	local seed_x, seed_y
	if params.seed_x and params.seed_y then
		seed_x, seed_y = math.randomseed(params.seed_x, params.seed_y)
	else
		seed_x, seed_y = math.randomseed()
	end
	cards.shuffle(deck_unrevealed)

	local board_state = {
		draw_type       = draw_type,
		deck_unrevealed = deck_unrevealed,
		deck_discard    = {},

		-- Cards taken from the deck, shown to the user.
		-- In draw one, this is only ever zero or one card.
		-- In draw three, this can be zero to three cards.
		-- The card at the end of the list is the one that is on "top"
		-- and the user can try to move. 
		deck_draw       = {},

		play_columns_unrevealed = {},
		play_columns_staging = {},
		goal_stacks = {},
		players = {},

		seed_x = seed_x,
		seed_y = seed_y,
	}

	for i=1,core.NUM_GOAL_STACKS do
		board_state.goal_stacks[i] = {}
	end

	for i=1,core.NUM_PLAY_COLUMNS do
		board_state.play_columns_unrevealed[i] = {}
		board_state.play_columns_staging[i]    = {}
		for j=2,i do
			local card = table.remove(board_state.deck_unrevealed)
			table.insert(board_state.play_columns_unrevealed[i], card)
		end
		local card = table.remove(board_state.deck_unrevealed)
		table.insert(board_state.play_columns_staging[i], card)
	end

	board_state.move_count   = 0
	board_state.time_elapsed = 0
	
	return board_state
end

function core.game_won(state)
	if state == nil then return false end

	if #state.goal_stacks ~= core.NUM_GOAL_STACKS then
		error(string.format("Expected num goal stacks (%d) to be equal to %d", #state.goal_stacks, core.NUM_GOAL_STACKS))
	end

	for _, goal_stack in ipairs(state.goal_stacks) do
		if #goal_stack ~= cards.NUM_VALS then
			return false
		end
	end

	return true
end

function core.new_game(num_players, draw_type, params)
	local board_state = core.new_board_state(draw_type, params)
	return core.new_state_from_board_state(num_players, board_state)
end

function core.print_state(state)
	print('{')
	for i=1,#state.goal_stacks do
		print(string.format('goal_stack[%d] = %s,', i, cards.card_ary_to_string(state.goal_stacks[i])))
	end
	print(string.format('deck_unrevealed = %s,', cards.card_ary_to_string(state.deck_unrevealed)))
	print(string.format('deck_draw   = %s,', cards.card_ary_to_string(state.deck_draw)))
	print(string.format('deck_discard = %s,', cards.card_ary_to_string(state.deck_discard)))
	for i=1,core.NUM_PLAY_COLUMNS do
		print(string.format('play_unrevealed[%d] = %s,', i, cards.card_ary_to_string(state.play_columns_unrevealed[i])))
		print(string.format('play_revealed[%d]   = %s,', i, cards.card_ary_to_string(state.play_columns_staging[i])))
	end
	print('}')
end

function core.copy_state(state_orig)
	local state_copy = {}
	state_copy.draw_type               = state_orig.draw_type
	state_copy.player_count            = state_orig.player_count
	state_copy.move_count              = state_orig.move_count
	state_copy.time_elapsed            = state_orig.time_elapsed
	state_copy.deck_unrevealed         = cards.copy_card_ary(state_orig.deck_unrevealed)
	state_copy.deck_draw               = cards.copy_card_ary(state_orig.deck_draw)
	state_copy.deck_discard            = cards.copy_card_ary(state_orig.deck_discard)
	state_copy.play_columns_unrevealed = cards.copy_card_ary_ary(state_orig.play_columns_unrevealed)
	state_copy.play_columns_staging    = cards.copy_card_ary_ary(state_orig.play_columns_staging)
	state_copy.goal_stacks             = cards.copy_card_ary_ary(state_orig.goal_stacks)
	state_copy.players                 = {}
	for i, player_state in ipairs(state_orig.players) do
		state_copy.players[i] = {}
		state_copy.players[i].y               = player_state.y
		state_copy.players[i].x               = player_state.x
		state_copy.players[i].holding         = cards.copy_card_ary(player_state.holding)
		state_copy.players[i].holding_src     = player_state.holding_src
		state_copy.players[i].holding_src_col = player_state.holding_src_col
		state_copy.players[i].moved           = moved
	end
	return state_copy
end

function core.get_held_cards(state, player)
	return state.players[player].holding
end

-- pos_info = {
-- 		section_type = core.SECTION_PLAY_*,
-- 		col = int, 
-- }
function core.can_place_card(state, held_cards, pos_info)
	if pos_info == nil then
		return false
	end

	local held_card_top = nil
	if #held_cards == 0 then
		return false
	else
		held_card_top = held_cards[1]
	end

	if pos_info.section_type == core.SECTION_PLAY_COLUMN_STAGING then
		if #state.play_columns_staging[pos_info.col] > 0 then
			local dst_card_top = state.play_columns_staging[pos_info.col][#state.play_columns_staging[pos_info.col]]
			return (cards.suit_is_red(dst_card_top.suit) ~= cards.suit_is_red(held_card_top.suit) and 
			       held_card_top.val == dst_card_top.val - 1)
		else
			return held_card_top.val == cards.KING
		end
	elseif pos_info.section_type == core.SECTION_GOAL_STACKS then
		if #held_cards > 1 then
			return false
		end
		if #state.goal_stacks[pos_info.col] == 0 then
			return held_card_top.val == cards.ACE
		else
			local dst_card_top = state.goal_stacks[pos_info.col][#state.goal_stacks[pos_info.col]]
			return (held_card_top.suit == dst_card_top.suit and held_card_top.val == dst_card_top.val + 1)
		end
	else
		print("can_place_card: unhandled section_type", pos_info.section_type)
		return false
	end
end

function core.handle_mousemove(state, player, pos_y, pos_x)
	local player = state.players[player]
	player.y = pos_y
	player.x = pos_x

	if player.y_start ~= nil and math.abs(player.y_start - pos_y) > MAX_MOVE_FOR_CLICK or
	   player.x_start ~= nil and math.abs(player.x_start - pos_x) > MAX_MOVE_FOR_CLICK then
		player.moved = true
	end
end

function core.get_card_ary(state, section_type, col)
	-- TODO: change all references to this enum
	if section_type == core.SECTION_DECK_DRAW then
		return state.deck_draw
	elseif section_type == core.SECTION_PLAY_COLUMN_STAGING then
		return state.play_columns_staging[col]
	elseif section_type == core.SECTION_GOAL_STACKS then
		return state.goal_stacks[col]
	else
		error(string.format("get_card_ary section_type %s unexpected", section_type))
	end
end

function core.next_in_deck(state)
	-- This can be confusing: for most lists of cards, we always draw from the end.
	-- For the case where the user clicks the deck, remove from end of deck_unrevealed, and insert at end of deck_draw
	-- When moving cards from deck_draw to deck_discard, remove from beginning of deck_draw, but insert at end of deck_discard.
	-- If the player runs out of deck_discard cards, draw from end of deck_discard.
		if #state.deck_unrevealed > 0 then
			while #state.deck_draw > 0 do
				table.insert(state.deck_discard, table.remove(state.deck_draw, 1))
			end
			for _=1,state.draw_type do
				if #state.deck_unrevealed == 0 then
					goto draw_from_deck -- continue
				end
				local card = table.remove(state.deck_unrevealed)
				table.insert(state.deck_draw, card)
				::draw_from_deck::
			end
		else
			while #state.deck_draw > 0 do
				table.insert(state.deck_discard, table.remove(state.deck_draw, 1))
				--table.insert(state.deck_discard, table.remove(state.deck_draw))
			end

			while #state.deck_discard > 0 do
				table.insert(state.deck_unrevealed, table.remove(state.deck_discard))
			end
		end
	core.inc_move_count(state)
end

function core.handle_mouse_down(player, state, pos_info)
	local rc = false
	if pos_info ~= nil then
		state.players[player].y = pos_info.y
		state.players[player].x = pos_info.x
		state.players[player].y_start = pos_info.y
		state.players[player].x_start = pos_info.x
	end

	state.players[player].moved = false

	if pos_info == nil then
		-- pass
	elseif pos_info.section_type == core.SECTION_DECK_UNREVEALED then
		core.next_in_deck(state)
		rc = true
	elseif #state.players[player].holding == 0 then
		if pos_info.section_type == core.SECTION_PLAY_COLUMN_UNREVEALED then
			if #state.play_columns_staging[pos_info.col] == 0 and
			   #state.play_columns_unrevealed[pos_info.col] > 0 then
				local card = table.remove(state.play_columns_unrevealed[pos_info.col])
				table.insert(state.play_columns_staging[pos_info.col], card)
			end
		elseif pos_info.section_type == core.SECTION_DECK_DRAW then
			if #state.deck_draw > 0 then
				local card = table.remove(state.deck_draw)
				state.players[player].holding = {card}
				state.players[player].holding_src = pos_info.section_type
				print(string.format("player picked up cards %s", cards.card_ary_to_string(state.players[player].holding)))
			end
		elseif pos_info.section_type == core.SECTION_PLAY_COLUMN_STAGING then
			local stack = core.get_card_ary(state, pos_info.section_type, pos_info.col)
			if #stack > 0 then
				state.players[player].holding = {}
				while #stack >= pos_info.idx do
					table.insert(state.players[player].holding, table.remove(stack, pos_info.idx))
				end
				state.players[player].holding_src = pos_info.section_type
				state.players[player].holding_src_col = pos_info.col
			end
		elseif pos_info.section_type == core.SECTION_GOAL_STACKS then
			local stack = core.get_card_ary(state, pos_info.section_type, pos_info.col)
			if #stack > 0 then
				state.players[player].holding = {table.remove(stack)}
				state.players[player].holding_src = pos_info.section_type
				state.players[player].holding_src_col = pos_info.col
			end
		end
	end

	if pos_info ~= nil and pos_info.card_src_y ~= nil and pos_info.card_src_x ~= nil then 
		state.players[player].y_card_offset = pos_info.y - pos_info.card_src_y
		state.players[player].x_card_offset = pos_info.x - pos_info.card_src_x
	end
	return rc
end

local function restore_card(state, player)
	local player_state = state.players[player]
	local stack = core.get_card_ary(state, player_state.holding_src, player_state.holding_src_col)
	while #player_state.holding > 0 do
		local card = table.remove(player_state.holding, 1)
		table.insert(stack, card)
	end
end

function core.move_held_cards_to_dst(state, player, pos_info)
	local stack = core.get_card_ary(state, pos_info.section_type, pos_info.col)
	local player_state = state.players[player]
	while #player_state.holding > 0 do
		local card = table.remove(player_state.holding, 1)
		table.insert(stack, card)
	end
end

function core.inc_move_count(state)
	if state.move_count ~= nil then
		state.move_count = state.move_count + 1
	end
end 

function core.update_time_elapsed(state, dt_ms)
	if state == nil then return end
	if state.time_elapsed == nil then
		return
	end

	if core.game_won(state) then
		return
	end

	if state.last_time_elapsed_update == nil then
		state.last_time_elapsed_update = 0
	end
	state.last_time_elapsed_update = state.last_time_elapsed_update + dt_ms
	if state.last_time_elapsed_update >= 1000 then
		state.last_time_elapsed_update = state.last_time_elapsed_update - 1000
		state.time_elapsed = state.time_elapsed + 1
	end
end

function core.handle_mouse_up(player, state, pos_info)
	local rc = false
	local player_state = state.players[player]
	if #player_state.holding == 0 then
		--print("player not holding anything")
		goto done
	end

	if not player_state.moved then
		--print("player not moved")
		if pos_info == nil then
			print("hitting this case")
			restore_card(state, player)
			goto done
		end

		-- TODO clean this up... need to put the card back before we attempt an auto move.
		local stack = core.get_card_ary(state, player_state.holding_src, player_state.holding_src_col)
		while #player_state.holding > 0 do
			local card = table.remove(player_state.holding, 1)
			table.insert(stack, card)
		end
		player_state.holding = {}
		player_state.holding_src = nil

		if pos_info.section_type == core.SECTION_PLAY_COLUMN_UNREVEALED then
			pos_info.section_type = core.SECTION_PLAY_COLUMN_STAGING
		end

		-- print("trying to auto move card")
		rc = core.auto_move_card(player, state, pos_info)
		goto done
	end

	if core.can_place_card(state, core.get_held_cards(state, player), pos_info) then
		--print("can place card...")
		core.move_held_cards_to_dst(state, player, pos_info)
		if #state.deck_draw == 0 and #state.deck_discard > 0 then
			local card = table.remove(state.deck_discard)
			table.insert(state.deck_draw, card)
		end
		rc = true
	else
		--print("can not place card, restoring...")
		restore_card(state, player)
	end
	player_state.holding = {}
	player_state.holding_src = nil


	::done::

	if rc then
		core.inc_move_count(state)
	end
	state.players[player].y_card_offset = 0
	state.players[player].x_card_offset = 0
	return rc

end

function core.copy_pos_info(pos_info)
	local new_pos_info = {
		section_type = pos_info.section_type,
		col          = pos_info.col,
		idx          = pos_info.idx,
		cards        = pos_info.cards,
	}
	return new_pos_info
end

function core.copy_move(move)
	local new_move = {
		src = core.copy_pos_info(move.src),
		dst = core.copy_pos_info(move.dst),
	}
	return new_move
end

function core.handle_move(state, player, move)
	assert(#state.players[player].holding == 0)
	core.handle_mouse_down(player, state, move.src)
	assert(#state.players[player].holding >= 1)

	if move.src.cards ~= nil then
		assert(cards.cards_eq(state.players[player].holding[1], move.src.cards[1]))
	end
	state.players[player].moved = true -- TODO CLEAN UP
	local rc = core.handle_mouse_up(player, state, move.dst)
	assert(#state.players[player].holding == 0)

	-- Click to reveal any cards that can now be revealed in the play columns
	if move.src.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	   #state.play_columns_staging[move.src.col] == 0 and
	   #state.play_columns_unrevealed[move.src.col] > 0 then
		local new_src = { section_type = core.SECTION_PLAY_COLUMN_UNREVEALED, col = move.src.col }
		core.handle_mouse_down(player, state, new_src )
		core.handle_mouse_up(player, state, new_src )
		assert(#state.players[player].holding == 0)
	end

	return rc
end

local function get_card_from_pos_info(state, pos_info)
	local ary = core.get_card_ary(state, pos_info.section_type, pos_info.col)
	if #ary == 0 then
		return nil
	end

	return ary[#ary]
end

local function find_auto_move_card_spot(state, pos_info)
	local card = get_card_from_pos_info(state, pos_info)

	if card == nil then
		return
	end

	for i, stack in ipairs(state.goal_stacks) do
		if card.val == cards.ACE then
			if #stack == 0 then
				return i
			end
		elseif #stack > 0 and stack[#stack].suit == card.suit then
			if stack[#stack].val == card.val - 1 then
				return i
			else
				return nil
			end
		end
	end
	return nil
end

function core.auto_move_card(player, state, pos_info)
	local rc = false
	local idx = find_auto_move_card_spot(state, pos_info)
	if idx ~= nil then
		local card = table.remove(core.get_card_ary(state, pos_info.section_type, pos_info.col))
		table.insert(state.goal_stacks[idx], card)
		rc = true
	end

	-- If card moved was the last draw card, put one from the discard pile on the draw pile.
	if pos_info.section_type == core.SECTION_DECK_DRAW and #state.deck_draw == 0 and #state.deck_discard > 0 then
		local card = table.remove(state.deck_discard)
		table.insert(state.deck_draw, card)
	end
	return rc
end

function core.autocomplete_available(state)
	return core.play_cols_unrevealed_empty(state)
end

function core.play_cols_unrevealed_empty(state)
	for i=1,core.NUM_PLAY_COLUMNS do
		if #state.play_columns_unrevealed[i] > 0 then
			return false
		end
	end
	return true
end

function core.get_autocomplete_move_list(state_orig)
	-- TODO there is a bug here where it doesn't check the last card
	-- if the deck only has one card in it? Something like that
	-- I tried the autocomplete feature and it got all the way to the end,
	-- but there was a single king left in the deck that it couldn't find

	-- TODO uncomment below
	if false then
	-- if not core.autocomplete_available(state_orig) then
		print("autocomplete not available")
		return
	end

	local move_list = {}

	local state_copy = core.copy_state(state_orig)

	local changed = true
	while changed do
		::play_columns_loop::
		changed = false
		for i,_ in ipairs(state_copy.play_columns_staging) do
			local src_pos_info = {
				section_type = core.SECTION_PLAY_COLUMN_STAGING,
				col = i,
			}
			local idx = find_auto_move_card_spot(state_copy, src_pos_info)
			if idx ~= nil then
				local dst_pos_info = {
					section_type = core.SECTION_GOAL_STACKS,
					col = idx,
				}
				table.insert(move_list, { move = core.ACTION_MOVE, src = src_pos_info, dst = dst_pos_info })
				local card = table.remove(core.get_card_ary(state_copy, src_pos_info.section_type, src_pos_info.col))
				table.insert(state_copy.goal_stacks[idx], card)
				changed = true
			end
		end
		if changed then
			goto play_columns_loop
		end

		
		--local deck_size_start = #state_copy.deck_unrevealed + #state_copy.deck_draw + #state_copy.deck_discard
		--local deck_pos_start  = #state_copy.deck_discard
		--local deck_pos_end    = nil
		--if deck_size_start > 0 then
		--	deck_pos_end = (deck_pos_start - 1) % deck_size_start
		--else
		--	deck_pos_end = 0
		--end
		local deck_pos_counter = 0
		local deck_pos_counter_end = math.ceil((#state_copy.deck_unrevealed + #state_copy.deck_draw + #state_copy.deck_discard)/state_copy.draw_type)

		while true do
			::next_deck::
			local src_pos_info = {
				section_type = core.SECTION_DECK_DRAW,
				col          = 1,
			}
			local idx = find_auto_move_card_spot(state_copy, src_pos_info)

			if idx == nil then
				deck_pos_counter = deck_pos_counter + 1
				-- TODO loop forever here to test error handling on OOM
				if deck_pos_counter <= deck_pos_counter_end then
					table.insert(move_list, { move = core.ACTION_DECK_NEXT })
					core.next_in_deck(state_copy)
					goto next_deck
				end
			else
				local dst_pos_info = {
					section_type = core.SECTION_GOAL_STACKS,
					col = idx,
				}
				table.insert(move_list, { move = core.ACTION_MOVE, src = src_pos_info, dst = dst_pos_info })
				local card = table.remove(core.get_card_ary(state_copy, src_pos_info.section_type, src_pos_info.col))
				table.insert(state_copy.goal_stacks[idx], card)
				changed = true
				goto play_columns_loop
			end
			break
		end
	end
	return move_list
end

function core.autocomplete(state, handle_move_list)
	local move_list = core.get_autocomplete_move_list(state)
	if #move_list > 0 then
		print("autocomplete moves", #move_list)
		handle_move_list(move_list)
	else
		print("can't autocomplete, no moves found")
	end
end

function core.remove_card_from_move(state, pos_info)
	local ary = core.get_card_ary(state, pos_info.section_type, pos_info.col)
	return table.remove(ary, #ary)
end

return core
local draw = {}

local alex_c_api = require("alex_c_api")

local cards      = require("libs/cards/cards")
local cards_draw = require("libs/cards/cards_draw")
local draw_celebration_anim = require("libs/draw/draw_celebration_anim")

local core       = require("games/solitaire/solitaire_core")

local BACKGROUND_COLOUR = '#008800'
local CARD_SPACE_COLOUR = '#007000'
local BACKGROUND_COLOUR_DARK  = '#002200'
local CARD_SPACE_COLOUR_DARK  = '#001100'

local TEXT_SIZE   = 14
local TEXT_COLOUR_LIGHT = '#0000cc'
local TEXT_COLOUR_DARK  = '#8888aa'
local PADDING = 3

-- 
draw.show_move_count_and_elapsed_time = nil

local function get_bg_colour()
	if alex_c_api.get_user_colour_pref() == "dark" then
		return BACKGROUND_COLOUR_DARK
	else
		return BACKGROUND_COLOUR
	end
end

local function get_card_space_colour()
	if alex_c_api.get_user_colour_pref() == "dark" then
		return CARD_SPACE_COLOUR_DARK
	else
		return CARD_SPACE_COLOUR
	end

end

local function get_text_colour()
	if alex_c_api.get_user_colour_pref() == "dark" then
		return TEXT_COLOUR_DARK
	else
		return TEXT_COLOUR_LIGHT
	end
end

--local PLAYER_HOLDING_OFFSET_Y = -7
--local PLAYER_HOLDING_OFFSET_X = 7
--local PLAYER_HOLDING_OFFSET_Y = 0
--local PLAYER_HOLDING_OFFSET_X = 0
local PLAYER_HOLDING_OFFSET_Y = -5
local PLAYER_HOLDING_OFFSET_X = 5
local HELD_CARD_IS_HIGHLIGHTED = true

local is_touch_controlled = false

draw.BTN_ID_AUTO_COMPLETE = "autocomplete"
draw.BTN_ID_NEW_GAME = "new_game"
draw.BTN_ID_UNDO     = "undo"

--local card_height = 105
--local card_width  = 60
local card_ratio = 75/40
local card_padding_ratio = 10/75

local card_height = 75
local card_width  = 40
local card_font_size  = 32
local card_padding = 10
local card_stack_offset = 5
local card_revealed_offset = 20
 -- for draw 3, how much space to leave between the three cards drawn from the deck
local draw_pile_offset = 23

local board_width  = nil
local board_height = nil

local ANIM_MOVE_MS = 150
local anim_start_time_ms = nil
local anim_end_time_ms   = nil
local card_anim_src_y = nil
local card_anim_src_x = nil
local card_anim_dst_y = nil
local card_anim_dst_x = nil
local card_anim = nil
local card_anim_pos_y = nil
local card_anim_pos_x = nil
local move_list = {}
local last_animation_update_time = nil
local anim_finished_callback = nil

local anim_state = draw_celebration_anim.new_state({
})
-- TODO this probably should be included in the anim state?
-- Perhaps as an option, for games that don't otherwise require a timer
local g_victory_anim_timer = nil


function draw.set_is_touch_controlled(arg)
	is_touch_controlled = arg
end

function draw.init(board_width_arg, board_height_arg)

	board_width  = board_width_arg
	board_height = board_height_arg

	local card_width_max  = math.floor(board_width/(core.NUM_PLAY_COLUMNS * (1+card_padding_ratio)))
	local card_height_max = math.floor(card_width_max * card_ratio)

	card_width  = card_width_max
	card_height = card_height_max
	card_padding = math.floor(card_width_max * card_padding_ratio)


	alex_c_api.create_btn(draw.BTN_ID_UNDO,          "Undo",          1)
	alex_c_api.create_btn(draw.BTN_ID_NEW_GAME,      "New Game",      1)
	alex_c_api.create_btn(draw.BTN_ID_AUTO_COMPLETE, "Auto-Complete", 1)
end


function draw.get_pos(state, game_section, col, idx)
	if game_section == core.SECTION_PLAY_COLUMN_UNREVEALED then
		return {
			y = card_height + 2*card_padding + (idx-1) * card_stack_offset,
			x = card_padding + (col-1) * (card_padding + card_width),
		}
	elseif game_section == core.SECTION_PLAY_COLUMN_STAGING then
		local stack = #state.play_columns_unrevealed[col]
		if idx == nil then
			idx = #state.play_columns_staging
		end
		return {
			y = card_height + 2*card_padding + stack*card_stack_offset + (idx-1)*card_revealed_offset,
			x = card_padding + (col-1) * (card_padding + card_width),
		}
	elseif game_section == core.SECTION_DECK_UNREVEALED then
		return {
			y = card_padding,
			x = card_padding + (core.NUM_PLAY_COLUMNS-1) * (card_padding + card_width),
		}
	elseif game_section == core.SECTION_DECK_DRAW or
	       game_section == core.SECTION_DECK_DISCARD then
		if game_section == core.SECTION_DECK_DISCARD then
			if col ~= nil then
				error("col is nil for get_pos(DISCARD)")
			end
			col = 1
		end
		if col == nil then
			error(string.format("get_pos col is nil"), 3)
		end
		-- This is the extra space that we have to divide between the draw 3 cards (if present)
		local draw_width = card_width + card_padding
		local draw_idx = 1
		if state.draw_type == core.DRAW_TYPE_THREE then
			draw_idx = 3 - col + 1
		end
		return {
			y = card_padding,
			x = math.floor(card_padding + (core.NUM_PLAY_COLUMNS-2) * (card_padding + card_width) - (draw_idx-1)*draw_pile_offset)
		}
	elseif game_section == core.SECTION_GOAL_STACKS then
		return {
			y = card_padding,
			x = card_padding + (col-1) * (card_padding + card_width),
		}
	else
		error(string.format("get_pos: unhandled section %s", game_section))
	end
	
end

local function in_section(state, pos_y, pos_x, game_section, col, idx)
	local pos = draw.get_pos(state, game_section, col, idx)
	return pos.y <= pos_y and pos_y <= pos.y + card_height and
	       pos.x <= pos_x and pos_x <= pos.x + card_width
end

local function get_offset(player_state)
	if not is_touch_controlled then
		return {
			dy = player_state.y_card_offset,
			dx = player_state.x_card_offset,
		}
	else
		return {
			dy = math.floor(card_height/2),
			dx = math.floor(card_width/2),
		}
	end
end


function draw.draw_state(session_id, state)
	alex_c_api.draw_clear()

	alex_c_api.draw_rect(get_bg_colour(), 0, 0, board_height, board_width)

	for i=1,core.NUM_GOAL_STACKS do
		local pos = draw.get_pos(state, core.SECTION_GOAL_STACKS, i)
		alex_c_api.draw_rect(get_card_space_colour(),
		                     pos.y, pos.x,
		                     pos.y + card_height,
		                     pos.x + card_width)
	end

	if state == nil then
		local pos = draw.get_pos(state, core.SECTION_DECK_UNREVEALED)
		cards_draw.draw_card(cards.UNREVEALED_CARD,
		                     pos.y, pos.x,
		                     card_width,
		                     card_height,
		                     card_font_size,
				             false,
				             0)
		local text_size = 24
		alex_c_api.draw_text("Press \"New Game\" button",
		                     "#000000",
		                     board_height/2 - text_size,
		                     board_width/2,
		                     text_size,
		                     alex_c_api.TEXT_ALIGN_CENTRE)
		return
	end


	for i=1,#state.play_columns_unrevealed do
		for j=1,#state.play_columns_unrevealed[i] do
			local pos = draw.get_pos(state, core.SECTION_PLAY_COLUMN_UNREVEALED, i, j)
			cards_draw.draw_card(cards.UNREVEALED_CARD,
					             pos.y, pos.x,
			                     card_width,
			                     card_height,
			                     card_font_size,
					             false,
					             0)
		end

		for j=1,#state.play_columns_staging[i] do
			local card = state.play_columns_staging[i][j]
			local pos = draw.get_pos(state, core.SECTION_PLAY_COLUMN_STAGING, i, j)
				cards_draw.draw_card(card,
					             pos.y, pos.x,
			                     card_width,
			                     card_height,
			                     card_font_size,
					             false,
					             0)		
		end
	end

	-- TODO if deck is empty, draw some sort of an icon in its place
	local pos = draw.get_pos(state, core.SECTION_DECK_UNREVEALED)
	if #state.deck_unrevealed > 0 then
		cards_draw.draw_card(cards.UNREVEALED_CARD,
		                     pos.y, pos.x,
		                     card_width,
		                     card_height,
		                     card_font_size,
				             false,
				             0)
	else
		-- TODO draw some sort of an icon, like a green circle,
		-- to indicate that this can be clicked?
		alex_c_api.draw_rect(get_card_space_colour(),
		                     pos.y, pos.x,
		                     pos.y + card_height,
		                     pos.x + card_width)
	end


	if #state.deck_draw > 0 then
		-- Card at top of stack should be drawn on top
		for i=1,#state.deck_draw do
			local pos = draw.get_pos(state, core.SECTION_DECK_DRAW, i)
			local deck_revealed_top = state.deck_draw[i]
			cards_draw.draw_card(deck_revealed_top,
			                     pos.y, pos.x,
			                     card_width,
			                     card_height,
			                     card_font_size,
					             false,
					             0)
		end
	-- Maybe only draw this card if the player is holding one?
	-- what is really bad is if the player isn't holding a card, and there's a bug
	-- in the core logic that prevents one of the discard cards from being moved to
	-- the draw pile. There's this card shown (by the below code) that can't be picked up.
	elseif #state.deck_discard > 0 and state.draw_type == core.DRAW_TYPE_ONE then
	-- For draw three, if there are no cards here, don't draw any from the deck_discard pile.
	-- Rely on the core game code to put a discard card here when the user has actually
	-- placed (stopped holding)
		local pos = draw.get_pos(state, core.SECTION_DECK_DRAW, 1)
		local card = state.deck_discard[#state.deck_discard]
		if card == nil then error("card is nil in case 1234234") end
		cards_draw.draw_card(card,
		                     pos.y, pos.x,
		                     card_width,
		                     card_height,
		                     card_font_size,
				             false,
				             0)
	end

	for i=1,#state.goal_stacks do
		local card = nil
		if #state.goal_stacks[i] > 0 then
			card = state.goal_stacks[i][#state.goal_stacks[i]]
		end
		local pos = draw.get_pos(state, core.SECTION_GOAL_STACKS, i)
		if card ~= nil then
			cards_draw.draw_card(card,
			                     pos.y, pos.x,
			                     card_width,
			                     card_height,
			                     card_font_size,
			                     false,
			                     0)
		end
	end

	for player=1,state.player_count do
		local player_state = state.players[player]
		if player_state.holding ~= nil then
			local y = player_state.y
			local x = player_state.x

			if player_state.y_card_offset ~= nil and
			   player_state.x_card_offset ~= nil then
				local offset = get_offset(player_state)
				y = y - offset.dy
				x = x - offset.dx
			end

			y = y + PLAYER_HOLDING_OFFSET_Y
			x = x + PLAYER_HOLDING_OFFSET_X

			for stack_idx, card in ipairs(player_state.holding) do
				cards_draw.draw_card(card,
				                     y + (stack_idx-1)*card_revealed_offset,
				                     x,
				                     card_width, card_height, card_font_size,
				                     HELD_CARD_IS_HIGHLIGHTED, 0)
			end
		end
	end

	if card_anim ~= nil then
		cards_draw.draw_card(card_anim,
		                     math.floor(card_anim_pos_y), math.floor(card_anim_pos_x),
		                     card_width, card_height, card_font_size,
		                     false, 0)
	end

	if draw.show_move_count_and_elapsed_time and state.move_count ~= nil then
		local moves_str = string.format('Moves: %d', state.move_count)
		alex_c_api.draw_text(moves_str, get_text_colour(),
		                     board_height - PADDING,
		                     PADDING,
		                     TEXT_SIZE, alex_c_api.TEXT_ALIGN_LEFT)
	end
	if draw.show_move_count_and_elapsed_time and state.time_elapsed ~= nil then
		local mins_elapsed = math.floor(state.time_elapsed / 60)
		local secs_elapsed = state.time_elapsed % 60
		local time_str = string.format('%d:%02d', mins_elapsed, secs_elapsed)
		alex_c_api.draw_text(time_str, get_text_colour(),
		                     board_height - PADDING,
		                     board_width - PADDING,
		                     TEXT_SIZE, alex_c_api.TEXT_ALIGN_RIGHT)
	end

	draw_celebration_anim.draw(anim_state)
	alex_c_api.draw_refresh()


	-- TODO uncomment once testing is done on this
	--alex_c_api.set_btn_enabled(draw.BTN_ID_AUTO_COMPLETE, core.autocomplete_available(state))
	alex_c_api.set_btn_enabled(draw.BTN_ID_UNDO, alex_c_api.has_saved_state_offset(session_id, -1))
end


function draw.pos_to_action(state, player, pos_y, pos_x, evt_id)
	if state == nil then
		return nil
	end
	if #move_list > 0 then
		return nil
	end
	local info = {
		section_type = nil,
		col = nil,
		idx = nil,

		-- only used for setting player pos
		y = pos_y,
		x = pos_x,
	}

	if evt_id == 'touchend' and 
	   state.players[player].y_card_offset ~= nil and 
	   state.players[player].x_card_offset ~= nil then
		local offset = get_offset(state.players[player])
		offset.dy = offset.dy - math.floor(card_height/2)
		offset.dx = offset.dx - math.floor(card_width/2)

		pos_y = pos_y - offset.dy
		pos_x = pos_x - offset.dx

		print(string.format("offsetting mouse pos with dy=%d, dx=%d, is_touch=%s", offset.dy, offset.dx, is_touch_controlled))
	end 

	if in_section(state, pos_y, pos_x, core.SECTION_DECK_UNREVEALED) then
		info.section_type = core.SECTION_DECK_UNREVEALED
		return info
	else
		for draw_idx=1,state.draw_type do
			if in_section(state, pos_y, pos_x, core.SECTION_DECK_DRAW, draw_idx) then
				info.section_type = core.SECTION_DECK_DRAW
				info.col          = draw_idx
				return info
			end
		end
		for col=1,core.NUM_PLAY_COLUMNS do
			for idx=#state.play_columns_staging[col],1,-1 do
				if in_section(state, pos_y, pos_x, core.SECTION_PLAY_COLUMN_STAGING, col, idx) then
					info.section_type = core.SECTION_PLAY_COLUMN_STAGING
					info.col = col
					info.idx = idx
					return info
				end
			end
			-- This is the "empty column" case, where you can place kings
			if #state.play_columns_staging[col] == 0 and 
			   #state.play_columns_unrevealed[col] == 0 then 
				if in_section(state, pos_y, pos_x, core.SECTION_PLAY_COLUMN_STAGING, col, 1) then
					info.section_type = core.SECTION_PLAY_COLUMN_STAGING
					info.col = col
					return info
				end
			end
		end

		for col=1,core.NUM_PLAY_COLUMNS do

			for idx=1,#state.play_columns_unrevealed[col] do
				if in_section(state, pos_y, pos_x, core.SECTION_PLAY_COLUMN_UNREVEALED, col, idx) then
					info.section_type = core.SECTION_PLAY_COLUMN_UNREVEALED
					info.col = col
					info.idx = idx
					return info
				end
			end
		end

		for col=1,cards.NUM_SUITS do
			if in_section(state, pos_y, pos_x, core.SECTION_GOAL_STACKS, col) then
				info.section_type = core.SECTION_GOAL_STACKS
				info.col = col
				return info
			end
		end
	end
	return nil
end

local function start_anim(state, item)
	--print("start_anim")
	--if #move_list > 0 then
	--	return
	--end
	if item.item.move == core.ACTION_MOVE then
		card_anim = core.remove_card_from_move(state, item.item.src)
		local src_pos = draw.get_pos(state, item.item.src.section_type, item.item.src.col)
		card_anim_src_y = src_pos.y
		card_anim_src_x = src_pos.x
		local dst_pos = draw.get_pos(state, item.item.dst.section_type, item.item.dst.col)
		card_anim_dst_y = dst_pos.y
		card_anim_dst_x = dst_pos.x
		anim_start_time_ms = alex_c_api.get_time_ms()
		anim_end_time_ms   = item.time

		card_anim_pos_y = card_anim_src_y
		card_anim_pos_x = card_anim_src_x
		core.inc_move_count(state)
	elseif item.item.move == core.ACTION_DECK_NEXT then
		core.next_in_deck(state)
		anim_start_time_ms = alex_c_api.get_time_ms()
		anim_end_time_ms   = item.time
	else
		error(string.format("unexpected item.item.move=%s", item.item.move))
	end
	
end

function draw.stop_move_animations()
	anim_start_time_ms = nil
	anim_end_time_ms   = nil
	card_anim_src_y = nil
	card_anim_src_x = nil
	card_anim_dst_y = nil
	card_anim_dst_x = nil
	card_anim = nil
	card_anim_pos_y = nil
	card_anim_pos_x = nil
	move_list = {}
	last_animation_update_time = nil
	if anim_finished_callback ~= nil then
		anim_finished_callback()
	end
	anim_finished_callback = nil
end

function draw.animate_moves(state, move_list_arg, on_anim_finished)
	if #move_list > 0 then
		return
	end

	local current_time_ms = alex_c_api.get_time_ms()
	for i, item in ipairs(move_list_arg) do
		local anim_item = {
			item = item,
			time = current_time_ms + i * ANIM_MOVE_MS,
		}
		table.insert(move_list, anim_item)
	end
	if #move_list > 0 then
		start_anim(state, move_list[1])
	end
	anim_finished_callback = on_anim_finished
end

-- While working on this I had added two "animations":
-- * the autocomplete moves, that's what `draw.animate_moves` does
-- * the fireworks "victory animation" / "draw_celebration_anim".
function draw.update_animations(state, dt_ms)
	--print("update_animations", dt_ms, "move list len", #move_list)

	draw.animate_moves(state, move_list, on_anim_finished)
	draw_celebration_anim.update(anim_state, dt_ms/1000.0)

	if #move_list == 0 then
		return
	end

	-- TODO REMOVE?
	if dt_ms == 0 then
		return
	end 
	local current_time_ms = alex_c_api.get_time_ms()
	--local time_diff = last_animation_update_time - current_time_ms
	if current_time_ms < move_list[1].time then
		if move_list[1].item.move == core.ACTION_MOVE then
			local time_portion = (current_time_ms - anim_start_time_ms) / (anim_end_time_ms - anim_start_time_ms)
			if time_portion >= 1 then
				time_portion = 1
			end
	
			card_anim_pos_y = card_anim_src_y + time_portion * (card_anim_dst_y - card_anim_src_y)
			card_anim_pos_x = card_anim_src_x + time_portion * (card_anim_dst_x - card_anim_src_x)
		end
	else
		if move_list[1].item.move == core.ACTION_MOVE then
			local ary = core.get_card_ary(state, move_list[1].item.dst.section_type, move_list[1].item.dst.col)
			table.insert(ary, card_anim)
			card_anim = nil
		end
		table.remove(move_list, 1)
		if #move_list > 0 then
			start_anim(state, move_list[1])
		else
			if anim_finished_callback ~= nil then
				anim_finished_callback()
			end
		end
	end
end

function draw.victory_animation(fps)
	print("setting timer")
	if g_victory_anim_timer ~= nil then
		error(string.format("victory_animation: anim_timer is not nil"))
	end
	g_victory_anim_timer = alex_c_api.set_timer_update_ms(1000/fps)
	draw_celebration_anim.fireworks_display(anim_state, {
		on_finish = function ()
			if g_victory_anim_timer == nil then
				alex_c_api.set_status_err("warning: g_victory_anim_timer is nil on anim complete")
			else
				alex_c_api.delete_timer(g_victory_anim_timer)
				g_victory_anim_timer = nil
			end
			--print("animation finished! Resuming timer")
			--alex_c_api.set_timer_update_ms(0)
			--alex_c_api.set_timer_update_ms(1000/60)
		end,
	})
end
	

return draw

local alex_c_api = require("alex_c_api")

local core = require("games/solitaire/solitaire_core")
local draw = require("games/solitaire/solitaire_draw")
local serialize = require("games/solitaire/solitaire_serialize")
local utils = require("libs/utils")
local storage_helpers = require("libs/serialize/storage_helpers")

-- Here is a winnable game state, for testing:
-- from the beginning
-- http://localhost:1234/?game=solitaire&state=AQEYKy0fJRwWDxUiAzEOIB0wCAkRBBkjGBoTAAAAARABDQEkAgsuAQIDKSEBASwELwAeFwEGBQUqKDMbAQwGByYSFCcyAQoAAAAAgPyBuwD%2f%2fv%2f+AAAAAGVH8nMAAAAAAANT1A%3d%3d
-- almost won:
--  http://localhost:1234/?game=solitaire&id=tczscg&state=AQEAAAAAAhkyAAIMJQACMwsAAAABJgAAAAALGhscHR4fICEiIyQMDQ4PEBESExQVFhcYCycoKSorLC0uLzAxCwABAgMEBQYHCAkKgK2B1AD%2f%2foAEAAAAAGVH8nMAAAAAAANT1A%3d%3d 
-- 01 01 00 00 00 00 01 19 00 00 00 00 00 00 00 00 00 00 00 00 0d 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 0d 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 0d 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 80 c9 80 4f 00 ff fe 80 01 00 00 00 00 65 47 f2 73 00 00 00 00 00 03 53 d4 

-- autocomplete testing
-- http://localhost:1234/?game=solitaire&id=tczscg&state=AQECKy0BHwEDAAsZMhcwCC4GLAQqAgAGDCUKIxUhAAczCyQJIhQgAAEpAAUmGDEWLwACBR4AAQcEGhscHQcNDg8QERITAicoAgABgPSB1QD%2f%2foADAAAAAGVH8nMAAAAAAANT1A%3d%3d


-- TODO:
--     * (WIP) auto complete button for when all hidden cards are revealed
--     * (DONE) tap on a card and have it move to goal stacks if possible
--     * (not started) (and maybe an option to move it to play columns... some games have this,
--        it's nifty but I find I hit it accidentally and feel like I "cheated")
--     * (DONE) undo button
--     * (DONE, but not working on Sabrina's iPhone??) maybe fix the "pick up cards" offset, so that when
--       you press a card its centre isn't
--       drawn where your finger is
--     * timer, move count, score/points
--     * fix bug where auto complete doesn't keep going if deck is closed (all cards are face down)
--     * (DONE) disable user input while animation is playing (including pressing animation button a second time!)
--     * make animations only "try" to move, not forcefully move the cards
--     * use card_offset for dropping cards. Right now, if you drag from the bottom right, if that little piece isn't
--       over the destination (even though the centre of the card is), it won't get dropped
--
--  Eventually:
--     * show if game is winnable or not (should be an option) after every move?
--     * have option to only generate winnable games (maybe hardcode a couple hundred at first)
--     * the ability to export state to a base 64 string, so you can copy it from your
--       phone to computer and vice versa? (Is there any way to leverage the server for this?)
--     * high scores / records (fewest moves, fastest time, most points?)
--
--     TODO for draw three:
--      * need to preserve popup state, save in persistent state: user should not have to switch from default (draw one) to draw three every time
--      * allow undo many times, use history browse API?
--      * don't save state again on new button presses, only on changes. And not when a card is revealed 
--      * constantly seeing "invalid session id", need to fix
--      * need to disable set_timer_update_ms outside of animations? The game is using a ton of CPU usage when idle...




local session_id = nil
local state = nil 
local g_shown_victory_animation = false
local g_anim_timer_handle = nil

local FPS = 60

-- TODO remove these in favour of the autosaved / history browser state
local DATA_ID_STATE      = "game_state"
local DATA_ID_PREV_STATE = "prev_game_state"

local DATA_ID_SHOW_TIME_AND_MOVE_COUNT = "show_time_and_move_count"

local GAME_OPTION_SHOW_TIME_AND_MOVE_COUNT = "opt_show_time_and_move_count"

draw.show_move_count_and_elapsed_time = storage_helpers.read_bool(DATA_ID_SHOW_TIME_AND_MOVE_COUNT, true)

local POPUP_ID_NEW_GAME = "new_game"
local POPUP_ITEM_ID_BTN_START_GAME = 1
local POPUP_ITEM_ID_BTN_CANCEL     = 2
local POPUP_ITEM_ID_DRAW_TYPE      = 3

-- This is to test what it looks like if the cards are stacked in the highest combination
-- right now it's cut off a bit, but might just barely work
-- if the number of the card is drawn on the corner of the card
--[[
state.play_columns_staging[7][1] = { suit = "spades", val = 13 }
state.deck_unrevealed = {
	{ suit = "diamonds", val = 12 },
	{ suit = "spades",   val = 11 },
	{ suit = "diamonds", val = 10 },
	{ suit = "spades",   val =  9 },
	{ suit = "diamonds", val =  8 },
	{ suit = "spades",   val =  7 },
	{ suit = "diamonds", val =  6 },
	{ suit = "spades",   val =  5 },
	{ suit = "diamonds", val =  4 },
	{ suit = "spades",   val =  3 },
	{ suit = "diamonds", val =  2 },
	{ suit = "spades",   val =  1 },
}
]]

local player = 1
local player_count = 1
local touches = {}
local active_touch = nil

local function draw_board_internal()

	if core.game_won(state) and not g_shown_victory_animation then
		print("Player won, showing victory animation")
		draw.victory_animation(FPS)
		g_shown_victory_animation = true
	end
	draw.draw_state(session_id, state)
end

-- TODO should never call the update_animations from anywhere but here,
-- and should call draw_board_internal in this file only, never `draw_board` directly
function draw_board(dt_ms)
	if dt_ms == nil then
		dt_ms = 0
	end
	--print(string.format("draw_board(dt_ms=%s)", dt_ms))
	core.update_time_elapsed(state, dt_ms)
	draw.update_animations(state, dt_ms)
	draw_board_internal()
end

function handle_user_clicked(pos_y, pos_x)
end

function handle_mousemove(pos_y, pos_x)
	if state == nil then return end
	draw.set_is_touch_controlled(false)
	core.handle_mousemove(state, player, pos_y, pos_x)
	draw_board_internal()
end

local function save_state()
	local prev_state_serialized = alex_c_api.read_stored_data(DATA_ID_STATE)
	if prev_state_serialized ~= nil then
		alex_c_api.store_data(DATA_ID_PREV_STATE, prev_state_serialized)
	end
	local state_serialized = serialize.serialize_state(state)
	alex_c_api.store_data(DATA_ID_STATE, state_serialized)
	-- TODO this is now kind of redundant, consider how to remove the old way of saving state
	alex_c_api.save_state(session_id, state_serialized)
end

local function load_prev_state()
--[[
	local prev_state_serialized = alex_c_api.read_stored_data(DATA_ID_PREV_STATE)
--]]
	print(string.format("loading prev state for session %s", session_id))
	-- If the player presses undo, we want all the previous state
	-- except we want the time elapsed to stay the same.
	local time_elapsed = state.time_elapsed
	local prev_state_serialized = alex_c_api.get_saved_state_offset(session_id, -1)
	if prev_state_serialized ~= nil then
		draw.stop_move_animations()
		state = serialize.deserialize_state(prev_state_serialized)
		state.time_elapsed = time_elapsed
		draw_board()
		alex_c_api.set_status_msg("Loaded previous state")
	else
		alex_c_api.set_status_err("Can not load previous state, not found")
	end
end

local function add_offset(info)
	if info ~= nil then
		local card_pos = draw.get_pos(state, info.section_type, info.col, info.idx)
		if card_pos ~= nil then
			info.card_src_y = card_pos.y
			info.card_src_x = card_pos.x
		end
	end
end

local function mouse_evt_id_to_touch_evt(evt_id)
	if evt_id == 2 then
		return 'touchstart'
	elseif evt_id == 1 then
		return 'touchend'
	elseif evt_id == 3 then
		return 'touchcancel'
	else
		error("unexpected evt_id ", evt_id)
	end
end

local function new_game()
	alex_c_api.show_popup(POPUP_ID_NEW_GAME, {
	                          title = "New Game",
	                          items  = {
	                              {
	                                  id        = POPUP_ITEM_ID_DRAW_TYPE,
	                                  item_type = alex_c_api.POPUP_ITEM_TYPE_DROPDOWN,
	                                  label     = "Draw",
	                                  options   = { "One", "Three" },
	                              },
	                              {
	                                  id        = POPUP_ITEM_ID_BTN_START_GAME,
	                                  item_type = alex_c_api.POPUP_ITEM_TYPE_BTN,
	                                  text      = "Start game",
	                              },
	                              {
	                                  id        = POPUP_ITEM_ID_BTN_CANCEL,
	                                  item_type = alex_c_api.POPUP_ITEM_TYPE_BTN,
	                                  text      = "Cancel",
	                              },
	                          },
	                      })
end


local function handle_nil_state_click()
	new_game()
end

function handle_mouse_evt(evt_id, pos_y, pos_x)
	if state == nil then 
		if evt_id == alex_c_api.MOUSE_EVT_DOWN or evt_id == alex_c_api.MOUSE_EVT_UP then
			handle_nil_state_click()
		end
		return
	end
	local info = draw.pos_to_action(state, player, pos_y, pos_x, mouse_evt_id_to_touch_evt(evt_id))
	add_offset(info)
	if evt_id == 2 then
		local rc = core.handle_mouse_down(player, state, info)
		if rc then
			save_state()
		end
	elseif evt_id == 1 then
		local rc = core.handle_mouse_up(player, state, info)
		if rc then
			save_state()
		end
	elseif evt_id == 3 then
		-- TODO ideally this should cancel rather than release normally
		core.handle_mouse_up(player, state, info)
	end

	draw_board_internal()
end

function handle_touch_evt(evt_id, changed_touches)
	if state == nil then return handle_nil_state_click() end
	draw.set_is_touch_controlled(true)
	local rc = false
	for _, touch in ipairs(changed_touches) do
		local y = math.floor(touch.y)
		local x = math.floor(touch.x)
		if active_touch == touch.id then
			if evt_id == 'touchmove' then
				core.handle_mousemove(state, player, y, x)
			elseif evt_id == 'touchend' then
				local info = draw.pos_to_action(state, player, y, x, evt_id)
				rc = core.handle_mouse_up(player, state, info)
				active_touch = nil
			elseif evt_id == 'touchcancel' then
				rc = core.handle_mouse_up(player, state, nil)
				active_touch = nil
			end
		end

		if evt_id == 'touchstart' then
			if active_touch == nil then
				active_touch = touch.id
				local info = draw.pos_to_action(state, player, y, x, evt_id)
				add_offset(info)
				core.handle_mouse_down(player, state, info)
			end
		end
	end
	draw_board_internal()
	if rc then
		save_state()
	end
end

local function on_anim_finished()
	save_state()
	if g_anim_timer_handle == nil then
		print("on_anim_finished: g_anim_timer_handle is nil")
	else
		alex_c_api.delete_timer(g_anim_timer_handle)
		g_anim_timer_handle = nil
	end
end

local function handle_move_list_animation(move_list)

	if g_anim_timer_handle ~= nil then
		alex_c_api.set_status_err("warning: g_anim_timer_handle was not nil on auto complete btn pressed")
		alex_c_api.delete_timer(g_anim_timer_handle)
		g_anim_timer_handle = nil
	end
	g_anim_timer_handle = alex_c_api.set_timer_update_ms(1000/FPS)

	draw.animate_moves(state, move_list, on_anim_finished)
end

local function start_new_game(draw_type)
	g_shown_victory_animation = false
	session_id = alex_c_api.get_new_session_id()
	local params = {}
	state = core.new_game(player_count, draw_type, params)
	print(string.format("Starting new game (session=%d) (seed %016x %016x) with state: %s",
	      session_id, state.seed_x, state.seed_y,
	      utils.binstr_to_hr_str(serialize.serialize_board_state(state))))
	alex_c_api.set_status_msg(string.format("Generated new grame with seed %x %x", state.seed_x, state.seed_y))
	draw.stop_move_animations()
	save_state()
	draw_board_internal()
end

-- TODO do this in C API instead
local function key_val_list_to_map(list)
	local map = {}
	for _, item in ipairs(list) do
		print(string.format("key=%s, vale=%s", item.id, item.selected))
		map[item.id] = item.selected
	end
	return map
end

function handle_popup_btn_clicked(popup_id, btn_id, popup_state)
	if popup_id == POPUP_ID_NEW_GAME then
		if btn_id == POPUP_ITEM_ID_BTN_START_GAME then
			local popup_state_map = key_val_list_to_map(popup_state)
			local draw_type_dropdown_selected = popup_state_map[POPUP_ITEM_ID_DRAW_TYPE]
			local draw_type = nil
			if draw_type_dropdown_selected == 0 then
				draw_type = core.DRAW_TYPE_ONE
			elseif draw_type_dropdown_selected == 1 then
				draw_type = core.DRAW_TYPE_THREE
			else
				error(string.format("Unhandled new game popup dropdown sel %s", draw_type_dropdown_selected))
			end
			start_new_game(draw_type)
			alex_c_api.hide_popup()
		elseif btn_id == POPUP_ITEM_ID_BTN_CANCEL then
			alex_c_api.hide_popup()
		else
			error(string.format("Unhandled new game popup btn id %s", btn_id))
		end
	else
		error(string.format("Unhandled popup \"%s\"", popup_id))
	end
end

function handle_btn_clicked(btn_id)
	if btn_id == draw.BTN_ID_AUTO_COMPLETE then
		core.autocomplete(state, handle_move_list_animation)
	elseif btn_id == draw.BTN_ID_NEW_GAME then
		--alex_c_api.set_status_msg("Starting new game")
		new_game()
	elseif btn_id == draw.BTN_ID_UNDO then
		load_prev_state()
	else
		error(string.format("Unhandled btn_id \"%s\"", btn_id))
	end
end


function load_hr_binstr_state(version, hr_binstr_state)
	local state_board_serialized = utils.hr_binstr_to_binstr(hr_binstr_state)
	local board_state = serialize.deserialize_board_state(version, state_board_serialized)
	state = core.new_state_from_board_state(player_count, board_state)
	draw_board()
end

function load_saved_state(session_id_arg, state_serialized)
	alex_c_api.set_status_msg(string.format("Loading saved state: %d bytes", #state_serialized)) -- TODO show date of last played?
	local hr_state_serialized = utils.binstr_to_hr_str(state_serialized)
	print("Serialized state: " .. hr_state_serialized)
	session_id = session_id_arg
	state = serialize.deserialize_state(state_serialized)
	g_shown_victory_animation = false
end

function get_state()
	if state == nil then return nil end
	return serialize.serialize_state(state)
end

function get_init_state()
	-- TODO I didn't look into this, but it's possible that the Lua random number seed
	-- stuff is not guaranteed to be consistent across versions of Lua.
	-- So this isn't super robust. I think that's fine for now.
	-- If you generate a state link via `get_state` and send it to a friend, and they're in
	-- a different version of Lua, then they might not be able to get the initial state
	-- themselves.
	--
	-- Partway through implementing this, I realized that all the states are saved in the
	-- history browser anyway, so I should just add a new API to load the oldest state.
	-- But that has two problems:
	--     1. if you share a link, it won't contain the original state. (Though I could add it,
	--        I suppose, doubling the size of the state)
	--     2. I will probably start pruning old saved states at some point, since I think
	--        the browser limits you to ~5 MB. (When I do that, I should add the option to mark
	--        some saved states as "more important".
	if state and state.seed_x and state.seed_y then
		local params = {
			seed_x = state.seed_x,
			seed_y = state.seed_y,
		}
		local init_state = core.new_game(player_count, state.draw_type, params)
		print(string.format("Generated initial state from seeds %016x %016x:", state.seed_x, state.seed_y))
		core.print_state(init_state)
		return serialize.serialize_state(init_state)
	else
		return ""
	end
end

function handle_game_option_evt(option_id, value)
	print(string.format("handle_game_option(option_id=%s, value=%s)", option_id, value))
	if option_id == GAME_OPTION_SHOW_TIME_AND_MOVE_COUNT then
		draw.show_move_count_and_elapsed_time = value
		storage_helpers.store_bool(DATA_ID_SHOW_TIME_AND_MOVE_COUNT, value)
		draw_board_internal()
	end
end

draw.init(480, 480)

function start_game(session_id_arg, state_serialized) 
	print(string.format("start_game(session_id=%d, state_serialized=%s)", session_id_arg, state_serialized))

	alex_c_api.enable_evt('mouse_move')
	alex_c_api.enable_evt('mouse_updown')
	alex_c_api.enable_evt('touch')
	
	if state_serialized ~= nil then
		print(string.format("start_game: loading from state param"))
		session_id = session_id_arg
		load_saved_state(session_id_arg, state_serialized)
		print(string.format("start_game: done loading from state param"))
	else
		-- this shouldn't be happening anymore, right?
		--print(string.format("start_game: no state param provided, checking if saved game stored in persistent storage"))
		--local state_serialized = alex_c_api.read_stored_data(DATA_ID_STATE)
		local last_session_id = alex_c_api.get_last_session_id()
		if last_session_id ~= nil then
			state_serialized = alex_c_api.get_saved_state_offset(last_session_id, 0)
		end

		-- this shouldn't usually be possible, but I think it happens if I manage to increment the session ID
		-- without storing a valid state.
		if state_serialized ~= nil then
			load_saved_state(last_session_id, state_serialized)
		else
			alex_c_api.set_status_msg("No saved state found, starting new game")
			new_game()
		end
	end

	alex_c_api.add_game_option(GAME_OPTION_SHOW_TIME_AND_MOVE_COUNT, {
		type  = alex_c_api.OPTION_TYPE_TOGGLE,
		label = "Show elapsed time and move count",
		value = draw.show_move_count_and_elapsed_time,
	} )
	
	-- Set a timer for every second, to update the "time elapsed" in the corner
	alex_c_api.set_timer_update_ms(1000)
end
local serialize = {}

local cards = require("libs/cards/cards")
local serialize_lib = require("libs/serialize/serialize")

local core  = require("games/solitaire/solitaire_core")

serialize.VERSION = 2

function serialize.serialize_board_state(state)
	local output = ""
	output = output .. serialize_lib.serialize_byte(state.draw_type)
	output = output .. cards.serialize_card_array(state.deck_unrevealed)
	output = output .. cards.serialize_card_array(state.deck_draw)
	output = output .. cards.serialize_card_array(state.deck_discard)
	for i=1,core.NUM_PLAY_COLUMNS do
		output = output .. cards.serialize_card_array(state.play_columns_unrevealed[i])
		output = output .. cards.serialize_card_array(state.play_columns_staging[i])
	end
	for i=1,core.NUM_GOAL_STACKS do
		output = output .. cards.serialize_card_array(state.goal_stacks[i])
	end

	if state.move_count ~= nil then
		output = output .. serialize_lib.serialize_16bit(state.move_count)
	else
		output = output .. serialize_lib.serialize_16bit(0)
	end

	if state.time_elapsed ~= nil then
		output = output .. serialize_lib.serialize_16bit(state.time_elapsed)
	else
		output = output .. serialize_lib.serialize_16bit(0)
	end
	return output
end

function serialize.serialize_state(state)
	if state == nil then
		error("arg is nil", 2)
	end

	local output = ""
	output = output .. serialize_lib.serialize_byte(serialize.VERSION)
	output = output .. serialize_lib.serialize_byte(state.player_count)
	output = output .. serialize.serialize_board_state(state)

	-- TODO I don't like the player state being serialized
	for _, player_state in ipairs(state.players) do
		output = output .. serialize_lib.serialize_16bit(player_state.y)
		output = output .. serialize_lib.serialize_16bit(player_state.x)
		output = output .. cards.serialize_card_array(player_state.holding)
		output = output .. serialize_lib.serialize_16bit(player_state.holding_src)
		output = output .. serialize_lib.serialize_16bit(player_state.holding_src_col)
	end
	output = output .. serialize_lib.serialize_u64(state.seed_x)
	output = output .. serialize_lib.serialize_u64(state.seed_y)
	return output
end


local function deserialize_board_state_internal(version, bytes, state)
	state.draw_type       = serialize_lib.deserialize_byte(bytes)
	state.deck_unrevealed = cards.deserialize_card_array(bytes)
	state.deck_draw       = cards.deserialize_card_array(bytes)
	state.deck_discard    = cards.deserialize_card_array(bytes) state.play_columns_unrevealed = {}
	state.play_columns_staging    = {}
	for i=1,core.NUM_PLAY_COLUMNS do
		state.play_columns_unrevealed[i] = cards.deserialize_card_array(bytes)
		state.play_columns_staging[i]    = cards.deserialize_card_array(bytes)
	end
	state.goal_stacks = {}
	for i=1,core.NUM_GOAL_STACKS do
		state.goal_stacks[i] = cards.deserialize_card_array(bytes)
	end

	print(string.format('Deserializing board state version %d', version))
	if version == 1 then
		-- do nothing
	elseif version == serialize.VERSION then
		state.move_count   = serialize_lib.deserialize_16bit(bytes)
		state.time_elapsed = serialize_lib.deserialize_16bit(bytes)
	else
		error(string.format("Unhandled solitaire serialized state version " ..
		                    "%d, expected <= %d",
		                    version,
		                    serialize.VERSION))
	end
end

function serialize.deserialize_board_state(bytes)
	local state = {}
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	deserialize_board_state_internal(version, bytes, state)

	if #bytes ~= 0 then
		error(string.format("%d bytes remaining after deserializing", #bytes))
	end

	return state
end

function serialize.deserialize_state(bytes)
	bytes = serialize_lib.bytestr_to_byteary(bytes)
	local state = {}
	local first_byte = serialize_lib.deserialize_byte(bytes)
	local version
	-- in the first version, I didn't have a byte for version.
	-- But I did have a player count that was always 1
	if first_byte == 1 then
		state.player_count = 1
		version = 1
	else
		version = first_byte
		if version ~= serialize.VERSION then
			error(string.format("Received solitaire serialized state for " ..
			                    "version %d, but can only handle <= %d",
			                    version, serialize.VERSION))
		end
		state.player_count    = serialize_lib.deserialize_byte(bytes)
	end

	deserialize_board_state_internal(version, bytes, state)

	state.players = {}
	for i=1, state.player_count do
		state.players[i] = {}
		state.players[i].y               = serialize_lib.deserialize_16bit(bytes)
		state.players[i].x               = serialize_lib.deserialize_16bit(bytes)
		state.players[i].holding         = cards.deserialize_card_array(bytes)
		state.players[i].holding_src     = serialize_lib.deserialize_16bit(bytes)
		state.players[i].holding_src_col = serialize_lib.deserialize_16bit(bytes)
	end
	state.seed_x = serialize_lib.deserialize_u64(bytes)
	state.seed_y = serialize_lib.deserialize_u64(bytes)

	if #bytes ~= 0 then
		error(string.format("%d bytes remaining after deserializing", #bytes))
	end

	return state
end

return serialize
local solve = {}

local cards     = require("libs/cards/cards")
local cards_set = require("libs/cards/cards_set")
local utils     = require("libs/utils")
local core      = require("games/solitaire/solitaire_core")
local solitaire_serialize = require("games/solitaire/solitaire_serialize")

--[[
--  TODO: need to try traversing these trees in real time to see what 
--        they manage to do in so much wasted time.
--        Implement logic to favour moves that I would in real life.
--        Also keep an eye out for bad moves that should never be allowed,
--        or should be heavily deprioritized.
--        To do figure out the most effective ways to fix all this:
--            * make nodes reference each other, and
--            * make a nicely readable state to ASCII function, likely using the ascii symbols
--              for heart/diamond/clubs/spades
--            * at each state, print a list of all possible moves, and all the moves that each one led to.
--              This should help estimate how much time is being wasted.
--            * Allow easily traversing the graph with keyboard shortcuts.
--]]


local MOVE_POS_DECK  = 1
local MOVE_POS_GOAL  = 3


--[[
-- These priorities seem to get pretty good results
local PRI_MOVE_TO_GOAL_STACK        = 1
local PRI_MOVE_KING_TO_EMPTY_COL    = 2
local PRI_MOVE_LAST_CARDS_IN_STAGING = 3
local PRI_NORMAL                    = 3
local PRI_MOVE_FROM_DECK            = nil
local PRI_MOVE_AROUND_STAGING       = nil
local PRI_MOVE_FROM_GOAL_STACK      = 6
local NUM_PRIORITIES = 6
--]]

local PRI_MOVE_TO_GOAL_STACK        = 1
local PRI_MOVE_KING_TO_EMPTY_COL    = 2
local PRI_MOVE_LAST_CARDS_IN_STAGING = 3 -- TODO increasing this above normal doesn't seem to help
local PRI_NORMAL                    = 3
local PRI_MOVE_FROM_DECK            = nil
local PRI_MOVE_AROUND_STAGING       = nil
local PRI_MOVE_FROM_GOAL_STACK      = 6
local NUM_PRIORITIES = 6

local SECTION_DECK_POS_INDEPENDENT = core.SECTION_LAST + 1

local player = 1 -- TODO

-- converts suit to an index from 1 to 4.
-- Used to choose which goal stack to put cards in,
-- to avoid a bunch of duplicate positions
local suit_idx_map = {}

for i, suit in ipairs(cards.suits) do
	suit_idx_map[suit] = i
end

-- TODO: print each move, so I can figure out what is going on.
-- keep track of prev move


--[[
-- Here is my plan for a solitaire solving algorithm:
--   make a "state to hash" api that returns a string that represents a unique
--   game state-- but returning the same hash for trivial variations of the same state,
--   such as:
--      * cycling through the deck, and
--      * moving a king (or its stack) from one empty column to another
--   I think I can simply:
--      * always hash the deck as if it were not opened, and
--      * have a separate set of columns for kings on an empty column?
--
--
-- Then I'd guess that it would be as simple as:
--    * loop through all possible moves, recurse...?
--
-- Since I'm taking shortcuts, I couldn't consider "reveal next card in deck" as a move.
-- So I'd have to loop through every possible move for every possible card in the deck.
-- That's not too hard either.
--
-- Then that's it? Return true once it's possible to reach a state where all the unrevealed
-- cards are revealed?
--]]

local function section_type_to_string(section_type)
	local type_to_str = {
		[core.SECTION_PLAY_COLUMN_UNREVEALED] = 'PLAY_COL_U',
		[core.SECTION_PLAY_COLUMN_STAGING]    = 'PLAY_COL',
		[core.SECTION_GOAL_STACKS]            = 'GOAL',
		[SECTION_DECK_POS_INDEPENDENT]        = 'DECK_PI',
	}
	return type_to_str[section_type]
end

local function format_int(val, chars)
	if val == nil then
		--return string.format("%-*s", chars, val)
		return string.format("%-" .. chars .. "s", val)
	else
		return string.format("%" .. chars .. "d", val)
	end
end

local function pos_to_str(pos)
	local s = string.format("{%-8s, %s, %s;",
	      section_type_to_string(pos.section_type), format_int(pos.col, 3), format_int(pos.idx, 3))
	if pos.card ~= nil then
		s = s .. string.format(" (%-12s)", cards.card_to_string(pos.card))
	end
	s = s .. "}"
	return s
end

local function print_move(prev_state_id, move, next_state_id, is_duplicate_state, info)
	local dup_string = ""
	if is_duplicate_state then
		dup_string = "(visited)"
	end
	print(string.format("from state id=%3d, src%s -> dst%s to state id %3d%s; %s",
	      prev_state_id,
	      pos_to_str(move.src),
	      pos_to_str(move.dst),
	      next_state_id, dup_string, info))
end
		

local function get_deck_pos_independent(state)
	local deck = {}
	for _, card in ipairs(state.deck_revealed) do
		table.insert(deck, card)
	end
	--for _, card in ipairs(state.deck_unrevealed) do
	for i=#state.deck_unrevealed,1,-1 do
		local card = state.deck_unrevealed[i]
		table.insert(deck, card)
	end

	return deck
end


-- Returns the serialized card array for each goal stack
-- in the order of cards.suits
-- 
-- The purpose is so that a whole new game isn't simulated
-- if the player chose to put the hearts in goal stack 1 or 2
function solve.get_goal_stacks_hash(state)
	local hash = ''
	for _, suit in ipairs(cards.suits) do
		local stack = {}
		for i=1,#state.goal_stacks do
			if #state.goal_stacks[i] > 0 and state.goal_stacks[i][1].suit == suit then
				stack = state.goal_stacks[i]
			end
		end
		hash = hash .. cards.serialize_card_array(stack)
	end
	return hash
end

function solve.state_to_hash(state)

	local hash = ''

	hash = hash .. cards.serialize_card_array(get_deck_pos_independent(state))
	hash = hash .. solve.get_goal_stacks_hash(state)

	local empty_stacks = {}

	local group_empty_stacks = true

	for i=1,core.NUM_PLAY_COLUMNS do
		local unrevealed = state.play_columns_unrevealed[i]
		local staging    = state.play_columns_staging[i]
		if group_empty_stacks and #unrevealed == 0 then
			table.insert(empty_stacks, staging)
			staging = {}
		end
		hash = hash .. cards.serialize_card_array(unrevealed)
		hash = hash .. cards.serialize_card_array(staging)
	end

	if group_empty_stacks then
	for _, suit in ipairs(cards.suits) do
		local suit_stack = {}
		for _, stack in ipairs(empty_stacks) do
			if #stack > 0 and stack[1].suit == suit then
				suit_stack = stack
			end
		end
		hash = hash .. cards.serialize_card_array(suit_stack)
	end
	end

	return hash
end

local function get_card_stack_positions_quick_order(num)
	if num == 0 then return { }
	elseif num == 1 then return { 1 }
	else
		local list = { 1, num }
		for i=2,num-1 do
			table.insert(list, i)
		end
		return list
	end
end

function solve.get_possib_src_cards(state)
	local src_cards = {}
	for i=1,core.NUM_PLAY_COLUMNS do
		local play_col = state.play_columns_staging[i]
		-- for j=#play_col,1,-1 do
		for _, j in ipairs(get_card_stack_positions_quick_order(#play_col)) do
			local card_stack = {}
			for k=j,#play_col do
				table.insert(card_stack, play_col[k])
			end
			table.insert(src_cards, {
				section_type = core.SECTION_PLAY_COLUMN_STAGING,
				col = i,
				idx = j,
				cards = card_stack,
				--card = play_col[j], -- TODO replace with card stack
			})
		end
	end

	for i=1,core.NUM_GOAL_STACKS do
		local stack = state.goal_stacks[i]
		if #stack > 0 then
			table.insert(src_cards, {
				section_type = core.SECTION_GOAL_STACKS,
				col = i,
				idx = #stack,
				cards = {stack[#stack]},
			})
		end
	end

	local deck = get_deck_pos_independent(state)
	for i=1,#deck do
		table.insert(src_cards, {
			section_type = SECTION_DECK_POS_INDEPENDENT,
			col = i,
			cards = {deck[i]},
		})
	end

	-- return cards_set.card_list_to_set(src_cards)
	return src_cards
end

function solve.get_possib_dsts(state)
	local dsts = {}

	for i=1,core.NUM_GOAL_STACKS do
		table.insert(dsts, {
			section_type = core.SECTION_GOAL_STACKS,
			col = i
		})
	end

	for i=1,core.NUM_PLAY_COLUMNS do
		table.insert(dsts, {
			section_type = core.SECTION_PLAY_COLUMN_STAGING,
			col = i,
		})
	end

	return dsts
end

function is_useful_move(state, src_info, dst_info)
	--assert(#src_info.cards > 0)
	--print(cards.card_array_to_string(src_info.cards))
	if src_info.section_type == core.SECTION_GOAL_STACKS and
	   dst_info.section_type == core.SECTION_GOAL_STACKS then
		return false
	elseif dst_info.section_type == core.SECTION_GOAL_STACKS and
	       suit_idx_map[src_info.cards[1].suit] ~= dst_info.col then
		return false
	-- moving kings around empty columns is not useful
	elseif src_info.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	       dst_info.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	       src_info.cards[1].val == cards.KING and
	       #state.play_columns_unrevealed[src_info.col] == 0 then
		return false
	end
	if dst_info.section_type ~= core.SECTION_GOAL_STACKS then
		--print("WARNING: SKIPPING DST NON GOAL STACKS MOVE FOR TESTING")
		--return false
	end

	return true
end

function new_move_priority_queue(priorities)
	local moves = {}
	for i=1,priorities do
		table.insert(moves, {})
	end
	return moves
end

function add_move(moves, priority, move_info)
	table.insert(moves[priority], move_info)
end


function has_moves(moves)
	for _, priority_list in ipairs(moves) do
		if #priority_list > 0 then return true end
	end
	return false
end

function moves_count(moves)
	local count = 0
	for _, queue in ipairs(moves) do
		count = count + #queue
	end
	return count
end

function get_move_count_str(moves)
	s = '{'
	for i, queue in ipairs(moves) do
		if i ~= 1 then s = s .. ', ' end
		s = s .. string.format('%d', #queue)
	end
	return s .. '}'
end

function get_move_priority(state, move)
	if move.src.section_type == core.SECTION_GOAL_STACKS then
		return PRI_MOVE_FROM_GOAL_STACK
	elseif move.dst.section_type == core.SECTION_GOAL_STACKS then
		return PRI_MOVE_TO_GOAL_STACK

	elseif move.src.section_type == core.SECTION_PLAY_COLUMN_STAGING and
		-- interestingly, changing this from #col == 1 to #col == #cards_held
		-- results in the first few tests going from 250 ms to ~10 ms,
		-- but test 4 goes up from 420 ms to 3480 s.
	       #state.play_columns_staging[move.src.col] == #move.src.cards then
	       -- #state.play_columns_staging[move.src.col] == 1 then
		return PRI_MOVE_LAST_CARDS_IN_STAGING
	elseif PRI_MOVE_KING_TO_EMPTY_COL ~= nil and
	       move.src.cards[1].val == cards.KING and
	       move.src.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	       move.dst.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	       #state.play_columns_staging[move.dst.col] == 0 then
		return PRI_MOVE_KING_TO_EMPTY_COL
	elseif PRI_MOVE_FROM_DECK ~= nil and
	       move.src.section_type == SECTION_DECK_POS_INDEPENDENT then
		return PRI_MOVE_FROM_DECK
	elseif PRI_MOVE_AROUND_STAGING ~= nil and 
	       move.src.section_type == core.SECTION_PLAY_COLUMN_STAGING and
	       move.dst.section_type == core.SECTION_PLAY_COLUMN_STAGING then
		return PRI_MOVE_AROUND_STAGING
	else
		return PRI_NORMAL
	end
end

function pop_move(moves)
	for _, queue in ipairs(moves) do
		if #queue > 0 then
			return table.remove(queue)
		end
	end
	error("popped on empty queue", 2)
end

function merge_moves(moves, new_moves)
	for priority, queue in ipairs(new_moves) do
		for _, move_info in ipairs(queue) do
			table.insert(moves[priority], move_info)
		end
	end
end


function solve.get_possib_moves(state, prev_state_id, state)
	local moves = new_move_priority_queue(NUM_PRIORITIES)
	-- print("deck: ", #state.deck_unrevealed, #state.deck_revealed, #get_deck_pos_independent(state))
	local srcs = solve.get_possib_src_cards(state)
	local dsts = solve.get_possib_dsts(state)
	--print(string.format("found %d possib srcs, %d possib dsts", #srcs, #dsts))
	for _, src_info in ipairs(srcs) do
		for _, dst_info in ipairs(dsts) do
			local useful_move = false
			if core.can_place_card(state, src_info.cards, dst_info) and
               is_useful_move(state, src_info, dst_info) then
				--table.insert(moves, {src = src_info, dst = dst_info})
				local move = {src = src_info, dst = dst_info}
				local priority = get_move_priority(state, move)
				local move_info = { 
					prev_state_id = prev_state_id,
					state = state, -- TODO remove this copy
					move = move,
				}
				add_move(moves, priority, move_info)
				useful_move = true
			end
			--[[
			print(string.format("checking if src=%s card=%-13s can be moved to dst=%s: %s, %s",
                  section_type_to_string(src_info.section_type),
			      cards.card_to_string(src_info.card),
                  section_type_to_string(dst_info.section_type),
                  core.can_place_card(state, src_info.card, dst_info),
                  core.can_place_card(state, src_info.card, dst_info)  and is_useful_move(state, src_info, dst_info)))
			]]
		end
	end
	return moves
end

local function make_move(state, move)
	move = core.copy_move(move)
	--core.print_state(state)
	--print(string.format("attempting to move from %s to %s", pos_to_str(move.src), pos_to_str(move.dst)))
	if move.src.section_type == SECTION_DECK_POS_INDEPENDENT then
		while #state.deck_revealed ~= move.src.col do
			core.handle_mouse_down(player, state, {section_type = core.SECTION_DECK_UNREVEALED })
		end
		--print(cards.card_to_string(state.deck_revealed[#state.deck_revealed]), cards.card_to_string(move.src.card))
		assert(cards.cards_eq(state.deck_revealed[#state.deck_revealed], move.src.cards[1]))
		move.src = {section_type = core.SECTION_DECK_REVEALED}
	end

	core.handle_move(state, player, move)

	for i=1,core.NUM_PLAY_COLUMNS do
		if #state.play_columns_staging[i] == 0 then
			assert(#state.play_columns_unrevealed[i] == 0)
		end
	end
end

local function get_cards_in_goals(state)
	local count = 0
	for _, goal_stack in ipairs(state.goal_stacks) do
		count = count + #goal_stack
	end
	return count
end

local function get_hidden_cards(state)
	local count = 0
	for _, hidden_stack in ipairs(state.play_columns_unrevealed) do
		count = count + #hidden_stack
	end
	return count
end


function solve.new_solve_state(params)
	local new_solve_state = {
		params = params,
		max_goal_cards = 0,
		min_hidden_cards = nil,
		best_cards_state = nil,
	}
	return new_solve_state
end

function solve.is_solvable(state, solve_state)
	if solve_state == nil then
		solve_state = solve.new_solve_state()
	end
	solve_state.start_time = os.time()
	local seen_states = {}
	local moves_to_try = new_move_priority_queue(NUM_PRIORITIES)

	-- TODO I need to think about this.
	-- * Keep track of the current state.
	-- * for every possible move from the current state, try
	--   making each move and see what happens to the state.
	-- * Then recurse. But stop if you already encountered this state before.
	--   Return true if all play_columns_unrevealed are empty

	-- So:
	-- * store current state in a node,
	-- * for each possible move, copy state, apply move, check hash.
	-- * if hash is already in map, skip-- duplicate result.
	-- * if hash is not in map, then create a new node and repeat

	local new_moves = solve.get_possib_moves(state, 0, state)
	--print("new_moves init: ", has_moves(new_moves))
	merge_moves(moves_to_try, new_moves)

	solve_state.counter = 0
	solve_state.unique_states_counter = 0
	while has_moves(moves_to_try) do
		--print(string.format("count=%d, unique_states=%d, moves_to_try=%d", counter, unique_states_counter, moves_count(moves_to_try)))
		solve_state.counter = solve_state.counter + 1
		--local move_to_try = table.remove(moves_to_try)
		local move_to_try = pop_move(moves_to_try)
		--local move_to_try = table.remove(moves_to_try, 1)
		local state2 = core.copy_state(move_to_try.state)

		make_move(state2, move_to_try.move)

		if core.play_cols_unrevealed_empty(state2) then
			return true
		end


		local state2_hash = solve.state_to_hash(state2)


		local is_duplicate_state
		if seen_states[state2_hash] == nil then
			solve_state.unique_states_counter = solve_state.unique_states_counter + 1
			seen_states[state2_hash] = solve_state.unique_states_counter
			is_duplicate_state = false
		else
			is_duplicate_state = true
		end

		local goal_cards = get_cards_in_goals(state2)
		local hidden_cards = get_hidden_cards(state2)
		--if goal_cards >= max_goal_cards then
		if solve_state.min_hidden_cards == nil or hidden_cards <= solve_state.min_hidden_cards then
			solve_state.max_goal_cards = goal_cards 
			solve_state.min_hidden_cards = hidden_cards
			solve_state.best_cards_state = core.copy_state(state2)
		end

		assert(#state.players[player].holding == 0)
		local next_state_id = seen_states[state2_hash]
		--print(string.format("%3d: %s", next_state_id, utils.binstr_to_hr_str(state2_hash)))
		--print(string.format("%3d state ser: %s", next_state_id, utils.binstr_to_hr_str(solitaire_serialize.serialize_state(state2))))


		if true or not is_duplicate_state then
			--print_move(move_to_try.prev_state_id, move_to_try.move, next_state_id, is_duplicate_state, get_cards_in_goals(state2))
		end

		if solve_state.params.update_period ~= nil and 
		   solve_state.counter % solve_state.params.update_period == 0 then
			if solve_state.params.id ~= nil then
				print(solve_state.params.id)
			end
			print(string.format("counter %d, min_hidden_cards = %d, max_goal_cards = %d", solve_state.counter, solve_state.min_hidden_cards, solve_state.max_goal_cards))
			print(string.format("count=%d, unique_states=%d, moves_to_try=%s", solve_state.counter, solve_state.unique_states_counter, get_move_count_str(moves_to_try)))
			core.print_state(solve_state.best_cards_state)
			print(string.format("board_state_ser: %s", utils.binstr_to_hr_str(solitaire_serialize.serialize_board_state(state2))))
			collectgarbage("collect")
		end

		local time_s = os.time()
		if solve_state.params.timeout_s ~= nil and
		   time_s - solve_state.start_time >= solve_state.params.timeout_s then
			error("solvable check timed out")
		end

		if is_duplicate_state then
			goto next_move
		end

		local new_moves = solve.get_possib_moves(state, seen_states[state2_hash], state2)
		merge_moves(moves_to_try, new_moves)


		::next_move::
	end

	return false
end


return solve
local core = {}

local PLAYER_MASS = 1

local function generate_spots(spots, x_pos)
	for i=1,10 do
		table.insert(spots, {
			y = 40 + math.random()*400,
			x = x_pos + math.random()*480,
		})
	end
end

function core.reset_player_state(state, player_idx)
	local player = state.players[player_idx]
	player.y  = 250
	player.x  = 0
	player.dy = 0
	player.dx = 0
	core.player_attach_swing(state, 1, 1)
end

local function squared(x)
	return x*x
end

local function get_speed(player)
	if player.swinging_on == nil then
		return math.sqrt(squared(player.dx) + squared(player.dy))
	else
		return math.abs(player.angleV * player.swing_len)
	end
end

function core.get_energy(state, player_idx)
	local player = state.players[player_idx]

	local player_height = (state.max_y - player.y)
	return PLAYER_MASS * (0.5*squared(get_speed(player)) + state.gravity_y *  player_height)
end

function core.new_state()
	local state = {
		players     = {
			{
				y  =  250,
				x  =    0,
				--dy = -250,
				--dx =  150,
				dy =    0,
				dx =    0,
				swinging_on = nil,
				swing_len   = nil,
			},
		},
		swing_spots = {
		--	{ y = 225, x = 250, },
	
			{ y = 150, x = 0, },

		--[[
			{ y = 25, x = 250, },
			{ y = 25, x = 500, },
			{ y = 25, x = 750, },
			{ y = 150, x = 1000, },
		--]]

		--[[
			{ y = 480 - 25, x = 1150, },
			{ y = 480 - 25, x = 1150 + 1*75, },
			{ y = 480 - 25, x = 1150 + 2*75, },
			{ y = 480 - 25, x = 1150 + 3*75, },
			{ y = 480 - 25, x = 1150 + 4*75, },
			{ y = 480 - 25, x = 1150 + 5*75, },
		--]]
		},

		gravity_y = 312,
		gravity_x =   0,

		max_y     =  480,
		game_over = false,

		finish_line_x = 5125,
	}

	for i=0,10 do
		generate_spots(state.swing_spots, 0 + 480*i)
	end
	core.player_attach_swing(state, 1, 1)
	return state
end

local function update_position(state, entity, dt_ms)
	entity.dy = entity.dy + state.gravity_y * dt_ms/1000
	entity.dx = entity.dx + state.gravity_x * dt_ms/1000
	entity.y = entity.y + entity.dy * dt_ms/1000
	entity.x = entity.x + entity.dx * dt_ms/1000
end

local function update_swinging_position(state, player, dt_ms)
	local node = state.swing_spots[player.swinging_on]
	local swing_dy = player.y - node.y
	local swing_dx = player.x - node.x
	player.swing_angle = math.atan(swing_dy,swing_dx)
	player.swing_len = math.sqrt(swing_dy*swing_dy + swing_dx*swing_dx)

	local gravity_force_perp_to_swing = state.gravity_y * math.sin(player.angle)
	local angleA = -gravity_force_perp_to_swing / player.swing_len
	player.angleV = player.angleV + angleA * dt_ms/1000
	player.angle = player.angle + player.angleV * dt_ms/1000

	player.x = node.x + player.swing_len * math.sin(player.angle)
	player.y = node.y + player.swing_len * math.cos(player.angle)

	--[[

	local x2 = swing_dx
	local y2 = swing_dy 

	local accel = -state.gravity_y * (x2/swing_len) * (swing_len - y2)/swing_len
	player.x = player.x + (player.dx + (accel/2 * dt_ms/1000)) * dt_ms/1000
	player.y = node.y + math.sqrt(swing_len*swing_len - x2*x2) - swing_len

	player.dx = player.dx + accel * dt_ms/1000
	--]]

	--[[
	player.swing_angle = math.atan(swing_dy,swing_dx)

	local swinging_gravity_y = state.gravity_y * math.sin(player.swing_angle + math.pi/2)
	local swinging_gravity_x = state.gravity_y * math.cos(player.swing_angle + math.pi/2)

	player.dy = player.dy + swinging_gravity_y * dt_ms/1000
	player.dx = player.dx + swinging_gravity_x * dt_ms/1000
	
	player.y = player.y + player.dy * dt_ms/1000
	player.x = player.x + player.dx * dt_ms/1000
	--]]

	

	
end

function core.update_state(state, dt_ms)
	if state.game_over then return end
	for _, player in ipairs(state.players) do
		if player.swinging_on == nil then
			update_position(state, player, dt_ms)
		else
			update_swinging_position(state, player, dt_ms)
		end

		if player.y > state.max_y then
			state.game_over = true
		end
	end
end

function core.get_closest_swing_spot(state, pos)
	local min_dist = nil
	local closest_node = nil

	-- TODO store these nodes in groups of screen size or something,
	-- to avoid looking through all of them
	for node_idx, node in ipairs(state.swing_spots) do
		local dy = pos.y - node.y
		local dx = pos.x - node.x
		local dist = math.sqrt(dy*dy + dx*dx)
		if min_dist == nil or dist < min_dist then
			closest_node = node_idx
			min_dist     = dist
		end
	end

	return closest_node
end

function core.player_attach_swing(state, player_idx, node_idx)
	local player = state.players[player_idx]
	local node = state.swing_spots[node_idx]

	player.swinging_on = node_idx
	local dy = node.y - player.y
	local dx = node.x - player.x

	player.swing_len = math.sqrt(dy*dy + dx*dx)
	--player.swing_angle = math.atan(dy, dx) + math.pi
	
	player.angle = math.atan(-dy, dx) - math.pi/2
	local angle2 = math.atan(dy, -dx) + math.pi
	player.angleV = (player.dx * math.sin(angle2) + player.dy * math.cos(angle2)) / player.swing_len
	player.dy = 0 -- TODO
	player.dx = 0 -- TODO
end
function core.player_release_swing(state, player_idx)
	local player = state.players[player_idx]
	if player.swinging_on == nil then return end
	local node = state.swing_spots[player.swinging_on]
	player.swinging_on = nil
	local angle2 = math.atan(player.y - node.y, -player.x + node.x)
	player.dy = math.cos(angle2) * player.swing_len * player.angleV
	player.dx = math.sin(angle2) * player.swing_len * player.angleV
	player.angleV = 0
end

function core.player_won(state, player_idx)
	return state.players[player_idx].x >= state.finish_line_x
end


return core
local draw = {}
local core = require("games/spider_swing/spider_swing_core")

local draw_celebration_anim = require("libs/draw/draw_celebration_anim")

local alex_c_api = require("alex_c_api")

local PLAYER_COLOURS = {
	[1] = { fill = '#cc8888', outline = '#ff0000', },
}
local PLAYER_RADIUS = 20
local PLAYER_WIDTH = 70
local PLAYER_HEIGHT = 50
local WEB_OFFSET = 10

local SWING_SPOT_RADIUS = 5
local SWING_SPOT_COLOUR = { fill = '#00ffff', outline = '#0000ff', }

local ROPE_THICKNESS = 4

local anim_state = draw_celebration_anim.new_state({
	on_finish = function ()
	end,
})


local function get_camera_pos(game_state, player_idx)
	--local camera = { y = 240, x = 240 }
	--local camera = { y = 0, x = 0 }
	local player = game_state.players[player_idx]
	local camera = {
		--y = player.y - 480/2,
		y = 0,
		x = math.max(player.x - 480/3, -480/3),
	}
	return camera
end


-- translate mouse position to game position
function draw.get_mouse_pos_in_game(game_state, player_idx, pos_y, pos_x)
	local player = game_state.players[player_idx]
	local camera = get_camera_pos(game_state, player_idx)
	local pos = {
		y = camera.y + pos_y,
	    x = camera.x + pos_x,
	}
	return pos
end

local function draw_finish_line(screen_x_pos, bg_height)

	local checker_count_y = 20
	local checker_count_x = 3
	local checker_size = bg_height / checker_count_y

	local FINISH_LINE_OUTLINE_COLOUR = '#888888'

	alex_c_api.draw_line(FINISH_LINE_OUTLINE_COLOUR, 1,
	                     0,   screen_x_pos,
	                     bg_height, screen_x_pos)
	alex_c_api.draw_line(FINISH_LINE_OUTLINE_COLOUR, 1,
	                     0,   screen_x_pos + checker_size * checker_count_x,
	                     bg_height, screen_x_pos + checker_size * checker_count_x)

	for i=0,checker_count_y-1 do
		for j=0,checker_count_x-1 do
			local checker_colour
			if (i*checker_count_x + j) % 2 == 0 then
				checker_colour = '#000000'
			else
				checker_colour = '#ffffff'
			end

			alex_c_api.draw_rect(checker_colour,
			                     (i  )*checker_size, screen_x_pos + (j  )*checker_size,
			                     (i+1)*checker_size, screen_x_pos + (j+1)*checker_size)
		end
	end
end

function draw.draw_state(game_state, player_idx, dt_ms)
	local camera = get_camera_pos(game_state, player_idx)
	alex_c_api.draw_clear()

	--alex_c_api.draw_rect('#aaaaaa', 0, 0, 480, 480)
	local bg_height = 480
	local bg_width = 480
	local screen_bg_pos = {
		y = math.floor(-(camera.y-math.floor(camera.y/bg_height)*bg_height)),
		x = math.floor(-(camera.x-math.floor(camera.x/bg_width)*bg_width)),
	}

	-- Draw two tiles of the background, that's the most that are ever visible at a time.
	for i=0,1 do
		local offset = 3 -- WTF why is this needed? Why doesn't my image tile nicely with this "offset" set to 0??
		                 -- ah, I shouldn't have the brick outline on both sides. TODO remove outline on right

		-- TODO I couldn't figure out how to make the bg image stop tiling at a certain position
		--if i == 1 then print(string.format("camera_real_pos_x = %8.1f", camera.x + i*bg_width)) end
		--if camera.x + (i+1)*bg_width > game_state.max_x then
		--	goto draw_bg_continue
		--end
		alex_c_api.draw_rect('#aaaaaa', math.floor(screen_bg_pos.y),             math.floor(screen_bg_pos.x + i * bg_width-offset),
		                                math.floor(screen_bg_pos.y) + bg_height, math.floor(screen_bg_pos.x + i * bg_width-offset) + bg_width)
		alex_c_api.draw_graphic('brick_wall',
		                        screen_bg_pos.y + bg_height/2, i*(bg_width-offset) + math.floor(screen_bg_pos.x) + bg_width/2, bg_width, bg_height)
		::draw_bg_continue::
	end

	draw_finish_line(game_state.finish_line_x - camera.x, bg_height)

	for player_idx, player in ipairs(game_state.players) do
		--alex_c_api.draw_circle(PLAYER_COLOURS[player_idx].fill, PLAYER_COLOURS[player_idx].outline,
		--                       math.floor(player.y - camera.y), math.floor(player.x - camera.x), PLAYER_RADIUS)
		local angle = 0
		if player.angle then
			angle = -math.floor(player.angle*180/math.pi)
		end
		alex_c_api.draw_graphic("spider",
		                       math.floor(player.y - camera.y), math.floor(player.x - camera.x), PLAYER_WIDTH, PLAYER_HEIGHT, { angle_degrees = angle })
		if player.swinging_on ~= nil then
			--local y2 = player.y + 30 * math.sin(player.swing_angle + math.pi/2)
			--local x2 = player.x + 30 * math.cos(player.swing_angle + math.pi/2)
			local node = game_state.swing_spots[player.swinging_on]
			local y1 = player.y - WEB_OFFSET * math.cos(player.angle)
			local x1 = player.x - WEB_OFFSET * math.sin(player.angle)
			local y2 = node.y
			local x2 = node.x
			alex_c_api.draw_line('#dddddd', ROPE_THICKNESS, math.floor(y1 - camera.y), math.floor(x1 - camera.x), math.floor(y2 - camera.y), math.floor(x2 - camera.x))

			--[[
			local dy = player.y - node.y
			local dx = player.x - node.x
			local angle = math.atan(dy,dx) - math.pi/2
			local y3 = player.y + 30 * math.sin(angle)
			local x3 = player.x + 30 * math.cos(angle)
			alex_c_api.draw_line('#00ff00', 2, math.floor(player.y - camera.y), math.floor(player.x - camera.x), math.floor(y3 - camera.y), math.floor(x3 - camera.x))
			--]]
		end
		alex_c_api.draw_text(string.format("E: %5.0f", math.floor(core.get_energy(game_state, player_idx)/100)), '#ff0000', 24, 5, 24, 1)
		alex_c_api.draw_text(string.format("pos: %5.0f", math.floor(player.x/10)), '#ff0000', 24, 480-150, 24, 1)
	end

	for _, node in ipairs(game_state.swing_spots) do
		alex_c_api.draw_circle(SWING_SPOT_COLOUR.fill, SWING_SPOT_COLOUR.outline,
		                       math.floor(node.y - camera.y), math.floor(node.x - camera.x), SWING_SPOT_RADIUS)
	end

	if dt_ms ~= 0 then
		draw_celebration_anim.update(anim_state, dt_ms/1000.0)
	end
	draw_celebration_anim.draw(anim_state)
	alex_c_api.draw_refresh()
end

function draw.player_finished()
	draw_celebration_anim.fireworks_display(anim_state, {
		-- I didn't implement dark mode in this game, so 
		-- when showing the fireworks display, the dark background
		-- needs to be drawn so that the fireworks are more visible.
		colour_pref = "light",
	})
end

return draw
-- Game:   Spider Swing
-- Author: Alex Barry (github.com/alexbarry)
--
--[[
-- TODO:
--   * add different stages, including moving swing spots such as:
--	     - butterflies (moving eratically, perhaps? Or any direction)
--       - leaves (could just fall down, or blow up, or blow side to side steadily)
--]]

local core = require("games/spider_swing/spider_swing_core")
local draw = require("games/spider_swing/spider_swing_draw")

local alex_c_api = require("alex_c_api")

local state = {}
state.game = core.new_state()
local player_idx = 1

local player_won = false

local FPS = 60
local TIME_PER_FRAME_MS = 1000/FPS

local GAME_OPTION_NEW_GAME = "option_new_game"

function draw_board(dt_ms)
	if state.game.game_over then 
		state.game.game_over = false
		core.reset_player_state(state.game, player_idx)
		player_won = false
	end
	--print(string.format("Pos is now {y=%.1f, x=%.1f}", state.game.players[1].y, state.game.players[1].x))
	if not player_won then
		player_won = core.player_won(state.game, player_idx)
		if player_won then
			draw.player_finished()
		end
	end
	core.update_state(state.game, dt_ms)
	draw.draw_state(state.game, player_idx, dt_ms)
end

local function user_press(pos_y, pos_x)
	local pos = draw.get_mouse_pos_in_game(state.game, player_idx, pos_y, pos_x)
	local node_idx = core.get_closest_swing_spot(state.game, pos)
	core.player_attach_swing(state.game, player_idx, node_idx)
end

local function user_release()
	core.player_release_swing(state.game, player_idx)
end


function handle_mouse_evt(evt_id, pos_y, pos_x)
	-- print("handle_mouse_evt" .. evt_id)
	if evt_id == 2 then
		user_press(pos_y, pos_x)
	elseif evt_id == 1 then
		user_release()
	end
end

function handle_touch_evt(evt_id, changed_touches)
	-- print("handle_touch_evt: " .. evt_id)
	if evt_id == "touchstart" then
		user_press(changed_touches[1].y, changed_touches[1].x)
	elseif evt_id == "touchend" then
		user_release()
	end
end

function handle_game_option_evt(option_id)
	if option_id == GAME_OPTION_NEW_GAME then
		state.game = core.new_state()
		player_won = false
	end
end

-- Since this game is fast, it doesn't really make sense to share the state.
-- Well, it sort of does, since it's randomly generated, maybe you really want to
-- try again on a different device.
-- But since I didn't implement saving state yet, I didn't implement serialization,
-- so for now I am just going to return nil here to suppress the warning.
function get_state()
	return nil
end

function start_game()
	alex_c_api.set_timer_update_ms(TIME_PER_FRAME_MS)
	alex_c_api.enable_evt("mouse_updown")
	alex_c_api.enable_evt("touch")

	alex_c_api.add_game_option(GAME_OPTION_NEW_GAME, { label = "New game", type = alex_c_api.OPTION_TYPE_BTN })
end
local core = {}

local alex_c_api = require("alex_c_api")
local shuffle = require("libs/shuffle")

core.GAME_SIZE = 9
core.BOX_SIZE = math.floor(math.sqrt(core.GAME_SIZE))

if core.BOX_SIZE*core.BOX_SIZE ~= core.GAME_SIZE then
	error("Invalid box size: is not sqrt of game size")
end

local GROUP_TYPE_ROW = 1
local GROUP_TYPE_COL = 2
local GROUP_TYPE_BOX = 3

local GROUP_TYPES = {
	GROUP_TYPE_ROW,
	GROUP_TYPE_COL,
	GROUP_TYPE_BOX,
}

local function print_board(board)
	for y=1,core.GAME_SIZE do
		if y%3 == 1 then
			print('+---+---+---+')
		end
		local s = '|'
		for x=1,core.GAME_SIZE do
			if board[y][x].val ~= 0 then
				s = s .. string.format("%s", board[y][x].val)
			else
				s = s .. " "
			end
			if x%3 == 0 then
				s = s .. '|'
			end
		end
		print(s)
	end
end


local function pt_eq(pt1, pt2)
	return pt1.y == pt2.y and pt1.x == pt2.x
end


-- Return y,x coords where idx is value in each cell
--     x=1, 2, 3
--   y=1[1][2][3],
--     2[4][5][6],
--     3[7][8][9] ]
local function get_box_pt(idx)
	return { y = math.floor((idx-1)/core.BOX_SIZE)+1,
	         x = math.floor((idx-1)%core.BOX_SIZE)+1 }
end

assert(pt_eq(get_box_pt(1), {y=1,x=1}))
assert(pt_eq(get_box_pt(2), {y=1,x=2}))
assert(pt_eq(get_box_pt(3), {y=1,x=3}))
assert(pt_eq(get_box_pt(4), {y=2,x=1}))
assert(pt_eq(get_box_pt(5), {y=2,x=2}))
assert(pt_eq(get_box_pt(6), {y=2,x=3}))
assert(pt_eq(get_box_pt(7), {y=3,x=1}))
assert(pt_eq(get_box_pt(8), {y=3,x=2}))
assert(pt_eq(get_box_pt(9), {y=3,x=3}))

-- Returns first cell in each box, e.g.
-- y,x coords of each cell below, where box_idx is value in cell
--    x=1, 2, 3,  4, 5, 6,  7, 8, 9
--  y=1[1][ ][ ]|[2][ ][ ]|[3][ ][ ]
--    2[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--    3[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--     ---------+---------+---------
--    4[4][ ][ ]|[5][ ][ ]|[6][ ][ ]
--    5[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--    6[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--     ---------+---------+---------
--    7[7][ ][ ]|[8][ ][ ]|[9][ ][ ]
--    8[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--    9[ ][ ][ ]|[ ][ ][ ]|[ ][ ][ ]
--
local function get_box_start_pt(box_idx)
	local pt = get_box_pt(box_idx)
	pt.y = (pt.y-1) * core.BOX_SIZE + 1
	pt.x = (pt.x-1) * core.BOX_SIZE + 1
	return pt
end

assert(pt_eq(get_box_start_pt(1), {y=1, x=1}))
assert(pt_eq(get_box_start_pt(2), {y=1, x=4}))
assert(pt_eq(get_box_start_pt(3), {y=1, x=7}))
assert(pt_eq(get_box_start_pt(4), {y=4, x=1}))
assert(pt_eq(get_box_start_pt(5), {y=4, x=4}))
assert(pt_eq(get_box_start_pt(6), {y=4, x=7}))
assert(pt_eq(get_box_start_pt(7), {y=7, x=1}))
assert(pt_eq(get_box_start_pt(8), {y=7, x=4}))
assert(pt_eq(get_box_start_pt(9), {y=7, x=7}))

local function pt_ary_eq(pt_ary1, pt_ary2)
	if #pt_ary1 ~= #pt_ary2 then
		return false
	end

	for i, _ in ipairs(pt_ary1) do
		if not pt_eq(pt_ary1[i], pt_ary2[i]) then
			return false
		end
	end
	return true
end

local function pt_add(pt1, pt2)
	return { y = pt1.y + pt2.y,
	         x = pt1.x + pt2.x }
end

assert(pt_eq(get_box_start_pt(1), {y=1,x=1}))
assert(pt_eq(get_box_start_pt(2), {y=1,x=4}))
assert(pt_eq(get_box_start_pt(3), {y=1,x=7}))
assert(pt_eq(get_box_start_pt(4), {y=4,x=1}))
assert(pt_eq(get_box_start_pt(5), {y=4,x=4}))
assert(pt_eq(get_box_start_pt(6), {y=4,x=7}))
assert(pt_eq(get_box_start_pt(7), {y=7,x=1}))
assert(pt_eq(get_box_start_pt(8), {y=7,x=4}))
assert(pt_eq(get_box_start_pt(9), {y=7,x=7}))

local function cells_in_group(group_type, idx)
	local cells = {}
	if group_type == GROUP_TYPE_ROW then
		local y = idx
		for x=1,core.GAME_SIZE do
			table.insert(cells, { y = y, x = x })
		end
	elseif group_type == GROUP_TYPE_COL then
		local x = idx
		for y=1,core.GAME_SIZE do
			table.insert(cells, { y = y, x = x })
		end
	elseif group_type == GROUP_TYPE_BOX then
		local box_idx = idx
		for cell_idx=1,core.GAME_SIZE do
			local pt = pt_add(get_box_start_pt(box_idx), get_box_pt(cell_idx))
			pt = pt_add(pt, { y = -1, x = -1 })
			table.insert(cells, pt)
		end
	else
		error(string.format("unexpected group_type: %s", group_type))
	end
	return cells
end


assert(pt_ary_eq(cells_in_group(GROUP_TYPE_BOX, 1), {
	{ y = 1, x = 1},
	{ y = 1, x = 2},
	{ y = 1, x = 3},
	{ y = 2, x = 1},
	{ y = 2, x = 2},
	{ y = 2, x = 3},
	{ y = 3, x = 1},
	{ y = 3, x = 2},
	{ y = 3, x = 3},
}))

local function get_pt_group_idx(group_type, y, x)
	if group_type == GROUP_TYPE_ROW then
		return y
	elseif group_type == GROUP_TYPE_COL then
		return x
	elseif group_type == GROUP_TYPE_BOX then
		local box_idx = math.floor( (y-1)/core.BOX_SIZE)*core.BOX_SIZE + math.floor( (x-1)/core.BOX_SIZE) + 1
		return box_idx
	else
		error(string.format("unexpected group_type: %s", group_type))
	end
end


local function is_board_valid(state)
	for _, group_type in ipairs(GROUP_TYPES) do
		for group_idx=1,core.GAME_SIZE do
			local nums_seen = {}
			for _, pt in ipairs(cells_in_group(group_type, group_idx)) do
				local val = state.board[pt.y][pt.x].val
				if val ~= 0 then
					if nums_seen[val] then
						return false
					end
					nums_seen[val] = true
				end
			end
		end
	end
	return true
end

local debug = false

local function get_possible_values(board, y, x)
	local vals = {}
	for i=1,core.GAME_SIZE do
		vals[i] = true
	end

	if debug then print_board(board) end
	if debug then print(string.format('--- checking y=%d,x=%d', y, x)) end
	for _, group_type in ipairs(GROUP_TYPES) do
		local group_idx = get_pt_group_idx(group_type, y, x)
		for _, pt in ipairs(cells_in_group(group_type, group_idx)) do
			local val = board[pt.y][pt.x].val
			if val ~= 0 then
				if debug then print(string.format("found val %d in group_type=%d, group_idx=%d", val, group_type, group_idx)) end
				vals[val] = false
			end
		end
	end

	local val_list = {}
	for val, is_valid in ipairs(vals) do
		if is_valid then
			table.insert(val_list, val)
		end
	end
	return val_list
end

local function get_cell_with_min_possib_vals(board)
	local cell = nil
	local min_possib_vals = nil
	for y=1,core.GAME_SIZE do
		for x=1,core.GAME_SIZE do
			if board[y][x].val ~= 0 then
				goto next_cell
			end
			local possib_vals = get_possible_values(board, y, x)
			if min_possib_vals == nil or #possib_vals < min_possib_vals then
				min_possib_vals = #possib_vals
				cell = { y = y, x = x }
			end
			if min_possib_vals == 0 then
				return cell
			end
			::next_cell::
		end
	end
	return cell
end

local function copy_board(board)
	local new_board = {}
	for y, row in ipairs(board) do
		new_board[y] = {}
		for x, cell in ipairs(row) do
			new_board[y][x] = {}
			new_board[y][x].val = cell.val
		end
	end
	return new_board
end

local function is_board_complete(board)
	for y=1,core.GAME_SIZE do
		for x=1,core.GAME_SIZE do
			if board[y][x].val == 0 then
				return false
			end
		end
	end
	return true
end

local function get_num_possib_solutions(board, max_count)
	--print_board(board)
	board = copy_board(board)
	local solution_count = 0
	local cell, possib_vals
	while true do
		if is_board_complete(board) then
			return 1
		end

		cell = get_cell_with_min_possib_vals(board)
		if cell == nil then
			error("get_cell_with_min_possib_vals is nil?")
			return 0
		end

		possib_vals = get_possible_values(board, cell.y, cell.x)
		--print(string.format("found cell{y=%d,x=%d} has %d possib_vals", cell.y, cell.x, #possib_vals))
		if #possib_vals == 0 then
			if is_board_complete(board) then
				return 1
			else
				return 0
			end
		elseif #possib_vals == 1 then
			--print(string.format("filling in easy val %d to {y=%d,x=%d}", possib_vals[1], cell.y, cell.x))
			board[cell.y][cell.x].val = possib_vals[1]
		else
			break
		end
	end
	for _, possib_val in ipairs(possib_vals) do
		local board2 = copy_board(board)
		--print(string.format("guessing val=%d at {y=%d,x=%d}", possib_val, cell.y, cell.x))
		board2[cell.y][cell.x].val = possib_val
		if solution_count >= max_count then
			return solution_count
		end
		solution_count = solution_count + get_num_possib_solutions(board2, max_count)
	end
	return solution_count
end

local function solve_board(board)
	board = copy_board(board)
	while not is_board_complete(board) do
		local cell = get_cell_with_min_possib_vals(board)
		local possib_vals = get_possible_values(board, cell.y, cell.x)
		--print(string.format("found cell {y=%d,x=%d} has %d possib vals", cell.y, cell.x, #possib_vals))
		if #possib_vals == 0 then
			return board
		end

		if #possib_vals == 1 then
			--print(string.format("filling in val %d to {y=%d,x=%d}", possib_vals[1], cell.y, cell.x))
			board[cell.y][cell.x].val = possib_vals[1]
		else
			shuffle.shuffle(possib_vals)
			for _, possib_val in ipairs(possib_vals) do
				--print("making guess val=%d, y=%d,x=%d", possib_val, cell.y, cell.x)
				local board2 = copy_board(board)
				board2[cell.y][cell.x].val = possib_val
				board2 = solve_board(board2)
				if is_board_complete(board2) then
					return board2
				end
			end
			-- if we hit this, the board wasn't solvable
			return board
		end
	end
	return board
end

local function get_random_filled_in_cell(board)
	local cells = {}
	for y=1,core.GAME_SIZE do
		for x=1,core.GAME_SIZE do
			if board[y][x].val ~= 0 then
				table.insert(cells, { y=y, x=x} )
			end
		end
	end
	return cells[math.random(#cells)]
end

function core.new_game()
	local state = {
		board = {},
	}

	for y=1,core.GAME_SIZE do
		state.board[y] = {}
		for x=1,core.GAME_SIZE do
			state.board[y][x] = {}
			state.board[y][x].val = 0
		end
	end

	local start_time_ms = alex_c_api.get_time_ms()
	state.board = solve_board(state.board)
	local i = 0
	while i < 400 do
		i = i + 1
		local orig_board = copy_board(state.board)
		local cell = get_random_filled_in_cell(state.board)
		state.board[cell.y][cell.x].val = 0
		if get_num_possib_solutions(state.board, 2) > 1 then
			state.board = orig_board
			break
		elseif get_num_possib_solutions(state.board, 2) == 1 then
			-- pass
		else
			error("more than 1 solution?")
		end
	end
	for y=1,core.GAME_SIZE do
		for x=1,core.GAME_SIZE do
			state.board[y][x].is_init_val = (state.board[y][x].val ~= 0)
		end
	end
	::done_generating_game::
	local end_time_ms = alex_c_api.get_time_ms()


	alex_c_api.set_status_msg(string.format("Generated a game in %.3f seconds", (end_time_ms - start_time_ms)/1000))
	--local soln_count = get_num_possib_solutions(state.board, 5)
	--print("found " .. soln_count .. " possible solutions (max 5)")
	
	debug = true
	return state
end

function core.user_enter(state, y, x, num_choice)
	if state.board[y][x].is_init_val then
		return -- TODO error code?
	end

	state.board[y][x].val = num_choice
end

return core
local draw = {}

local cell_size = nil
local x_offset = nil
local num_choice_y_offset = nil
local num_choice_x_offset = nil

local OUTLINE_COLOUR = '#88888888'
local TEXT_COLOUR = '#000000'
local TEXT_SIZE   = 24
local TEXT_PADDING_Y = 5

local ORIG_CELL_COLOUR   = '#cccccc44'
local SELECTED_BG_COLOUR = '#0088cc33'

local CELL_LINE_THICKNESS = 1
local BOX_LINE_THICKNESS = 4

local core       = require("games/sudoku/sudoku_core")
local draw_shapes = require("libs/draw/draw_shapes")
local alex_c_api = require("alex_c_api")

local board_height = nil
local board_width  = nil

function draw.init(width, height)
	cell_size = math.floor(math.min(width,height)*1.0/(core.GAME_SIZE + 2.5))
	x_offset = math.floor((width - cell_size*core.GAME_SIZE)/2)
	board_height = height
	board_width  = width

	num_choice_y_offset = board_height - cell_size
	num_choice_x_offset = math.floor((board_width - (core.GAME_SIZE + 1)*cell_size)/2)
	return {
		selected = nil,
	}
end

local function draw_num_choices()
	local choices = { 'x' }
	for num=1,core.GAME_SIZE do
		table.insert(choices, string.format("%d", num))
	end
	for choice_idx, choice_val in ipairs(choices) do
		alex_c_api.draw_text(choice_val, TEXT_COLOUR,
		                     math.floor(num_choice_y_offset + TEXT_SIZE/2),
		                     num_choice_x_offset + math.floor((choice_idx-0.5)*cell_size),
		                     TEXT_SIZE, 0)
	end
end

function draw.draw_state(state, ui_state)
	alex_c_api.draw_clear()
	for y, row in ipairs(state.board) do
		for x, cell in ipairs(row) do
			draw_shapes.draw_rect_outline(OUTLINE_COLOUR, CELL_LINE_THICKNESS,
			                              (y-1)*cell_size, x_offset + (x-1)*cell_size,
			                              y*cell_size,     x_offset +  x*cell_size)
			local cell_bg = nil
			if cell.is_init_val then
				cell_bg = ORIG_CELL_COLOUR
			elseif ui_state.selected ~= nil and
			       ui_state.selected.y == y and
    			   ui_state.selected.x == x then
				cell_bg = SELECTED_BG_COLOUR
			end
			if cell_bg ~= nil then
				alex_c_api.draw_rect(cell_bg,
				                     (y-1)*cell_size, x_offset + (x-1)*cell_size,
				                     y*cell_size,     x_offset +  x*cell_size)
			end
			if cell.val ~= 0 then
				alex_c_api.draw_text(string.format("%d", cell.val), TEXT_COLOUR,
				                     math.floor((y-0.5)*cell_size + TEXT_SIZE/2),
				                     math.floor((x-0.5)*cell_size) + x_offset, 
				                     TEXT_SIZE, 0)
			end
		end
	end

	for y=1,core.BOX_SIZE-1 do
		alex_c_api.draw_line(OUTLINE_COLOUR, BOX_LINE_THICKNESS,
		                     y*core.BOX_SIZE*cell_size, x_offset + 0,
		                     y*core.BOX_SIZE*cell_size, x_offset + core.GAME_SIZE*cell_size)
	end
	for x=1,core.BOX_SIZE-1 do
		alex_c_api.draw_line(OUTLINE_COLOUR, BOX_LINE_THICKNESS,
		                     0,                        x_offset + x*core.BOX_SIZE*cell_size,
		                     core.GAME_SIZE*cell_size, x_offset + x*core.BOX_SIZE*cell_size)
	end

	if ui_state.selected ~= nil then
		draw_num_choices()
	end
	alex_c_api.draw_refresh()
end

function draw.get_cell_coords(pos_y, pos_x)
	local coords = {
		y = math.floor(pos_y/cell_size) + 1,
		x = math.floor((pos_x - x_offset)/cell_size) + 1,
	}

	if 1 <= coords.y and coords.y <= core.GAME_SIZE and
	   1 <= coords.x and coords.x <= core.GAME_SIZE then
		return coords
	else
		return nil
	end
end

function draw.get_num_choice(ui_state, pos_y, pos_x)
	if ui_state.selected == nil then
		return nil
	end
	if pos_y >= num_choice_y_offset then
		if num_choice_x_offset <= pos_x and pos_x <= num_choice_x_offset + (core.GAME_SIZE+1) * cell_size then
			local idx = math.floor((pos_x - num_choice_x_offset)/cell_size)
			return idx
		end
	end
end

function draw.handle_user_sel(ui_state, cell)
	if ui_state.selected ~= nil and
	   ui_state.selected.y == cell.y and
	   ui_state.selected.x == cell.x then
		ui_state.selected = nil
	else
		ui_state.selected = cell
	end
end

return draw

local core = require("games/sudoku/sudoku_core")
local draw = require("games/sudoku/sudoku_draw")

local ui_state = draw.init(480, 480)
local state = core.new_game()

function draw_board()
	draw.draw_state(state, ui_state)
end

function handle_user_clicked(pos_y, pos_x)
	local cell = draw.get_cell_coords(pos_y, pos_x)
	if cell ~= nil then
		print("user clicked: " .. cell.y .. ", " .. cell.x)
		draw.handle_user_sel(ui_state, cell)
	end


	local num_choice = draw.get_num_choice(ui_state, pos_y, pos_x)
	if num_choice ~= nil and ui_state.selected ~= nil then
		print("user chose ", num_choice)
		core.user_enter(state, ui_state.selected.y, ui_state.selected.x, num_choice)
	end

	draw_board()
	
end

function start_game()
end
local core = {}

local utils = require("libs/utils")

--local ENEMY_MOVE_SPEED  = 60
local ENEMY_MOVE_SPEED  = 120
local PLAYER_MOVE_SPEED = 150

local ENEMY_SPAWN_DIST_FROM_PLAYER = 400
local ENEMY_DIST_TO_PLAYER = 10

local MAX_BROCCOLI_OFFSET = 400
local BROC_DMG = 200
local BROCCOLI_MOVE_SPEED = 35

local HAMMER_RADIUS = 150
local HAMMER_ROT_SPEED = 1.0/2*(2*math.pi)

local HAMMER_SIZE = 20 

core.ATTACK_TYPE_BROCCOLI = 1
core.ATTACK_TYPE_FROG     = 2
core.ATTACK_TYPE_HAMMER   = 3

core.ENTITY_TYPE_PLAYER   = 1
core.ENTITY_TYPE_ENEMY    = 2


core.ATTACK_INFO = {
	[core.ATTACK_TYPE_BROCCOLI] = {
		size_y = 80,
		size_x = 80,
	},
	[core.ATTACK_TYPE_HAMMER] = {
		size_y = HAMMER_SIZE,
		size_x = HAMMER_SIZE,
	},
}

local function get_enemy_spawn_time(state)
end

local function squared(x)
	return x*x
end

local function abs(x)
	if x >= 0 then return x
	else return -x end
end

local ENTITY_MAP_STEP = 20

local function entity_map_round(val)
	return math.floor(val/ENTITY_MAP_STEP)*ENTITY_MAP_STEP
end

local function get_entity_map_pos(pos)
	if pos.y == nil or pos.x == nil then
		error(string.format("invalid pos{y=%s,x=%s}", pos.y, pos.x), 2)
	end
	return {
		y = entity_map_round(pos.y),
		x = entity_map_round(pos.x),
	}
end

local function get_entity_map_cell_or_create(entity_map, y, x)
	if entity_map[y] == nil then
		entity_map[y] = {}
	end

	if entity_map[y][x] == nil then
		entity_map[y][x] = {}
	end

	return entity_map[y][x]
end

local function add_to_entity_map(entity_map, item_type, item_state)
	local entity_map_pos = get_entity_map_pos(item_state)
	local new_cell = get_entity_map_cell_or_create(entity_map, entity_map_pos.y, entity_map_pos.x)

	table.insert(new_cell, {
		item_type = item_type,
		state = item_state,
	})
	--print(string.format("Added entity type=%s, state=%s to entity map at y=%d, x=%d",
	--	item_type, item_state, entity_map_pos.y, entity_map_pos.x))
		
end

local function print_entity_map(entity_map)
	for y, row in pairs(entity_map) do
		for x, entities in pairs(row) do
			if #entities > 0 then
				print(string.format("entity_map[y=%3d][x=%3d] has %d entities",
				      y, x, #entities))
			end
		end
	end
end

local function get_entity_map_cell(entity_map, y, x)
	if entity_map[y] == nil or
	   entity_map[y][x] == nil then
		error(string.format("y=%d,x=%d not found in entity_map", y, x), 2)
	end

	return entity_map[y][x]
end

local function update_attack_states(state, player_state, dt_ms)
	for _, attack_state in pairs(player_state.attack_states) do
		if attack_state.enabled then
			attack_state.update(state, player_state, attack_state, dt_ms)
		end
	end
end

local function area_contains_enemy(state, start_y, start_x, end_y, end_x)
	local found_enemies = {}
	for y=entity_map_round(start_y),entity_map_round(end_y),ENTITY_MAP_STEP do
		for x=entity_map_round(start_x),entity_map_round(end_x),ENTITY_MAP_STEP do
			for val_idx, val in ipairs(get_entity_map_cell_or_create(state.entity_map, y, x)) do
				if val.item_type == core.ENTITY_TYPE_ENEMY then
					table.insert(found_enemies, val.state)
				end
			end
		end
	end

	return { found = #found_enemies > 0, enemies = found_enemies }
end

local function remove_entity(state, entity)
	local pos = get_entity_map_pos(entity)
	local cell = get_entity_map_cell(state.entity_map, pos.y, pos.x)
	local entity_idx
	for idx, val in ipairs(cell) do
		if val.state == entity then
			entity_idx = idx
		end
	end

	if entity_idx == nil then
		error(string.format("Could not find entity %s in entity_map", entity))
	end

	table.remove(cell, entity_idx)
end

local function remove_enemy(state, enemy)
	remove_entity(state, enemy)
	local enemy_idx
	for val_idx, val in ipairs(state.enemies) do
		if val == enemy then
			enemy_idx = val_idx
		end
	end

	if enemy_idx == nil then
		error(string.format("Could not find enemy %s in state.enemies", enemy))
	end
	table.remove(state.enemies, enemy_idx)
	print(string.format("Removed enemy %s", enemy))
end

local function damage_enemy(state, enemy, dmg)
	enemy.health = enemy.health - dmg
	if enemy.health <= 0 then
		remove_enemy(state, enemy)
	end
end

function update_broccoli_state(state, player_state, attack_state, dt_ms)
	local spawn_dirs = {
		{ y_vel = 0, x_vel =  1 },
		{ y_vel = 0, x_vel = -1 },
		{ y_vel = 1, x_vel =  0 },
		{ y_vel =-1, x_vel =  0 },
	}
	attack_state.time_to_next_spawn_ms = attack_state.time_to_next_spawn_ms - dt_ms
	if attack_state.time_to_next_spawn_ms < 0 then
		attack_state.time_to_next_spawn_ms = attack_state.spawn_period_ms

		for i=1,attack_state.entities_per_spawn do
			print("spawning broccoli")
			local y_vel = spawn_dirs[attack_state.next_spawn_dir].y_vel * BROCCOLI_MOVE_SPEED * dt_ms/1000
			local x_vel = spawn_dirs[attack_state.next_spawn_dir].x_vel * BROCCOLI_MOVE_SPEED * dt_ms/1000
	
			attack_state.next_spawn_dir = (attack_state.next_spawn_dir % #spawn_dirs) + 1
			table.insert(attack_state.particles, {
				y_offset = 0,
				x_offset = 0,
				
				y_vel = y_vel,
				x_vel = x_vel,
			})
		end
	end

	local broc_idxes_to_remove = {}

	for particle_idx, particle in ipairs(attack_state.particles) do
		particle.y_offset = particle.y_offset + particle.y_vel * dt_ms
		particle.x_offset = particle.x_offset + particle.x_vel * dt_ms

	if abs(particle.y_offset) > MAX_BROCCOLI_OFFSET or
	   abs(particle.x_offset) > MAX_BROCCOLI_OFFSET then
		table.insert(broc_idxes_to_remove, particle_idx)
		end
	end

	local positions = core.get_broccoli_particle_positions(state, player_state, attack_state)
	local BROC_SIZE_Y = 80
	local BROC_SIZE_X = 80
	--print_entity_map(state.entity_map)
	for pos_idx, pos in ipairs(positions) do
		local info = area_contains_enemy(state,
		                                 pos.y - BROC_SIZE_Y/2, pos.x - BROC_SIZE_X/2,
		                                 pos.y + BROC_SIZE_Y/2, pos.x + BROC_SIZE_X/2)
		--[[
		print(string.format("area y in {%s, %s}, x in {%s, %s} contained enemies: %s",
			pos.y - BROC_SIZE_Y/2, pos.y + BROC_SIZE_Y/2,
			pos.x - BROC_SIZE_Y/2, pos.x + BROC_SIZE_Y/2,
			info.found))
		--]]
		if info.found then
			print("broccoli hit enemy!")
			for _, enemy in ipairs(info.enemies) do
				damage_enemy(state, enemy, BROC_DMG)
			end
			if attack_state.consumed_on_dmg then
				table.insert(broc_idxes_to_remove, pos_idx)
			end
		end
	end
	-- TODO handle removing more than one at a time
	if #broc_idxes_to_remove > 0 then
		table.remove(attack_state.particles, broc_idxes_to_remove[1])
	end
		
end

-- TODO make private
function core.get_broccoli_particle_positions(state, player_state, attack_state)
	local positions = {}
	for _, particle in ipairs(attack_state.particles) do
		table.insert(positions, {
			y = player_state.y + particle.y_offset,
			x = player_state.x + particle.x_offset,
		})
	end

	return positions
end

local function get_missing_hammer_idx(attack_state)
	for i=1,attack_state.max_particles do
		if attack_state.particles[i] == nil then
			return i 
		end
	end
	return nil
end

local function update_hammer_state(state, player_state, attack_state, dt_ms)
	print("update_hammer_state")
	attack_state.time_to_next_spawn_ms = attack_state.time_to_next_spawn_ms - dt_ms
	if attack_state.time_to_next_spawn_ms < 0 then
		while utils.table_len(attack_state.particles) < attack_state.max_particles do
				attack_state.time_to_next_spawn_ms = attack_state.spawn_period_ms
				local i = get_missing_hammer_idx(attack_state)
				attack_state.particles[i] = {
					hammer_radius = HAMMER_RADIUS + i*HAMMER_SIZE,
					angle = 0,
					idx   = i,
				}
		end
	end

	for _, particle in pairs(attack_state.particles) do
		particle.angle = particle.angle + HAMMER_ROT_SPEED*dt_ms/1000
	end

	local hammers_to_remove = {}

	local positions = core.get_hammer_particle_positions(state, player_state, attack_state)
	for hammer_idx, hammer in ipairs(positions) do
		local info = area_contains_enemy(state,
		                                 hammer.y - HAMMER_SIZE/2, hammer.x - HAMMER_SIZE/2,
		                                 hammer.y + HAMMER_SIZE/2, hammer.x + HAMMER_SIZE/2)
		if info.found then
			print(string.format("Hammer hit %d enemies", #info.enemies))
			for _, enemy in ipairs(info.enemies) do
				damage_enemy(state, enemy, 200)
			end
			if attack_state.hammers_consumable then
				table.insert(hammers_to_remove, hammer_idx)
			end
		end
	end

	for _, idx in ipairs(hammers_to_remove) do
		attack_state.particles[idx] = nil
	end

end

function core.get_hammer_particle_positions(state, player_state, attack_state)
	local positions = {}
	for _, particle in pairs(attack_state.particles) do
		table.insert(positions, {
			y = player_state.y + particle.hammer_radius * math.cos(particle.angle),
			x = player_state.x + particle.hammer_radius * math.sin(particle.angle),
		})
	end

	return positions
end



local function update_entity_map(entity_map, old_pos, item_state)
	--print_entity_map(entity_map)
	local old_entity_map_pos = get_entity_map_pos(old_pos)
	local new_entity_map_pos = get_entity_map_pos(item_state)
	--[[
	print(string.format("Moving entity from {y=%d,x=%d} to {y=%d,x=%d}",
		old_entity_map_pos.y,
		old_entity_map_pos.x,
		new_entity_map_pos.y,
		new_entity_map_pos.x))
	--]]

	if old_entity_map_pos.y == new_entity_map_pos.y and
	   old_entity_map_pos.x == new_entity_map_pos.x then
		return
	end

	local old_map_cell = get_entity_map_cell(entity_map, old_entity_map_pos.y, old_entity_map_pos.x)
	local old_map_idx
	local old_val
	for idx, val in ipairs(old_map_cell) do
		if val.state == item_state then
			old_map_idx = idx
			old_val = val
		end
	end

	if old_map_idx == nil then
		print(string.format("old_map_cell has len %d", #old_map_cell))
		for idx, val in ipairs(old_map_cell) do
			print(string.format("old_map_cell[%d] = %s", idx, val.state))
		end
		error(string.format("Could not find item %s in old entity_map cell", item_state))
	end

	local new_map_cell = get_entity_map_cell_or_create(entity_map, new_entity_map_pos.y, new_entity_map_pos.x)
	table.remove(old_map_cell, idx)
	table.insert(new_map_cell, old_val)
end

function core.new_state(num_players)
	local state = {
		entity_map = {},
		players = {},
		enemies = {},
		--enemies_to_spawn_per_period = 50,
		enemies_to_spawn_per_period = 1,
		enemy_spawn_time_ms         = 400,
		--enemy_spawn_time_ms         = 400,
		time_to_next_enemy_spawn_ms = 0,
	}

	for i=1,num_players do

		table.insert(state.players, {
			y = 0,
			x = 0,

			move_vec = {
				y = 0,
				x = 0,
			},

			level = 1,
			attack_states = {
				[core.ATTACK_TYPE_BROCCOLI] = {
					enabled = true,
					update = update_broccoli_state,
					get_positions = core.get_broccoli_particle_positions,
					consumed_on_dmg = false,
					level = 1,
					time_to_next_spawn_ms = 500,
					--entities_per_spawn = 1,
					entities_per_spawn = 4,
					spawn_period_ms = 1000,
					next_spawn_dir = 1,
					particles = {},
				},

				[core.ATTACK_TYPE_HAMMER] = {
					enabled = true,
					update = update_hammer_state,
					get_positions = core.get_hammer_particle_positions,
					max_particles = 3,
					level = 1,
					time_to_next_spawn_ms = 500,
					spawn_period_ms = 1000,
					next_spawn_dir = 1,
					hammers_consumable = false,
					particles = {},
				},

			},
		})
		add_to_entity_map(state.entity_map, core.ENTITY_TYPE_PLAYER, state.players[i])
	end

	return state
end

local function get_random_dist_from_player(player_state, dist_from_player)
	local angle = math.random()*2*math.pi
	local pos = {
		y = player_state.y + dist_from_player*math.cos(angle),
		x = player_state.x + dist_from_player*math.sin(angle),
	}
	return pos
end

local function spawn_enemy(state, pos)
	local enemy_state = {
		y      = pos.y,
		x      = pos.x,
		health = 10,
		move_speed = ENEMY_MOVE_SPEED,
	}
	table.insert(state.enemies, enemy_state)
	add_to_entity_map(state.entity_map, core.ENTITY_TYPE_ENEMY, enemy_state)
end

local function collides_with_new_pos(state, entity, tentative_pos)
	local old_entity_pos = get_entity_map_pos(entity)
	local new_entity_pos = get_entity_map_pos(tentative_pos)

	if old_entity_pos.y == new_entity_pos.y and
	   old_entity_pos.x == new_entity_pos.x then
		return false
	else
		return #get_entity_map_cell_or_create(state.entity_map, new_entity_pos.y, new_entity_pos.x) > 0
	end

	
end

local function move_enemies_toward_player(state, dt_ms)
	local player_state = state.players[1]
	for _, enemy in ipairs(state.enemies) do
		local dy = player_state.y - enemy.y
		local dx = player_state.x - enemy.x

		local angle = math.atan(dy, dx)
		local dist_squared = dy*dy + dx*dx

		local old_pos = {
			y = enemy.y,
			x = enemy.x,
		}

		if dist_squared > squared(ENEMY_DIST_TO_PLAYER) then
			local tentative_pos = {
				y = enemy.y + enemy.move_speed * math.sin(angle) * dt_ms/1000.0,
				x = enemy.x + enemy.move_speed * math.cos(angle) * dt_ms/1000.0,
			}

			local map_pos = get_entity_map_pos(tentative_pos)
			local map_cell = get_entity_map_cell_or_create(state.entity_map, map_pos.y, map_pos.x)
			if not collides_with_new_pos(state, enemy, tentative_pos) then
				enemy.y = tentative_pos.y
				enemy.x = tentative_pos.x
			else
				-- otherwise, collision. Do not move
			end
			--print(string.format("enemy is at pos y=%s, x=%s", enemy.y, enemy.x))
		end

		update_entity_map(state.entity_map, old_pos, enemy)
	end
end

function core.update_state(state, dt_ms)
	if state.time_to_next_enemy_spawn_ms < 0 then
		for i=1,state.enemies_to_spawn_per_period do
			local new_enemy_pos = get_random_dist_from_player(state.players[1], ENEMY_SPAWN_DIST_FROM_PLAYER)
			spawn_enemy(state, new_enemy_pos)
		end
		state.time_to_next_enemy_spawn_ms = state.enemy_spawn_time_ms
	end

	state.time_to_next_enemy_spawn_ms = state.time_to_next_enemy_spawn_ms - dt_ms

	for _, player_state in ipairs(state.players) do
		if player_state.move_vec.y ~= 0 or
		   player_state.move_vec.x ~= 0 then
			local dy = PLAYER_MOVE_SPEED * player_state.move_vec.y * dt_ms/1000.0
			local dx = PLAYER_MOVE_SPEED * player_state.move_vec.x * dt_ms/1000.0

			player_state.y = player_state.y + dy
			player_state.x = player_state.x + dx
		end
		update_attack_states(state, player_state, dt_ms)
	end

	move_enemies_toward_player(state, dt_ms)
end

function core.set_player_move_vec(state, player_idx, move_vec)
	state.players[player_idx].move_vec.y = move_vec.y
	state.players[player_idx].move_vec.x = move_vec.x
end

return core
local draw = {}

local core = require("games/swarm/swarm_core")
local touchpad = require("libs/ui/touchpad")
local alex_c_api = require("alex_c_api")

draw.ACTION_PLAYER_VEC_CHANGE = 1

local height = 480
local width  = 480

local padding = 5

local TOUCHPAD_RADIUS = 85
local TOUCHPAD_POS = {
	y = height - TOUCHPAD_RADIUS - padding,
	x = width  - TOUCHPAD_RADIUS - padding,
}

local BACKGROUND_COLOUR = '#0f7901'

local function get_attack_img(attack_type)
	local MAP = {
		[core.ATTACK_TYPE_BROCCOLI] = "swarm_broccoli",
		[core.ATTACK_TYPE_HAMMER]   = "swarm_hammer",
	}
	return MAP[attack_type]
end

local function get_screen_pos(state, game_pos)
	return {
		y = math.floor(height/2 - state.players[1].y + game_pos.y),
		x = math.floor(width/2  - state.players[1].x + game_pos.x),
	}
end

local function draw_bg(state, player_idx)
	--alex_c_api.draw_rect(BACKGROUND_COLOUR, 0, 0, height, width)

	for _, bg_y_idx in ipairs({0, 1}) do
		for _, bg_x_idx in ipairs({0, 1}) do
			local bg = get_screen_pos(state, {
				y = (math.floor(state.players[player_idx].y/height) + bg_y_idx)*height,
				x = (math.floor(state.players[player_idx].x/width) + bg_x_idx)*width,
			})
			alex_c_api.draw_graphic("swarm_grass_bg1", bg.y, bg.x, height, width)
		end
	end
end

local function draw_attacks_state(state, player_idx)
	local player_state = state.players[player_idx]
	for attack_type, attack_state in pairs(player_state.attack_states) do
		local img_id = get_attack_img(attack_type)
		local positions = attack_state.get_positions(state, player_state, attack_state)
		--local broccoli_positions = core.get_broccoli_particle_positions(state, state.players[player_idx], state.players[player_idx].attack_states[core.ATTACK_TYPE_BROCCOLI])
		for _, pos in ipairs(positions) do
			local screen_pos = get_screen_pos(state, pos)
			local attack_info = core.ATTACK_INFO[attack_type]
			alex_c_api.draw_graphic(img_id, screen_pos.y, screen_pos.x,
				attack_info.size_y, attack_info.size_x)
		end
	end

end

function draw.draw_state(state, ui_state, player_idx)
	alex_c_api.draw_clear()

	draw_bg(state, player_idx)

	alex_c_api.draw_text("player", '#000000', height/2, width/2, 12, 0)
	draw_attacks_state(state, player_idx)
	--alex_c_api.draw_graphic("swarm_broccoli", height/4, width/4, 80, 80)
	--alex_c_api.draw_graphic("swarm_hammer", height/4, width/4, 50, 50)

	for enemy_idx, enemy in ipairs(state.enemies) do
		local screen_pos = get_screen_pos(state, enemy)
		alex_c_api.draw_text(string.format("%d", enemy_idx), '#000000', screen_pos.y, screen_pos.x, 12, 0)
	end

	alex_c_api.draw_graphic('hospital_ui_dirpad',
	                        ui_state.touchpad.pos.y,
	                        ui_state.touchpad.pos.x,
	                        2*ui_state.touchpad.radius,
	                        2*ui_state.touchpad.radius)
	                        

end

function draw.handle_touch_evts(state, evt_id, touches)
	local actions = {}

	local new_player_vec = touchpad.handle_touch_evts(state.touchpad, evt_id, touches)
	if new_player_vec ~= nil then
		table.insert(actions, {
			action_type = draw.ACTION_PLAYER_VEC_CHANGE,
			new_player_vec = new_player_vec,
		})
	end

	return actions
end

function draw.init(height, width)
	local state = {
		touchpad = touchpad.new_state(TOUCHPAD_POS, TOUCHPAD_RADIUS),
	}
	return state
end

return draw
local keyboard_input = {}

local INV_SQRT2 = 1/math.sqrt(2)

function keyboard_input.new_key_state()
	local state = {
		keys_pressed = {},
	}
	return state
end

local function abs(x)
	if x >= 0 then return x
	else return -x end
end

local function sign(x)
	if x >= 0 then return 1
	else return -1 end
end

function keyboard_input.get_move_vec_from_key_evt(state, evt, code)
	if state.keys_pressed[code] == nil then
		state.keys_pressed[code] = false
	end

	state.keys_pressed[code] = (evt == "keydown")

	local keys_handled = {
		["ArrowLeft"]  = true,
		["ArrowRight"] = true,
		["ArrowUp"]    = true,
		["ArrowDown"]  = true,

		["ArrowH"]  = true,
		["ArrowJ"]  = true,
		["ArrowK"]  = true,
		["ArrowL"]  = true,
	}

	local left  = state.keys_pressed["ArrowLeft"]  or state.keys_pressed["KeyH"]
	local right = state.keys_pressed["ArrowRight"] or state.keys_pressed["KeyL"]
	local down  = state.keys_pressed["ArrowDown"]  or state.keys_pressed["KeyJ"]
	local up    = state.keys_pressed["ArrowUp"]    or state.keys_pressed["KeyK"]

	local move_vec_y = 0
	local move_vec_x = 0

	if left and right then
		-- pass
	elseif left then
		move_vec_x = -1
	elseif right then
		move_vec_x = 1
	end

	if up and down then
		-- pass
	elseif up then
		move_vec_y = -1
	elseif down then
		move_vec_y = 1
	end

	if abs(move_vec_y) > 0 and abs(move_vec_x) > 0 then
		move_vec_y = sign(move_vec_y)*INV_SQRT2
		move_vec_x = sign(move_vec_x)*INV_SQRT2
	end

	return {
		handled = keys_handled[code],
		vec = {
			y = move_vec_y,
			x = move_vec_x,
		},
	}
		
end

return keyboard_input
--[[
--
-- TODO better AoE damage:
--   hard to do much AoE damage when the attacks are consumed as soon as they hit the edge of a mob of enemies, especially the hammer.
--   should mark them as "remove in 300 ms" or something, so they get some time to do more damage.
--   maybe also only let them do a certain amount of damage
--
-- TODO:
--   * add touch dirpad, refactor into common library for use with other games like thrust and hospital/bound
--
--]]
local core = require("games/swarm/swarm_core")
local draw = require("games/swarm/swarm_draw")
local keyboard_input = require("games/swarm/swarm_keyboard_input")
local alex_c_api = require("alex_c_api")

local FPS = 60
--local FPS = 2
local MS_PER_FRAME = math.floor(1000/FPS)
local player_idx = 1

local is_paused = false

local height = 480
local width  = 480

local g_state = {
	ui = draw.init(height, width),
	game = core.new_state(1),
	key_state = keyboard_input.new_key_state(),
}

function draw_board()
	draw.draw_state(g_state.game, g_state.ui, player_idx)
	if not is_paused then
		core.update_state(g_state.game, MS_PER_FRAME)
	end
end

function handle_key_evt(evt, code)
	local handled = false
	if code == "KeyP" and evt == "keydown" then
		is_paused = not is_paused
		local pause_str
		if is_paused then
			pause_str = "paused"
		else
			pause_str = "unpaused"
		end
		alex_c_api.set_status_msg(string.format("Game %s. (Press \"P\" to toggle)", pause_str))
		handled = true
	end
	local info = keyboard_input.get_move_vec_from_key_evt(g_state.key_state, evt, code)
	handled = handled or info.handled
	core.set_player_move_vec(g_state.game, player_idx, info.vec)
	return handled
end

function handle_touch_evt(evt, touches)
	local actions = draw.handle_touch_evts(g_state.ui, evt, touches)
	for _, action in ipairs(actions) do
		if action.action_type == draw.ACTION_PLAYER_VEC_CHANGE then
			core.set_player_move_vec(g_state.game, player_idx, action.new_player_vec)
		end
	end
end

alex_c_api.set_timer_update_ms(MS_PER_FRAME)
alex_c_api.enable_evt("key")
alex_c_api.enable_evt("touch")

local cards      = require("libs/cards/cards") 
local cards_draw = require("libs/cards/cards_draw")
local draw_more  = require("libs/draw/draw_more")
local alex_c_api = require("alex_c_api")

local padding = 50
local card_height = 100
local card_width  =  70
--local card_height = 60
--local card_width  =  40
local card_font_size = 24

local BTN_ID_INC_ANGLE = "inc_angle"
local BTN_ID_DEC_ANGLE = "dec_angle"
local BTN_ID_TOGGLE_FACE_DN_UP = "toggle_face_dn_up"

local pos_y = 240
local pos_x = 240

local deck = cards.new_deck()
cards.shuffle(deck)

local angle_offset = 0
local cards_face_down = true

function draw_board()
	alex_c_api.set_status_msg(string.format("Drawing cards with angle offset = %d", angle_offset))
	alex_c_api.draw_clear()

	if not cards_face_down then
		cards_draw.draw_card(deck[1], pos_y + padding, pos_x,
			card_width, card_height,
			card_font_size, false, 0 + angle_offset)
		
		cards_draw.draw_card(deck[2], pos_y, pos_x - padding, 
			card_width, card_height,
			card_font_size, false, 90 + angle_offset)
		
		cards_draw.draw_card(deck[3], pos_y - padding, pos_x,
			card_width, card_height,
			card_font_size, false, 180 + angle_offset)
		
		cards_draw.draw_card(deck[4],  pos_y, pos_x + padding,
			card_width, card_height,
			card_font_size, false, 270 + angle_offset)
			alex_c_api.draw_refresh()
	else

		draw_more.draw_graphic_ul("card_facedown", 0, 0, card_width, card_height, { angle_degrees =   0 + angle_offset })
	
		draw_more.draw_graphic_ul("card_facedown", pos_y + padding, pos_x + padding, card_width, card_height, { angle_degrees =   0 + angle_offset })
		draw_more.draw_graphic_ul("card_facedown", pos_y + padding, pos_x - padding, card_width, card_height, { angle_degrees =  90 + angle_offset })
		draw_more.draw_graphic_ul("card_facedown", pos_y - padding, pos_x - padding, card_width, card_height, { angle_degrees = 180 + angle_offset })
		draw_more.draw_graphic_ul("card_facedown", pos_y - padding, pos_x + padding, card_width, card_height, { angle_degrees = 270 + angle_offset })
	
		alex_c_api.draw_circle('#ff0000', '#ff000055', pos_y + padding, pos_x + padding, 5)
		alex_c_api.draw_text('1', '#000000',           pos_y + padding, pos_x + padding, 12, 0)
		alex_c_api.draw_circle('#ff0000', '#ff000055', pos_y + padding, pos_x - padding, 5)
		alex_c_api.draw_text('2', '#000000',           pos_y + padding, pos_x - padding, 12, 0)
		alex_c_api.draw_circle('#ff0000', '#ff000055', pos_y - padding, pos_x - padding, 5)
		alex_c_api.draw_text('3', '#000000',           pos_y - padding, pos_x - padding, 12, 0)
		alex_c_api.draw_circle('#ff0000', '#ff000055', pos_y - padding, pos_x + padding, 5)
		alex_c_api.draw_text('4', '#000000',           pos_y - padding, pos_x + padding, 12, 0)
	end
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_INC_ANGLE then
		angle_offset = angle_offset + 15
	elseif btn_id == BTN_ID_DEC_ANGLE then
		angle_offset = angle_offset - 15
	elseif btn_id == BTN_ID_TOGGLE_FACE_DN_UP then
		cards_face_down = not cards_face_down
	end
	draw_board()
end

alex_c_api.create_btn(BTN_ID_INC_ANGLE, "Increment Angle", 1)
alex_c_api.create_btn(BTN_ID_DEC_ANGLE, "Decrement Angle", 1)
alex_c_api.create_btn(BTN_ID_TOGGLE_FACE_DN_UP, "Toggle face dn/up", 1)
local alex_c_api = require("alex_c_api")

local y = 200
local x = 100

local width = 75
local height = 75

local i = 0
local prop = 0

function draw_board()
	alex_c_api.draw_clear()

	if prop % 2 == 0 then
		flip_y_vals = { false, true }
		flip_x_vals = { false, true }
		
		local flip_y_used = nil
		local flip_x_used = nil
		
		local j = 0
		
		for _, flip_x in ipairs(flip_x_vals) do
			for _, flip_y in ipairs(flip_y_vals) do
				if j ~= i % 4 then
					goto next_iter
				end
			
				alex_c_api.draw_graphic('hospital_ventilator', y, x,
				                        width, height,
				                        { flip_y = flip_y, flip_x = flip_x })
				flip_y_used = flip_y
				flip_x_used = flip_x
				::next_iter::
				j = j + 1
			end
		
		end
	
		local text1 = string.format("flip_y: %s", flip_y_used)
		local text2 = string.format("flip_x: %s", flip_x_used)
		alex_c_api.draw_text(text1, '#000000', 300, 0, 12, alex_c_api.TEXT_ALIGN_LEFT)
		alex_c_api.draw_text(text2, '#000000', 330, 0, 12, alex_c_api.TEXT_ALIGN_LEFT)
	
	
	else 
		local angle_degrees = i * 15
		alex_c_api.draw_graphic('hospital_ventilator', y, x,
		                        width, height,
		                        { angle_degrees = angle_degrees })
	
		local text1 = string.format("angle: %s", angle_degrees)
		alex_c_api.draw_text(text1, '#000000', 300, 0, 12, alex_c_api.TEXT_ALIGN_LEFT)
	
	end
	alex_c_api.draw_circle('#ff0000', '#ff0000', y, x, 5)

	alex_c_api.draw_refresh()
end

local BTN_ID_NEXT_FRAME = "btn_next_frame"
local BTN_ID_NEXT_PROP  = "btn_next_prop"

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_NEXT_FRAME then
		i = i + 1
		draw_board()
	elseif btn_id == BTN_ID_NEXT_PROP then
		prop = prop + 1
		draw_board()
	else
		error(string.format("Unhandled btn id %s", btn_id))
	end
end

function start_game()
	alex_c_api.create_btn(BTN_ID_NEXT_FRAME, "Next Frame", 1)
	alex_c_api.create_btn(BTN_ID_NEXT_PROP,  "Next Property", 1)
end

local alex_c_api = require("alex_c_api")

local TEXT_SIZE = 12
local PADDING = 5
local TEXT_COLOUR = "#ff0000"

local BTN_ID_TIMER1_TOGGLE = "timer1_toggle"
local BTN_ID_TIMER2_TOGGLE = "timer2_toggle"

local TIMER1_PERIOD_MS = 1000
local TIMER2_PERIOD_MS = 1500

local timer1 = nil
local timer2 = nil

local program_start_time = 0

local total_updates = 0
local recent_updates = {}

local function internal_draw_board()
	alex_c_api.draw_clear()

	for i, info in ipairs(recent_updates) do
		local y = (TEXT_SIZE + PADDING) * (i)
		local msg = string.format("%3.3f: draw_board fired, dt_ms: %d", info.time_ms/1000, info.dt_ms)
		alex_c_api.draw_text(msg, TEXT_COLOUR, y, 0, TEXT_SIZE, alex_c_api.TEXT_ALIGN_LEFT)
	end

	alex_c_api.draw_text(string.format("Timer 1 (1 s) handle: %s", timer1), TEXT_COLOUR,
	                     400, 0, TEXT_SIZE, alex_c_api.TEXT_ALIGN_LEFT)
	alex_c_api.draw_text(string.format("Timer 2 (1.5 s) handle: %s", timer2), TEXT_COLOUR,
	                     400 + TEXT_SIZE + PADDING, 0, TEXT_SIZE, alex_c_api.TEXT_ALIGN_LEFT)
	alex_c_api.draw_refresh()
end

function draw_board(dt_ms)
	local time_ms = alex_c_api.get_time_ms() - program_start_time
	total_updates = total_updates + 1
	table.insert(recent_updates, { dt_ms = dt_ms, time_ms = time_ms })
	while #recent_updates > 15 do
		table.remove(recent_updates, 1)
	end

	internal_draw_board()
end

function handle_btn_clicked(btn_id)
	if btn_id == BTN_ID_TIMER1_TOGGLE then
		if timer1 == nil then
			timer1 = alex_c_api.set_timer_update_ms(TIMER1_PERIOD_MS)
		else
			alex_c_api.delete_timer(timer1)
			timer1 = nil
		end
	else
		if timer2 == nil then
			timer2 = alex_c_api.set_timer_update_ms(TIMER2_PERIOD_MS)
		else
			alex_c_api.delete_timer(timer2)
			timer2 = nil
		end
	end

	internal_draw_board()
end


function start_game()
	program_start_time = alex_c_api.get_time_ms()
	timer1 = alex_c_api.set_timer_update_ms(TIMER1_PERIOD_MS)
	timer2 = alex_c_api.set_timer_update_ms(TIMER2_PERIOD_MS)

	-- TODO remove
	--alex_c_api.delete_timer(timer1)
	--timer1 = nil

	alex_c_api.create_btn(BTN_ID_TIMER1_TOGGLE, "Toggle timer 1", 1)
	alex_c_api.create_btn(BTN_ID_TIMER2_TOGGLE, "Toggle timer 2", 1)
end
local core = {}

local NUM_STARS = 5*5*50
local NUM_WALLS = 50
local MIN_WALL_Y = 0
local MAX_WALL_Y = 480
local WALL_Y_SIZE = 170

local WALL_X_SPACE = 250
local WALL_X_WIDTH =   5

local THRUST_ACCEL = 900.0
local MAX_SPEED    = 750
local ANGLE_ROT_PER_SECOND = 360.0

local WALL_TOUCHING_DIST = 15

local RACE_TRACK_SCALING = 480
local race_track = {
	{ outer = { y =  0, x =  0 }, inner = { y =  2, x =  2 }, }, -- a ( 1, 2)
	{ outer = { y =  0, x =  5 }, inner = { y =  2, x =  5 }, }, -- b ( 3, 4)
	{ outer = { y =  0, x =  6 }, inner = { y =  2, x =  6 }, }, -- c ( 5, 6)
	{ outer = { y =  1, x =  9 }, inner = { y =  3, x =  7 }, }, -- d ( 7, 8)
	{ outer = { y =  4, x =  9 }, inner = { y =  4, x =  6 }, }, -- e ( 9,10)
	{ outer = { y =  6, x =  7 }, inner = { y =  6, x =  5 }, }, -- f (11,12)
	{ outer = { y =  9, x =  9 }, inner = { y =  9, x =  7 }, }, -- g
	{ outer = { y = 12, x =  9 }, inner = { y = 10, x =  7 }, }, -- h
	{ outer = { y = 12, x =  3 }, inner = { y = 10, x =  4 }, }, -- i
	{ outer = { y =  9, x =  0 }, inner = { y =  9, x =  2 }, }, -- j
	{ outer = { y =  7, x =  0 }, inner = { y =  7, x =  2 }, }, -- k
	{ outer = { y =  4, x =  2 }, inner = { y =  4, x =  4 }, }, -- l
	{ outer = { y =  2, x =  0 }, inner = { y =  2, x =  2 }, }, -- m
}
local race_track_finish = {
	pt1 = { y=0, x=2 },
	pt2 = { y=2, x=2 },
}

local race_track_checkpoints = {
	{ pt1 = {y= 6, x=7}, pt2 = {y= 6, x=5} },
	{ pt1 = {y=12, x=6}, pt2 = {y=10, x=6} },
	{ pt1 = {y= 7, x=0}, pt2 = {y= 7, x=2} },
}

local start_race_pt =  { y = 1, x = 3 }
local start_race_pt =  { y = 1, x = 3 }

local races = {
	{
		track       = race_track,
		finish      = race_track_finish,
		checkpoints = race_track_checkpoints,
		start       = start_race_pt,
	},

	{
		start       = { y = 1, x = 6 },
		checkpoints = {
			{ pt1 = { y = 4, x = 13 }, pt2 = { y = 4, x = 10 }, },
			{ pt1 = { y = 7.5, x = 5 }, pt2 = { y = 6.5, x = 5 }, },
			{ pt1 = { y = 4, x = -1 }, pt2 = { y = 4, x = 2 }, },
		},
		finish      = { pt1 = { y = 0, x = 4}, pt2 = { y = 2, x = 4 } },
		track       = {
			{ outer = { y = 0, x = 0 }, inner = { y = 2, x = 2 }, },
			{ outer = { y = 0, x =12 }, inner = { y = 2, x =10 }, },
			{ outer = { y = 4, x =13 }, inner = { y = 4, x =10 }, },

			{ outer = { y = 8, x =12 }, inner = { y = 6, x =10 }, },

			{ outer = { y = 7.50, x = 6 }, inner = { y = 6.50, x = 6 } },
			{ outer = { y = 7.50, x = 4 }, inner = { y = 6.50, x = 4 } },

			{ outer = { y = 8, x = 0 }, inner = { y = 6, x = 2 }, },
			{ outer = { y = 4, x =-1 }, inner = { y = 4, x = 2 }, },
		},
	},
}

local function sign(val)
	if val >= 0 then return 1
	else return -1 end
end

local function clip(min_val, val, max_val)
	if val < min_val then return min_val
	elseif val > max_val then return max_val
	else return val end
end


local function new_player_state(state)
	local player_state = {
		y = 0,
		x = 0,
		angle_degrees = 0,
		vel_y = 0,
		vel_x = 0,

		thrust_on = false,
		brake_on  = false,

		lap_time_ms = 0,
		lap_times = {},

		met_checkpoints = {},
	}
	for checkpoint_idx, _ in ipairs(state.checkpoints) do
		player_state.met_checkpoints[checkpoint_idx] = false
	end
	return player_state
end

local function squared(x)
	return x*x
end

local function wall_length(wall_info)
	return math.sqrt( squared(wall_info.y_end - wall_info.y_start) + squared(wall_info.x_end - wall_info.x_start))
end

function core.new_game_state(track_key)
	local state = {
		zoom = 0.2,
		stars = {},
		walls = {},
		players = {},
		checkpoints = {},
		track       = nil,
	}


	for i=1,NUM_STARS do
		table.insert(state.stars, {
			y = math.random() * 5*480,
			x = math.random() * 5*480,
		})
	end

	local race                   = races[track_key]
	state.track = race
	local race_track_finish      = race.finish
	local race_track_checkpoints = race.checkpoints
	local start_race_pt          = race.start
	local race_track             = race.track

	state.finish_line = {
		y_start = race_track_finish.pt1.y * RACE_TRACK_SCALING,
		y_end   = race_track_finish.pt2.y * RACE_TRACK_SCALING,
		x_start = race_track_finish.pt1.x * RACE_TRACK_SCALING,
		x_end   = race_track_finish.pt2.x * RACE_TRACK_SCALING,
	}

	for _, checkpoint_info in ipairs(race_track_checkpoints) do
		table.insert(state.checkpoints, {
			y_start = checkpoint_info.pt1.y * RACE_TRACK_SCALING,
			y_end   = checkpoint_info.pt2.y * RACE_TRACK_SCALING,
			x_start = checkpoint_info.pt1.x * RACE_TRACK_SCALING,
			x_end   = checkpoint_info.pt2.x * RACE_TRACK_SCALING,
		})
	end
	print('checkpoints count: ' .. #state.checkpoints)


	state.players[1] = new_player_state(state)
	state.players[1].y = start_race_pt.y * RACE_TRACK_SCALING
	state.players[1].x = start_race_pt.x * RACE_TRACK_SCALING
	state.players[1].angle_degrees = 90

	--[[
	for i=1,NUM_WALLS do
		y_start = math.floor(math.random()*(MAX_WALL_Y-MIN_WALL_Y-WALL_Y_SIZE) + MIN_WALL_Y)
		table.insert(state.walls, {
			y_start = y_start,
			y_end   = y_start + WALL_Y_SIZE,

			x_start = i*WALL_X_SPACE,
			x_end   = i*WALL_X_SPACE + WALL_X_WIDTH,
		})
	end
	--]]

	for race_pt_idx, race_pt in ipairs(race_track) do
		local pts1 = race_pt
		local pts2
		if race_pt_idx == #race_track then	
			pts2 = race_track[1]
		else
			pts2 = race_track[race_pt_idx + 1]
		end

		table.insert(state.walls, {
			y_start = pts1.outer.y * RACE_TRACK_SCALING,
			x_start = pts1.outer.x * RACE_TRACK_SCALING,

			y_end   = pts2.outer.y * RACE_TRACK_SCALING,
			x_end   = pts2.outer.x * RACE_TRACK_SCALING,
		})
		state.walls[#state.walls].len = wall_length(state.walls[#state.walls])

		table.insert(state.walls, {
			y_start = pts1.inner.y * RACE_TRACK_SCALING,
			x_start = pts1.inner.x * RACE_TRACK_SCALING,

			y_end   = pts2.inner.y * RACE_TRACK_SCALING,
			x_end   = pts2.inner.x * RACE_TRACK_SCALING,
		})
		state.walls[#state.walls].len = wall_length(state.walls[#state.walls])

	end

	

	return state
end

local function is_touching_line(wall_info, player_state, touching_dist)
	if wall_info.len == nil then
		wall_info.len = wall_length(wall_info)
	end

	local len_squared = wall_info.len * wall_info.len
	local t = ((player_state.x - wall_info.x_start) * (wall_info.x_end - wall_info.x_start) + 
	           (player_state.y - wall_info.y_start) * (wall_info.y_end - wall_info.y_start)) / len_squared
	          
	t = clip(0, t, 1)
	local projection = {
		y = wall_info.y_start + t * (wall_info.y_end - wall_info.y_start),
		x = wall_info.x_start + t * (wall_info.x_end - wall_info.x_start),
	}

	local dy = projection.y - player_state.y
	local dx = projection.x - player_state.x

	local dist_to_wall_squared = squared(dy) + squared(dx)

	if false and wall_idx == 1 then
		print(string.format("Dist to wall %d is %f", wall_idx, math.sqrt(dist_to_wall_squared)))
		print(string.format("{y_start=%s, y_end=%s, x_start=%s, x_end=%s}, player {y=%s, x=%s}",
		      wall_info.y_start, wall_info.y_end,
		      wall_info.x_start, wall_info.x_end,
		      player_state.y, player_state.x))
	end

	
	if dist_to_wall_squared <= squared(touching_dist) then
		print(string.format("Dist to wall %s is %f", wall_idx, math.sqrt(dist_to_wall_squared)))
		print(string.format("{y_start=%s, y_end=%s, x_start=%s, x_end=%s}, player {y=%s, x=%s}",
		      wall_info.y_start, wall_info.y_end,
		      wall_info.x_start, wall_info.x_end,
		      player_state.y, player_state.x))
		return true
	end

end

local function is_touching_any_wall(state, player_state, touching_dist)
	for wall_idx, wall_info in ipairs(state.walls) do
		-- Oops, this is only for infinite length lines
		--[[
		local dist_to_wall = math.abs( (wall_info.x_end - wall_info.x_start)*(wall_info.y_start - player_state.y) -
		                       (wall_info.x_start - player_state.x)*(wall_info.y_end - wall_info.y_start)
		                     ) / wall_info.len
		--]]
		if is_touching_line(wall_info, player_state, touching_dist) then
			return true
		end

	end

	return false
end

function core.met_all_checkpoints(player_state)
	for _, met in pairs(player_state.met_checkpoints) do
		if not met then return false end
	end
	return true
end

function core.update_state(state, dt)
	local player_state = state.players[1]
	local angle_diff = 0
	if player_state.rot_left and player_state.rot_right then
	elseif player_state.rot_left then
		angle_diff = -ANGLE_ROT_PER_SECOND * dt
	elseif player_state.rot_right then
		angle_diff = ANGLE_ROT_PER_SECOND * dt
	end

	player_state.angle_degrees = player_state.angle_degrees + angle_diff

	if player_state.brake_on then
		player_state.vel_y = player_state.vel_y / 2
		if player_state.vel_y < 1 then
			player_state.vel_y = 0
		end

		player_state.vel_x = player_state.vel_x / 2
		if player_state.vel_x < 1 then
			player_state.vel_x = 0
		end
	elseif player_state.thrust_on then
		player_state.vel_y = player_state.vel_y + THRUST_ACCEL * dt * -math.cos(player_state.angle_degrees/180*math.pi)
		player_state.vel_x = player_state.vel_x + THRUST_ACCEL * dt * math.sin(player_state.angle_degrees/180*math.pi)
	end

	player_state.vel_y = clip(-MAX_SPEED, player_state.vel_y, MAX_SPEED)
	player_state.vel_x = clip(-MAX_SPEED, player_state.vel_x, MAX_SPEED)
	

	if player_state.vel_y ~= 0 then
		player_state.y = math.floor(player_state.y + player_state.vel_y * dt + 0.5)
	end
	if player_state.vel_x ~= 0 then
		player_state.x = math.floor(player_state.x + player_state.vel_x * dt + 0.5)
	end

	player_state.lap_time_ms = player_state.lap_time_ms + math.floor(1000*dt)

	if is_touching_any_wall(state, player_state, WALL_TOUCHING_DIST) then
		print("Touching wall!")
		player_state.vel_y = 0
		player_state.vel_x = 0
		player_state.y = state.track.start.y * RACE_TRACK_SCALING
		player_state.x = state.track.start.x * RACE_TRACK_SCALING
		player_state.angle_degrees = 90
		player_state.lap_time_ms = 0
		player_state.met_checkpoints = {}
		for checkpoint_idx, _ in ipairs(state.checkpoints) do
			player_state.met_checkpoints[checkpoint_idx] = false
		end
	else
		for checkpoint_idx, checkpoint_info in ipairs(state.checkpoints) do
			if is_touching_line(checkpoint_info, player_state, WALL_TOUCHING_DIST) then
				player_state.met_checkpoints[checkpoint_idx] = true
	
			end
		end
		if core.met_all_checkpoints(player_state) and
		   is_touching_line(state.finish_line, player_state, WALL_TOUCHING_DIST) then
			table.insert(player_state.lap_times, player_state.lap_time_ms)
			player_state.lap_time_ms = 0
			for checkpoint_idx, _ in ipairs(state.checkpoints) do
				player_state.met_checkpoints[checkpoint_idx] = false
			end
		end
	end

	local str = ''
	for _, met in pairs(player_state.met_checkpoints) do
		local val
		if met then val = '1' else val = '0' end
		str = str .. val .. ' '
	end
	--print('checkpoints: ' .. str .. string.format("%s", core.met_all_checkpoints(player_state)))

	-- print(string.format("update_state{y=%s, x=%s, angle=%s, vel_y=%s, vel_x=%s}",
	--                    state.y, state.x, state.angle_degrees, state.vel_y, state.vel_x))
end



return core

local draw = {}
local alex_c_api = require("alex_c_api")
local touchpad   = require("libs/ui/touchpad")
local core = require("games/thrust/thrust_core")

draw.ACTION_PLAYER_VEC_CHANGED = 1



local BG_COLOUR = '#000000'
local THRUST_COLOUR = '#ff8800'
local THRUST_COLOUR_OUTLINE = '#ffff00'
local STAR_COLOUR = '#ffffff'
local WALL_COLOUR = '#ff0000'
local height = 480
local width  = 480

local WALL_THICKNESS = 5
local CHECKPOINT_WALL_COLOUR_UNMET = '#00ff0077'
local CHECKPOINT_WALL_COLOUR_MET   = '#00880077'
local CHECKPOINT_THICKNESS_MET     = 1
local CHECKPOINT_THICKNESS_UNMET   = 2

local TEXT_COLOUR  = '#aaaaaa'
local TEXT_SIZE    = 24
local TEXT_PADDING = 3

local padding = 5
local TOUCHPAD_RADIUS = 85
local TOUCHPAD_POS = {
	y = height - TOUCHPAD_RADIUS - padding,
	x = width  - TOUCHPAD_RADIUS - padding,
}

local SHIP1 = "ship1"

local ship_graphics = {
	[SHIP1] = { img_id = "space_ship1", height = 150, width = 150 },
}

local function game_pt_to_screen_pt(state, player_state, pt)
	return {
		y = math.floor(state.zoom * (pt.y - player_state.y) + height/2),
		x = math.floor(state.zoom * (pt.x - player_state.x) + width/2),
	}
end

local function draw_walls(state, player_state)
	for _, wall_info in ipairs(state.walls) do
		--[[
		alex_c_api.draw_rect(WALL_COLOUR,
		                     wall_info.y_start - state.y, wall_info.x_start - state.x,
		                     wall_info.y_end   - state.y, wall_info.x_end   - state.x)
		--]]
		local pt1 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_start, x = wall_info.x_start})
		local pt2 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_end,   x = wall_info.x_end})
		alex_c_api.draw_line(WALL_COLOUR, WALL_THICKNESS,
		                     pt1.y, pt1.x,
		                     pt2.y, pt2.x)
		                     
	end

	for checkpoint_idx, wall_info in ipairs(state.checkpoints) do
		local pt1 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_start, x = wall_info.x_start})
		local pt2 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_end,   x = wall_info.x_end})
		local colour
		local thickness
		if player_state.met_checkpoints[checkpoint_idx] then
			colour = CHECKPOINT_WALL_COLOUR_MET
			thickness = CHECKPOINT_THICKNESS_MET
		else
			colour = CHECKPOINT_WALL_COLOUR_UNMET
			thickness = CHECKPOINT_THICKNESS_UNMET
		end
		alex_c_api.draw_line(colour, thickness,
		                     pt1.y, pt1.x,
		                     pt2.y, pt2.x)
	end

	local wall_info = state.finish_line
	local pt1 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_start, x = wall_info.x_start})
	local pt2 = game_pt_to_screen_pt(state, player_state, { y = wall_info.y_end,   x = wall_info.x_end})
	if not core.met_all_checkpoints(player_state) then
		colour = CHECKPOINT_WALL_COLOUR_MET
		thickness = CHECKPOINT_THICKNESS_MET
	else
		colour = CHECKPOINT_WALL_COLOUR_UNMET
		thickness = CHECKPOINT_THICKNESS_UNMET
	end
	alex_c_api.draw_line(colour, thickness,
	                     pt1.y, pt1.x,
	                     pt2.y, pt2.x)

end

local function draw_ship(ship_type, state, player_state)
	--print(string.format("ship_type=%s, y=%s, x=%s, angle=%s", ship_type, y, x, angle))
	local ship_img_info = ship_graphics[ship_type]

	local thrust_offset = 20
	local thrust_len    = 20
	local thrust_width  =  5
	local thrust_angle = player_state.angle_degrees/180*math.pi

	local thrust_radius = 10

	local y_pos = height/2
	local x_pos = width/2



	if player_state.thrust_on then
	alex_c_api.draw_circle(THRUST_COLOUR,
	                       THRUST_COLOUR_OUTLINE,
	                       math.floor(y_pos + thrust_offset*math.cos(thrust_angle)),
	                       math.floor(x_pos - thrust_offset*math.sin(thrust_angle)),
	                       math.floor(state.zoom*thrust_radius))
	--[[
	local thrust_angle = player_state.angle_degrees/180*math.pi
	alex_c_api.draw_rect(THRUST_COLOUR,
		math.floor(player_state.y + thrust_offset*math.cos(thrust_angle)),
		math.floor(player_state.x - thrust_width*math.sin(thrust_angle)),
		math.floor(player_state.y + (thrust_offset+thrust_len)*math.cos(thrust_angle)),
		math.floor(player_state.x + thrust_width*math.sin(thrust_angle)))
	--]]
	end

	alex_c_api.draw_graphic(ship_img_info.img_id,
	                        math.floor(y_pos),
	                        math.floor(x_pos),
	                        math.floor(state.zoom*ship_img_info.height),
	                        math.floor(state.zoom*ship_img_info.width), {
	                        	-- anchor_centre = true, -- TODO this should be the default, I think...
	                        	angle_degrees = math.floor(player_state.angle_degrees),
	                        })
	--[[
	alex_c_api.draw_rect('#ffffff', y - ship_img_info.height/2,
	                     x - ship_img_info.width/2,
	                     y - ship_img_info.height/2 + ship_img_info.height,
	                     x - ship_img_info.width/2 + ship_img_info.width)
	--]]
	                     
end

local function draw_stars_bg(state, player_state, star_move_fact)
	star_move_fact = star_move_fact / state.zoom
	for _, star in ipairs(state.stars) do
		alex_c_api.draw_circle(STAR_COLOUR, STAR_COLOUR,
		                       math.floor(star.y - player_state.y/star_move_fact), math.floor(star.x - player_state.x/star_move_fact),
		                       1)
	end
end

local function format_time(time_ms)
	local milliseconds = (time_ms % 1000)
	local seconds = math.floor(time_ms/1000)
	local minutes = math.floor(seconds/60)
	seconds = seconds % 60

	return string.format("%2d:%02d.%03d", minutes, seconds, milliseconds)
end

function draw.init()
	return {
		touchpad = touchpad.new_state(TOUCHPAD_POS, TOUCHPAD_RADIUS),
	}
end

function draw.draw_state(state, ui_state)
	alex_c_api.draw_clear()
	alex_c_api.draw_rect(BG_COLOUR, 0, 0, height, width)
	draw_stars_bg(state, state.players[1], 3)
	draw_walls(state, state.players[1])
	draw_ship(SHIP1, state, state.players[1])

	alex_c_api.draw_text(format_time(state.players[1].lap_time_ms), TEXT_COLOUR,
	                     TEXT_SIZE + TEXT_PADDING, TEXT_PADDING, TEXT_SIZE, 1)

	for lap_idx, lap_time in ipairs(state.players[1].lap_times) do
		local text = string.format('%d:%s', lap_idx, format_time(lap_time))
		alex_c_api.draw_text(text, TEXT_COLOUR,
		                     lap_idx*(TEXT_SIZE + TEXT_PADDING),
		                     width - TEXT_PADDING,
		                     TEXT_SIZE, -1)
	end

	alex_c_api.draw_graphic("hospital_ui_dirpad",
	                        ui_state.touchpad.pos.y,
	                        ui_state.touchpad.pos.x,
	                        2*ui_state.touchpad.radius,
	                        2*ui_state.touchpad.radius)

	alex_c_api.draw_refresh()
end

function draw.handle_touch_evts(ui_state, evt_id, touches)
	local actions = {}

	local player_vec = touchpad.handle_touch_evts(ui_state.touchpad, evt_id, touches)
	if player_vec ~= nil then
		table.insert(actions, {
			action = draw.ACTION_PLAYER_VEC_CHANGED,
			player_vec = player_vec,
		})
	end
		
	return actions
end

return draw
local input = {}

local need_to_rotate_enabled = true

function input.new_input_state() 
	return {
		rot_left  = false,
		rot_right = false,

		thrust_left  = false,
		thrust_right = false,
		thrust_up    = false,
		thrust_down  = false,
	}
end

function input.handle_key_evt(input_state, player_state, evt_id, code)
	--print(string.format("handle_key_evt, code=%s, evt=%s", code, evt_id))
	if need_to_rotate_enabled then
		if code == "ArrowLeft" then
			player_state.rot_left = (evt_id == "keydown")
		elseif code == "ArrowRight" then
			player_state.rot_right = (evt_id == "keydown")
		elseif code == "ArrowUp" then
			player_state.thrust_on = (evt_id == "keydown")
		elseif code == "ArrowDown" then
			player_state.brake_on = (evt_id == "keydown")
		else
			return false
		end
		return true
	else
		if code == "ArrowLeft" then
			input_state.thrust_left = (evt_id == "keydown")
		elseif code == "ArrowRight" then
			input_state.thrust_right = (evt_id == "keydown")
		elseif code == "ArrowUp" then
			input_state.thrust_up = (evt_id == "keydown")
		elseif code == "ArrowDown" then
			input_state.thrust_down = (evt_id == "keydown")
		else
			return false
		end

		local thrust_vec_y = 0
		local thrust_vec_x = 0

		if input_state.thrust_left and input_state.thrust_right then
			-- pass
		elseif input_state.thrust_left then
			thrust_vec_x =  1
		elseif input_state.thrust_right then
			thrust_vec_x = -1
		end

		if input_state.thrust_up and input_state.thrust_down then
			-- pass
		elseif input_state.thrust_up then
			thrust_vec_y = 1
		elseif input_state.thrust_down then
			thrust_vec_y = -1
		end

		if thrust_vec_y ~= 0 or thrust_vec_x ~= 0 then
			player_state.angle_degrees = math.atan(thrust_vec_y, thrust_vec_x) * 180 / math.pi - 90
			player_state.thrust_on = true
		else
			player_state.thrust_on = false
		end
		return true
	end
end

return input
--[[

TODO:
* add a button to do a speed boost, or to increase the "max allowed speed"
* implement touch support with a joystick like the hospital game
* maybe implement mouse support?

* bug with checkpoints: I've missed a few sometimes. Need to draw them as lines on the screen,
  higlight the next one, and make it change colour once passed through

--]]
local core = require("games/thrust/thrust_core")
local draw = require("games/thrust/thrust_draw")
local key_input = require("games/thrust/thrust_keyboard_input")

local alex_c_api = require("alex_c_api")


--local FPS = 60
local FPS = 50
local TIME_PER_FRAME_MS = math.floor(1000/FPS)

local g_state = {
	ui       = draw.init(),
	game     = core.new_game_state(1),
	keyboard = key_input.new_input_state(),
}


function draw_board(dt_ms)
	--core.update_state(g_state.game, TIME_PER_FRAME_MS/1000.0)
	core.update_state(g_state.game, dt_ms/1000.0)
	draw.draw_state(g_state.game, g_state.ui)
end

function handle_mousemove(y_pos, x_pos)
	--g_state.angle_degrees = math.floor(math.atan(480/2 - y_pos, 480/2 - x_pos)*180/3.14159 - 90)
	--print("handle_mousemove:", y_pos, x_pos, g_state.angle_degrees)
	--draw.draw_state(g_state.ui, g_state)
end


function handle_key_evt(evt_id, code)
	local player_state = g_state.game.players[1]
	local handled = key_input.handle_key_evt(g_state.keyboard, player_state, evt_id, code)
	if handled then
		draw.draw_state(g_state.game, g_state.ui)
	end
	return handled
end

function handle_touch_evt(evt_id, touches)
	local player_state = g_state.game.players[1]

	local actions = draw.handle_touch_evts(g_state.ui, evt_id, touches)

	for _, action in ipairs(actions) do
		if action.action == draw.ACTION_PLAYER_VEC_CHANGED then
			local vec = action.player_vec
			player_state.angle_degrees = math.atan(-vec.y, -vec.x) * 180 / math.pi - 90
			player_state.thrust_on = (vec.y ~= 0 and vec.x ~= 0)
		end
	end
end

-- In this game, it doesn't really make sense to save the state.
-- Well, ideally I'd implement some way to share your best times... maybe in
-- a future update.
function get_state()
	return nil
end

function start_game()
	alex_c_api.enable_evt("mouse_move")
	alex_c_api.enable_evt("key")
	alex_c_api.enable_evt("touch")
	alex_c_api.set_timer_update_ms(TIME_PER_FRAME_MS)
end

local alex_c_api = require("alex_c_api")

local touch_count = 0
local touches = {}

local colours = {
	'#ff0000',
	'#0000ff',
	'#00ff00',
	'#00ffff',
	'#ffff00',
	'#ff00ff',
	'#000000',
}

local board_height = 480
local board_width  = 480

local touch_line_width = 2
local circle_radius = 20

local text_size = 12
local padding = 5

local last_touch_str = nil

function draw_board()
	alex_c_api.draw_clear()

	if touch_count == 0 then
		local text_size = 18
		local line1 = 'Touch (and optionally drag) the screen'
		local line2 = 'to see info about touches'
		alex_c_api.draw_text(line1,
		                     text_colour,
		                     board_height/2 - text_size - padding/2, board_width/2,
		                     text_size, 0)
		alex_c_api.draw_text(line2,
		                     text_colour,
		                     board_height/2 + text_size + padding/2, board_width/2,
		                     text_size, 0)
	end
	local touch_idx = 1
	for i, touch in pairs(touches) do

		local text = string.format('%2d: id=%d [%3d] ', touch_idx, i, #touch)
		for _, pos in ipairs(touch) do
			text = text .. string.format('{y=%d,x=%d}, ', pos.y, pos.x)
		end
		alex_c_api.draw_text(text, '#000000', touch_idx*(text_size+padding), padding, text_size, 1)
		last_touch_str = text

		local colour = colours[ (i-1) % #colours + 1]
		print('draw: ', touch[1].y, touch[1].x)
		alex_c_api.draw_circle(colour, colour, touch[1].y, touch[1].x, circle_radius)
		for i=2,#touch do
			local pt1 = touch[i-1]
			local pt2 = touch[i]
			alex_c_api.draw_line(colour, touch_line_width, pt1.y, pt1.x, pt2.y, pt2.x)
		end
		touch_idx = touch_idx + 1
	end

	if last_touch_str ~= nil then
		alex_c_api.draw_text('last: ' .. last_touch_str, '#000000', board_height - text_size - padding, padding, text_size, 1)
	end
end

function handle_touch_evt(evt_id, changed_touches)
	for _, touch in ipairs(changed_touches) do
		if evt_id == 'touchstart' then
			touch_count = touch_count + 1
			touches[touch.id] = {}
		end
		if evt_id == 'touchstart' or
		   evt_id == 'touchmove' then
			print(evt_id, touch.y, touch.x)
			table.insert(touches[touch.id], { y = math.floor(touch.y), x = math.floor(touch.x) })
		end

		if evt_id == 'touchend' or
		   evt_id == 'touchcancel' then
			touch_count = touch_count - 1
			touches[touch.id] = nil
		end
	end
	draw_board()
end

alex_c_api.enable_evt('touch')
local core = {}

local words_lib = require("libs/words")

local LANGUAGE = "en" -- TODO get from state

core.LETTER_UNUSED          = 1
core.LETTER_PRESENT_IN_WORD = 2
core.LETTER_PRESENT_IN_POS  = 3
core.LETTER_UNKNOWN         = 4

core.RC_SUCCESS         =  0
core.RC_WRONG_GUESS_LEN = -1
core.RC_NOT_VALID_WORD  = -2

VALID_GUESS_FREQ       = 1e-8
VALID_SECRET_WORD_FREQ = 1e-6

local ERR_MSGS = {
	[core.RC_WRONG_GUESS_LEN] = "Guess not correct length",
	[core.RC_NOT_VALID_WORD]  = "Guess is not in dictionary",
}

function core.dict_ready()
	return words_lib.is_ready()
end

function core.rc_to_str(rc)
	return ERR_MSGS[rc]
end

local function get_random_word(len)
	return words_lib.get_random_word(LANGUAGE, VALID_SECRET_WORD_FREQ, len)
end

local function get_possib_word_count(len)
	return words_lib.get_possib_word_count(LANGUAGE, VALID_SECRET_WORD_FREQ, len)
end


local function is_valid_word(word)
	return words_lib.is_valid_word(LANGUAGE, word)
end

function core.init_lib()
	words_lib.init(LANGUAGE)
end

function core.new_game(word_len, max_guesses, word)
	local state = {
		word_len       = word_len,
		max_guesses    = max_guesses,
		possible_words = nil,
		word           = nil,
		guesses        = {},
		letter_states  = {},
		game_over      = false,
	}
	if word == nil then
		--print(string.format("Got random word: %q", state.word))
		state.word = get_random_word(word_len)
	else
		word = string.lower(word)
		state.word = word
	end
	state.possible_words = get_possib_word_count(word_len)

	print(string.format("There are %d possible words of length %d in this dictionary",
	                    state.possible_words, word_len))

	return state
end

local function get_word_letter_scores(answer, guess)
	local word_len = #answer
	if #guess ~= word_len then
		error("answer and guess must have some number of letters", 2)
	end
	local letter_scores = {}
	for _=1,word_len do
		table.insert(letter_scores, core.LETTER_UNUSED)
	end

	local answer_letter_counts = {}
	for i=1,word_len do
		if answer:sub(i,i) == guess:sub(i,i) then
			letter_scores[i] = core.LETTER_PRESENT_IN_POS
		else
			if answer_letter_counts[answer:sub(i,i)] == nil then
				answer_letter_counts[answer:sub(i,i)] = 0
			end
			answer_letter_counts[answer:sub(i,i)] = answer_letter_counts[answer:sub(i,i)] + 1
		end
	end

	for i=1,word_len do
		if answer:sub(i,i) ~= guess:sub(i,i) then
			local count = answer_letter_counts[guess:sub(i,i)]
			if count ~= nil and count > 0 then
				letter_scores[i] = core.LETTER_PRESENT_IN_WORD
				answer_letter_counts[guess:sub(i,i)] = answer_letter_counts[guess:sub(i,i)] - 1
			end
		end
	end

	return letter_scores
end


local function update_letter_states(state, guess, letter_scores)
	local word_len = #guess
	for i=1,word_len do
		local c = guess:sub(i,i)
		local c_score = letter_scores[i]
		if state.letter_states[c] == core.LETTER_PRESENT_IN_POS then
			goto next_letter
		end

		if c_score == core.LETTER_PRESENT_IN_POS then
			state.letter_states[c] = core.LETTER_PRESENT_IN_POS
		elseif c_score == core.LETTER_PRESENT_IN_WORD then
			state.letter_states[c] = core.LETTER_PRESENT_IN_WORD
		end

		if state.letter_states[c] ~= core.LETTER_PRESENT_IN_WORD then
			if c_score == core.LETTER_UNUSED then
				state.letter_states[c] = core.LETTER_UNUSED
			end
		end
		::next_letter::
	end
end

function core.validate_word(state, word_input)
	local word_len = #state.word
	if #word_input ~= word_len then
		print(string.format("Guess length is %d, need length %d", #word_input, word_len))
		return core.RC_WRONG_GUESS_LEN
	end

	if not is_valid_word(word_input) then
		return core.RC_NOT_VALID_WORD
	end

	return core.RC_SUCCESS
end

-- like the normal "guess" call that a player would call, but
-- without any dictionary checks. This is for loading games from save state.
function core.force_guess(state, guess)
	local letter_scores = get_word_letter_scores(state.word, guess)

	update_letter_states(state, guess, letter_scores)

	table.insert(state.guesses, {
		word  = guess,
		score = letter_scores,
	})

	if state.word == guess or
	   #state.guesses >= state.max_guesses then
		state.game_over = true
	end
end

-- This is what players should call when making a guess (with a full word).
function core.guess(state, guess)

	local rc = core.validate_word(state, guess)
	if rc ~= core.RC_SUCCESS then
		return rc
	end

	-- TODO add the option to only allow words that fit
	-- the existing knowledge?

	core.force_guess(state, guess)

	return core.RC_SUCCESS
end

function core.user_won(state, guess)
	return #state.guesses > 0 and state.guesses[#state.guesses].word == state.word
end

local function print_state_pretty(state)
	for guess_idx=1,state.max_guesses do
		if guess_idx <= #state.guesses then
			local guess = state.guesses[guess_idx]
			for i=1,state.word_len do
				if guess.score[i] == core.LETTER_PRESENT_IN_WORD then
					io.write("\27[43;30m")
				elseif guess.score[i] == core.LETTER_PRESENT_IN_POS then
					io.write("\27[42;30m")
				end
				local c = guess.word:sub(i,i)
				io.write(" " .. c .. " ")
				io.write("\27[0m")
				io.write(" ")
			end
			io.write("\n")
		else
			for i=1,state.word_len do
				io.write("___ ")
			end
			io.write("\n")
		end
	end

	print("")

	local keyboard = {
		"qwertyuiop",
		"asdfghjkl",
		"zxcvbnm",
	}

	for row_idx, keyboard_row in ipairs(keyboard) do
		for i=0,row_idx-2 do
			io.write(" ")
		end
		for i=1,#keyboard_row do
			local c = keyboard_row:sub(i,i)
			local key_state = state.letter_states[c]
			if key_state == core.LETTER_PRESENT_IN_WORD then
				io.write("\27[43;30m")
			elseif key_state == core.LETTER_PRESENT_IN_POS then
				io.write("\27[42;30m")
			elseif key_state == core.LETTER_UNUSED then
				c = ' '
			end
			io.write(c)
			io.write("\27[0m")
			io.write(" ")
		end
		io.write("\n")
	end
end

local function example_main_loop()
	local word_len    = 5
	local max_guesses = 6

	local state = core.new_game(word_len, max_guesses)

	while true do
		::new_guess::
		io.write("Enter a guess: ")
		local guess = io.read("*l")
		guess = guess:gsub("%s+", "")
		io.write("\n\n")
	
		local rc = core.guess(state, guess)
		if rc ~= core.RC_SUCCESS then
			--print(string.format("Error %d", rc))
			print(core.rc_to_str(rc))
			goto new_guess
		end

		print_state_pretty(state)

		if state.game_over then
			if state.guesses[#state.guesses].word ~= state.word then
				print(string.format("Game over! The word was \"%s\"", state.word))
			else
				print(string.format("You guessed the word in %d guesses.", #state.guesses))
			end
			break
		end
	end


end

-- example_main_loop()

--local scores = get_word_letter_scores("crane", "creep")
--for i, score in ipairs(scores) do
--	print(string.format("%d: %s", i, score))
--end

return core
local draw = {}

local alex_c_api = require("alex_c_api")

local core                  = require("games/word_mastermind/word_mastermind_core")

local draw_keyboard         = require("libs/draw/draw_keyboard")
local draw_celebration_anim = require("libs/draw/draw_celebration_anim")
local draw_shapes           = require("libs/draw/draw_shapes")
local show_buttons_popup    = require("libs/ui/show_buttons_popup")

draw.ACTION_NEW_GAME      = 1
draw.ACTION_CUSTOM_PUZZLE = 2

local BTN_ID_CUSTOM_PUZZLE = "custom_puzzle"
local BTN_ID_NEW_GAME      = "new_game"

local POPUP_ID_NEW_GAME_CONFIRM      = "popup_new_game_confirm"
local POPUP_ID_CUSTOM_PUZZLE_CONFIRM = "popup_custom_puzzle_confirm"

local OUTLINE_WIDTH = 1
local CHAR_TEXT_COLOUR          = '#ffffff'
local CHAR_TEXT_COLOUR_UNKNOWN  = '#000000'
local CHAR_BG_COLOUR_POS_KNOWN  = '#008800'
local CHAR_BG_COLOUR_CHAR_KNOWN = '#aaaa00'
local CHAR_BG_COLOUR_UNUSED     = '#444444'
local CHAR_BG_COLOUR_UNKNOWN    = '#ffffff'

if alex_c_api.get_user_colour_pref() == "dark" or 
   alex_c_api.get_user_colour_pref() == "very_dark" then
	CHAR_TEXT_COLOUR          = '#888888'
	CHAR_TEXT_COLOUR_UNKNOWN  = '#888888'
	CHAR_BG_COLOUR_POS_KNOWN  = '#003300'
	CHAR_BG_COLOUR_CHAR_KNOWN = '#333300'
	CHAR_BG_COLOUR_UNUSED     = '#000000'
	CHAR_BG_COLOUR_UNKNOWN    = '#222222'
end

local BG_COLOURS = {
	[core.LETTER_PRESENT_IN_WORD] = CHAR_BG_COLOUR_CHAR_KNOWN,
	[core.LETTER_PRESENT_IN_POS]  = CHAR_BG_COLOUR_POS_KNOWN,
	[core.LETTER_UNUSED]          = CHAR_BG_COLOUR_UNUSED,
	[core.LETTER_UNKNOWN]         = CHAR_BG_COLOUR_UNKNOWN,
}

local FG_COLOURS = {
	[core.LETTER_PRESENT_IN_WORD] = CHAR_TEXT_COLOUR,
	[core.LETTER_PRESENT_IN_POS]  = CHAR_TEXT_COLOUR,
	[core.LETTER_UNUSED]          = CHAR_TEXT_COLOUR,
	[core.LETTER_UNKNOWN]         = CHAR_TEXT_COLOUR_UNKNOWN,
}

local TEXT_SIZE = 32
local padding = 10

-- TODO this might be the first game that requires me to increase the height of the canvas
local board_width = 480
local board_height = 480

local text_start_x = math.floor((board_width - (TEXT_SIZE + padding) * 5)/2)
local big_text_size_y = (TEXT_SIZE + padding) * 6 + 2*padding

function draw.init()
	local draw_state = {
		user_input = {},
		anim = draw_celebration_anim.new_state({
			on_finish = function ()
				alex_c_api.set_timer_update_ms(0)
			end,
		})
	}

	alex_c_api.create_btn(BTN_ID_CUSTOM_PUZZLE, "New Custom Puzzle", 1)
	alex_c_api.create_btn(BTN_ID_NEW_GAME,      "New Game", 1)

	return draw_state
end

local function draw_word(game_state, pos, word, score)

	local padding   = 10

	x_pos = padding
	y_pos = padding + (TEXT_SIZE + padding) * (pos-1)

	local chars = {}
	if word == nil then
		for _=1,game_state.word_len do
			table.insert(chars, " ")
		end
	else
		for i=1,#word do
			table.insert(chars, word:sub(i,i))
		end
	end

	for char_idx, char in ipairs(chars) do
		x_pos = text_start_x + (TEXT_SIZE + padding) * (char_idx-1 + 0.5)
		local bg_colour = CHAR_BG_COLOUR_UNUSED
		local bg_outline_colour = CHAR_TEXT_COLOUR
		local fg_colour = CHAR_TEXT_COLOUR
		if score then
			local char_score = score[char_idx]
			if char_score ~= nil then
				bg_colour = BG_COLOURS[char_score]
			end
			
		end
		if bg_colour == CHAR_BG_COLOUR_UNKNOWN then
			fg_colour = CHAR_TEXT_COLOUR_UNKNOWN
		end
		local rect_y1 = y_pos + padding/2
		local rect_x1 = x_pos - (TEXT_SIZE + padding/2)/2
		local rect_y2 = y_pos + TEXT_SIZE + padding/2
		local rect_x2 = x_pos + (TEXT_SIZE+padding/2)/2
		alex_c_api.draw_rect(bg_colour,
		                     rect_y1, rect_x1,
		                     rect_y2, rect_x2)
		draw_shapes.draw_rect_outline(bg_outline_colour, OUTLINE_WIDTH,
		                              rect_y1, rect_x1,
		                              rect_y2, rect_x2)
		alex_c_api.draw_text(string.upper(char), fg_colour,
		                     y_pos + TEXT_SIZE, x_pos,
		                     math.floor(0.7*TEXT_SIZE),
		                     alex_c_api.TEXT_ALIGN_CENTRE)
	end
end

local function get_key_bg_colours(game_state)
	local bg_colours = {}
	for key, key_state in pairs(game_state.letter_states) do
		if key_state ~= nil then
			bg_colours[key] = BG_COLOURS[key_state]
		end
	end
	return bg_colours
end

local function get_key_fg_colours(game_state)
	local bg_colours = {}
	for key, key_state in pairs(game_state.letter_states) do
		if key_state ~= nil then
			bg_colours[key] = FG_COLOURS[key_state]
		end
	end
	return bg_colours
end


local function get_keyboard_params(game_state)
	return {
		y_start = big_text_size_y,
		x_start = 0,
		y_end   = board_height,
		x_end   = board_width,
		key_bg_colours = get_key_bg_colours(game_state),
		key_bg_colour_default = CHAR_BG_COLOUR_UNKNOWN,
		key_fg_colours = get_key_fg_colours(game_state),
		key_fg_colour_default = CHAR_TEXT_COLOUR_UNKNOWN,
	}
end

function draw.draw_state(ui_state, game_state, dt_ms)
	alex_c_api.draw_clear()
	if game_state == nil then return end
	for i=1,game_state.max_guesses do
		if i <= #game_state.guesses then
			local guess = game_state.guesses[i]
			draw_word(game_state, i, guess.word, guess.score)
		elseif i == 1+#game_state.guesses and #ui_state.user_input > 0 then
			local word = ""
			local score = {}
			for _, c in ipairs(ui_state.user_input) do
				word = word .. c
				table.insert(score, core.LETTER_UNKNOWN)
			end
			while #word < game_state.word_len do
				word = word .. " "
				table.insert(score, core.LETTER_UNUSED)
			end
			draw_word(game_state, i, word, score)
		else
			-- otherwise, draw empty squares
			draw_word(game_state, i, nil)
		end
	end
	draw_keyboard.draw_keyboard(get_keyboard_params(game_state))


	if dt_ms ~= 0 then
		draw_celebration_anim.update(ui_state.anim, dt_ms/1000.0)
	end
	draw_celebration_anim.draw(ui_state.anim)
	alex_c_api.draw_refresh()
end

local function handle_enter(ui_state)
	local word = ""
	for _, c in ipairs(ui_state.user_input) do
		word = word .. c
	end
	return word
end

local function handle_bksp(ui_state)
	table.remove(ui_state.user_input)
end

function draw.handle_user_clicked(ui_state, game_state, pos_y, pos_x)
	if game_state.game_over then
		return
	end
	local keyboard_params = get_keyboard_params(game_state)
	local key_pressed = draw_keyboard.get_key_pressed(keyboard_params, pos_y, pos_x)
	if key_pressed == nil then
		return
	end
	print(string.format("User pressed soft key %s", key_pressed))
	if key_pressed == draw_keyboard.SPECIAL_KEY_ENTER then
		print("user pressed enter!!!")
		return handle_enter(ui_state)
	elseif key_pressed == draw_keyboard.SPECIAL_KEY_BKSP then
		handle_bksp(ui_state)
	elseif #ui_state.user_input < game_state.word_len then
		table.insert(ui_state.user_input, key_pressed)
	end
end

function draw.clear_user_input(ui_state)
	ui_state.user_input = {}
end


function draw.handle_key_evt(ui_state, game_state, evt_id, key_code)
	local key_status = {
		handled    = false,
		guess_word = nil,
	}
	if game_state.game_over then
		return key_status
	end
	if evt_id == "keydown" then
		if key_code == "Enter" then
			key_status.handled = true
			key_status.guess_word = handle_enter(ui_state)
		elseif key_code == "Backspace" then
			key_status.handled = true
			handle_bksp(ui_state)
		else 
			local user_input_letter = string.match(key_code, "Key(%a)")
			if user_input_letter then
				key_status.handled = true
				if #ui_state.user_input < game_state.word_len then
					user_input_letter = string.lower(user_input_letter)
					table.insert(ui_state.user_input, user_input_letter)
				end
			end
		end
	end
	return key_status
end

function draw.player_won(ui_state)
	draw_celebration_anim.fireworks_display(ui_state.anim)
	alex_c_api.set_timer_update_ms(1000/60)
end

function draw.handle_btn_pressed(game_state, ui_state, btn_id)
	if btn_id == BTN_ID_NEW_GAME then
		if game_state and game_state.game_over then
			return draw.ACTION_NEW_GAME
		else
			-- TODO now I definitely need to implement the history browser for this game
			show_buttons_popup.show_popup(POPUP_ID_NEW_GAME_CONFIRM, "Start New Game?",
			                              "Are you sure you want to start a new game?\n" ..
			                              "Current progress can be resumed " ..
			                              "from the \"Load Autosaved Game\" in the options.",
			                              {"New Game", "Cancel"})
		end
	elseif btn_id == BTN_ID_CUSTOM_PUZZLE then
		if game_state and game_state.game_over then
			return draw.ACTION_CUSTOM_PUZZLE
		else
			show_buttons_popup.show_popup(POPUP_ID_CUSTOM_PUZZLE_CONFIRM, "Generate custom puzzle?",
			                              "Are you sure you want to generate a custom puzzle?\n" ..
			                              "Current progress can be resumed " ..
			                              "from the \"Load Autosaved Game\" in the options.",
			                              {"Generate custom puzzle", "Cancel"})
		end
	end
end

function draw.handle_popup_btn_pressed(game_state, ui_state, popup_id, btn_id)
	if popup_id == POPUP_ID_NEW_GAME_CONFIRM then
		alex_c_api.hide_popup()
		if btn_id == 0 then
			return draw.ACTION_NEW_GAME
		elseif btn_id == 1 then
		else
			error(string.format("Unhandled btn_id %d for popup %s", btn_id, popup_id))
		end
	elseif popup_id == POPUP_ID_CUSTOM_PUZZLE_CONFIRM then
		alex_c_api.hide_popup()
		if btn_id == 0 then
			return draw.ACTION_CUSTOM_PUZZLE
		elseif btn_id == 1 then
			alex_c_api.hide_popup()
		else
			error(string.format("Unhandled btn_id %d for popup %s", btn_id, popup_id))
		end
	else
		print(string.format("Popup id %s not handled", popup_id))
	end
end


return draw
-- TODO currently there's a bug where if you generate a custom puzzle via entering a
-- string and press "enter" with the keyboard, you see a 'Invalid guess ""' error message,
-- I guess the popup is being closed, and then the enter key is being processed.
local alex_c_api = require("alex_c_api")
local words_lib  = require("libs/words")

local core      = require("games/word_mastermind/word_mastermind_core")
local draw      = require("games/word_mastermind/word_mastermind_draw")
local serialize = require("games/word_mastermind/word_mastermind_serialize")

local WORD_LEN    = 5
local MAX_GUESSES = 6

local SAVED_STATE_KEY = "word_mastermind_saved_state"
local SESSION_ID_KEY  = "word_mastermind_session_id"

local state = {
	session_id = nil,
}
state.ui_state   = draw.init()

function draw_board(dt_ms)
	draw.draw_state(state.ui_state, state.game_state, dt_ms)
end

local function internal_draw_board(dt_ms)
	draw.draw_state(state.ui_state, state.game_state, dt_ms)
end

local function save_state(game_state)
	local serialized_state = serialize.serialize_state(game_state)
	alex_c_api.store_data(SAVED_STATE_KEY, serialized_state)
	alex_c_api.store_data(SESSION_ID_KEY, serialize.serialize_session_id(state.session_id))

	alex_c_api.save_state(state.session_id, serialized_state)
end

local function new_game(word)
	alex_c_api.set_status_msg("Starting new game")
	state.session_id = alex_c_api.get_new_session_id()
	state.game_state = core.new_game(WORD_LEN, MAX_GUESSES, word)
	save_state(state.game_state)
	draw.draw_state(state.ui_state, state.game_state, 0)
end

local function prompt_custom_puzzle()
	local msg = "Enter your own word to generate a puzzle.\n" ..
	            "Then you can either let a friend play on your device, " ..
	            "or send them a link by pressing \"share state\" in the " ..
	            "options menu."
	alex_c_api.prompt_string("Custom puzzle", msg)
end

function get_state()
	local serialized_state = serialize.serialize_state(state.game_state)
	local byteary = {}
	for i=1,#serialized_state do
		table.insert(byteary, string.byte(serialized_state:sub(i,i)))
	end
	return byteary
end


function get_init_state()
	local init_state = core.new_game(#state.game_state.word, state.game_state.max_guesses, state.game_state.word)
	local serialized_state = serialize.serialize_state(init_state)
	local byteary = {}
	for i=1,#serialized_state do
		table.insert(byteary, string.byte(serialized_state:sub(i,i)))
	end
	return byteary
end

	

function handle_user_string_input(str_input, is_cancelled)
	print(string.format("handle_user_string_input: %s, is_cancelled=%s", str_input, is_cancelled))
	local rc = core.validate_word(state.game_state, str_input)
	if rc ~= core.RC_SUCCESS then
		alex_c_api.set_status_err(string.format("Invalid word \"%s\": %s", str_input, core.rc_to_str(rc)))
		return
	end
	new_game(str_input)
	internal_draw_board(0)
end

function start_game(session_id, serialized_state)
	core.init_lib()
	if not core.dict_ready() then
		alex_c_api.set_status_msg("Waiting for dictionary to load... not starting game yet")
		return
	end

	-- if state wasn't passed via param, then check if it's stored in
	-- persistent storage
	if serialized_state == nil then
		-- TODO now that the get_last_session_id() API was introduced, I should use that instead
		session_id = serialize.deserialize_session_id(alex_c_api.read_stored_data(SESSION_ID_KEY))
		serialized_state = alex_c_api.read_stored_data(SAVED_STATE_KEY)
	end

	-- if we do have some saved state, then deserialize it.
	-- otherwise, start a new game
	if serialized_state ~= nil then
		state.session_id = session_id
		state.game_state = serialize.deserialize_state(serialized_state)
	else
		new_game()
	end

	alex_c_api.enable_evt("key")
end

local function handle_guess(guess)
	local rc = core.guess(state.game_state, guess)
	if rc == core.RC_SUCCESS then
		save_state(state.game_state)
		draw.clear_user_input(state.ui_state)
		local msg = string.format("User guessed \"%s\"", guess)
		if state.game_state.game_over then
			if core.user_won(state.game_state) then
				msg = msg .. string.format(", you win! Correct answer in %d guesses.", #state.game_state.guesses)
				draw.player_won(state.ui_state)
			else
				msg = msg .. string.format(", game over! Correct answer was \"%s\"", state.game_state.word)
			end
		end
		alex_c_api.set_status_msg(msg)
	else
		alex_c_api.set_status_err(string.format("Invalid guess \"%s\", %s", guess, core.rc_to_str(rc)))
	end
end

-- I guess at some point I supported this?
-- The user_string_input callback could really use an identifier to see what the purpose
-- of the string is.
-- For now I'm only using string input for generating custom puzzles.
--[[
function handle_user_string_input(user_line, is_cancelled)
	if not is_cancelled then
		local guess = user_line
		handle_guess(guess)
		draw.draw_state(state.ui_state, state.game_state, 0)
	end
end
--]]


function handle_user_clicked(pos_y, pos_x)
	local word = draw.handle_user_clicked(state.ui_state, state.game_state, pos_y, pos_x)
	if word then
		handle_guess(word)
	end
	draw.draw_state(state.ui_state, state.game_state, 0)
end

function handle_key_evt(evt_id, key_code)
	--print(string.format("handle_key_evt(%s, %s)", evt_id, key_code))
	local key_info = draw.handle_key_evt(state.ui_state, state.game_state, evt_id, key_code)
	if key_info.guess_word ~= nil then
		handle_guess(key_info.guess_word)
	end
	draw.draw_state(state.ui_state, state.game_state, 0)
	return key_info.handled
end

local function handle_action(action)
	if action == nil then
		-- do nothing
	elseif action == draw.ACTION_NEW_GAME then
		new_game()
		internal_draw_board(0)
	elseif action == draw.ACTION_CUSTOM_PUZZLE then
		prompt_custom_puzzle()
		-- TODO
	else
		error(string.format("Unhandled action %s", action))
	end
end

function handle_btn_clicked(btn_id)
	local action = draw.handle_btn_pressed(state.game_state, state.ui_state, btn_id)
	handle_action(action)
end

function handle_popup_btn_clicked(popup_id, btn_id)
	local action = draw.handle_popup_btn_pressed(state.game_state, state.ui_state, popup_id, btn_id)
	handle_action(action)
end
local serialize = {}

local serialize_lib = require("libs/serialize/serialize")

local core = require("games/word_mastermind/word_mastermind_core")

serialize.version = 1

function serialize.serialize_state(state)
	if state == nil then return nil end
	local output = ""

	output = output .. serialize_lib.serialize_byte(serialize.version)

	output = output .. serialize_lib.serialize_byte(state.max_guesses)
	output = output .. serialize_lib.serialize_string(state.word)
	output = output .. serialize_lib.serialize_16bit(#state.guesses)
	for _, guess in ipairs(state.guesses) do
		output = output .. serialize_lib.serialize_string(guess.word)
	end

	return output
end

function serialize.deserialize_state(bytes)
	if bytes == nil then return nil end
	bytes = serialize_lib.bytestr_to_byteary(bytes)

	local version = serialize_lib.deserialize_byte(bytes)

	if version ~= serialize.version then
		error(string.format("can't deserialize state: received version %d, this implementation version is %d", version, serialize.version))
	end

	local partial_state = {}
	partial_state.max_guesses = serialize_lib.deserialize_byte(bytes)
	partial_state.word        = serialize_lib.deserialize_string(bytes)
	partial_state.guesses     = {}
	local guess_count         = serialize_lib.deserialize_16bit(bytes)
	for i=1,guess_count do
		table.insert(partial_state.guesses, serialize_lib.deserialize_string(bytes))
	end

	local state = core.new_game(#partial_state.word, partial_state.max_guesses, partial_state.word)
	for guess_idx, guess in ipairs(partial_state.guesses) do
		core.force_guess(state, guess)
	end

	return state
end

function serialize.serialize_session_id(bytes)
	return serialize_lib.serialize_s32(bytes)
end

function serialize.deserialize_session_id(bytestr)
	if bytestr == nil then
		return nil
	end
	bytes = serialize_lib.bytestr_to_byteary(bytestr)
	return serialize_lib.deserialize_s32(bytes)
end

return serialize
local wu = {}

wu.EMPTY   = 0
-- Player1 is black (since black goes first)
wu.PLAYER1 = 1
-- Player2 is white (since white goes second)
wu.PLAYER2 = 2

wu.PIECES_IN_ROW_TO_WIN = 5

function wu.player_idx_to_colour_name(idx)
	local map =  {
		[wu.PLAYER1] = "black",
		[wu.PLAYER2] = "white",
	}
	return map[idx]
end

local Point = {x = 0, y = 0}

function Point:str(self)
	return string.format("(%d,%d)",self.y, self.x)
end

function Point:create (o)
	o.parent = self
	return o
end

function Point:add(arg1, arg2)
	return Point:create{ y = (arg1.y + arg2.y), x = (arg1.x + arg2.x) }
end

function Point:mult(arg, factor)
	return Point:create{ y = (arg.y * factor), x = (arg.x * factor) }
end

local function in_range(game_state, y, x)
	return (1 <= x and x <= game_state.x_max and
	       1 <= y and y <= game_state.y_max)
end


-- In only one direction, you must check these and the negative of them at once
-- (if a user places a piece "a" in "xxaxx" then they still win, because they have 2 on the right
-- and 2 on the left)
local dirs = {
	{y = 0, x = 1}, -- -->
	{y = 1, x = 0}, -- ^
	{y = 1, x = 1}, -- \v
	{y =-1, x = 1}, -- /^
}

local function make_2d_array(y_len,x_len, val)
	local visited = {}
	for y=1,y_len do
		table.insert(visited, {})
		for x=1,x_len do
			table.insert(visited[y], val)
		end
	end
	return visited
end

local function copy_2d_array(ary)
	local to_return = {}
	for y=1, #ary do
		table.insert(to_return, {})
		for x=1, #ary[y] do
			table.insert(to_return[y], ary[y][x])
		end
	end
	return to_return
end

local val_to_char = {
	[wu.EMPTY]   = ' ',
	[wu.PLAYER1] = '1',
	[wu.PLAYER2] = '2'
}

function wu.print_board(board)
	if #board[1] > 9 then
		io.write('  ')
		for x =1, #board[1] do
			local c = ' '
			if x >= 10 then c = string.format('%d', math.floor(x/10)) end
			io.write(string.format('%s ', c))
		end
		io.write('\n')
	end
	io.write('  ')
	for x =1, #board[1] do
		io.write(string.format('%d ', x%10))
	end
	io.write('\n +')
	for x =1, #board[1] do
		io.write('-+')
	end
	io.write('\n')
	for y = 1, #board do
		io.write(string.format('%s|', string.char(string.byte('A')+(y-1))))
		for x = 1, #board[y] do
			local c =  board[y][x]
			io.write( val_to_char[c] )
			io.write('|')
		end
		io.write('\n +')
		for x =1, #board[y] do
			io.write('-+')
		end
		io.write('\n')
	end
end

function wu.player_num_to_char(num)
	return val_to_char[num]
end

function wu.new_game(size)
	game_state = {
		player_turn = 1,
		y_max = size,
		x_max = size,
		board = make_2d_array(size, size, wu.EMPTY),
		last_move_y = nil,
		last_move_x = nil,
		winner = nil,
	}
	return game_state
end

function if_nil_rt_zero(val)
	if val == nil then
		return 0
	else
		return val
	end
end

function wu.serialize_state(state)
	local bytes = { }
	bytes[#bytes+1] = string.char(state.player_turn)
	bytes[#bytes+1] = string.char(state.y_max)
	bytes[#bytes+1] = string.char(state.x_max)
	bytes[#bytes+1] = string.char(if_nil_rt_zero(state.last_move_y))
	bytes[#bytes+1] = string.char(if_nil_rt_zero(state.last_move_x))
	for y=1,state.y_max do
		for x=1,state.x_max do
			bytes[#bytes+1] = string.char(state.board[y][x])
		end
	end

	--print(string.format("Serialized state into %d bytes", #bytes))
	return table.concat(bytes, "")
end

function wu.deserialize_state(data)
	local state = {}
	local header_bytes = 5
	if #data < header_bytes then
		print(string.format("Bad serialized state received, less than 3 bytes: %d", #data))
		return nil
	end
	state.player_turn = string.byte(data:sub(1,1))
	state.y_max       = string.byte(data:sub(2,2))
	state.x_max       = string.byte(data:sub(3,3))
	state.last_move_y = string.byte(data:sub(4,4))
	state.last_move_x = string.byte(data:sub(5,5))
	local expected_len = header_bytes + state.y_max * state.x_max 
	if #data ~= expected_len then
		print(string.format("Bad serialized state, recvd %d bytes, expected %d bytes; y_max = %d, x_max = %d",
		                    #data, expected_len, state.y_max, state.x_max))
		return nil
	end
	state.board = make_2d_array(state.y_max, state.x_max, wu.EMPTY)
	local idx = header_bytes + 1
	for y=1,state.y_max do
		for x=1,state.x_max do
			state.board[y][x] = string.byte(data:sub(idx,idx))
			idx = idx + 1
		end
	end

	return state
end

wu.SUCCESS        =  0
wu.NOT_YOUR_TURN  = -1
wu.OUT_OF_RANGE   = -2
wu.OCCUPIED       = -3
wu.GAME_OVER      = -4

local code_to_str = {
	[wu.SUCCESS]        = "Success",
	[wu.NOT_YOUR_TURN]  = "Not your turn",
	[wu.OUT_OF_RANGE]   = "Position out of range",
	[wu.OCCUPIED]       = "Position occupied",
	[wu.GAME_OVER]      = "Game over",
}

function wu.err_code_to_str(code)
	return code_to_str[code]
end


function wu.player_move(game_state, player, y, x)
	print(string.format("Attempting to move player %s to y=%d, x=%d", player, y, x))

	if game_state.winner ~= nil then
		return wu.GAME_OVER
	end
	if player ~= game_state.player_turn then
		return wu.NOT_YOUR_TURN
	end

	if not (1 <= x and x <= game_state.x_max) or
	   not (1 <= y and y <= game_state.y_max) then
		return wu.OUT_OF_RANGE
	end

	if game_state.board[y][x] ~= wu.EMPTY then
		return wu.OCCUPIED
	end


	game_state.board[y][x] = player

	pt = Point:create{y=y, x=x}
	for _, dir in ipairs(dirs) do
		local in_a_row = 1
		for is_neg=0, 1 do
			for i=1,wu.PIECES_IN_ROW_TO_WIN-1 do
				local offset = Point:mult(dir,i)
				if is_neg == 1 then
					offset = Point:mult(offset, -1)
				end
				local pt2 = Point:add(pt, offset)
				if not in_range(game_state, pt2.y, pt2.x) then
					goto neg_dir
				end
				local dst = game_state.board[pt2.y][pt2.x]
				if dst ~= player then
					goto neg_dir
				end
				in_a_row = in_a_row + 1
			end
			::neg_dir::
		end

		if in_a_row >= wu.PIECES_IN_ROW_TO_WIN then
			game_state.winner = player
			print(string.format("Found winner at y=%d,x=%d", pt.y, pt.x))
			goto end_dir_loop
		end
	end
	::end_dir_loop::

	if game_state.player_turn == 1 then
		game_state.player_turn = 2
	elseif game_state.player_turn == 2 then
		game_state.player_turn = 1
	else
		error("invalid player turn")
	end
	game_state.last_move_y = pt.y
	game_state.last_move_x = pt.x
	return wu.SUCCESS
end


return wu
local wu_ctrl = {}
-- This file should contain the state for things like deciding
-- if players have been chosen yet (whether the player choice UI should be shown),
-- and what player you are

function wu_ctrl.new_state()
	return {
		player_choice = nil,
		other_player_choice = nil,
	}
end

function wu_ctrl.player_chosen(ctrl_state, player_idx)
	print(string.format("Storing player choice of %q", player_idx))
	ctrl_state.player_choice = player_idx
end

function wu_ctrl.other_player_chosen(ctrl_state, player_idx)
	print(string.format("Storing other player choice of %q", player_idx))
	ctrl_state.other_player_choice = player_idx
end

function wu_ctrl.get_player(ctrl_state)
	return ctrl_state.player_choice
end

function wu_ctrl.get_other_player(ctrl_state)
	return ctrl_state.other_player_choice
end

return wu_ctrl
local two_player = require("libs/multiplayer/two_player")
local utils      = require("libs/utils")

local wu      = require("games/wu/wu_core")
local wu_ui   = require("games/go/go_ui")
local wu_ctrl = require("games/wu/wu_ctrl")

local alex_c_api = require("alex_c_api");
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local OPTION_ID_NEW_GAME = "opt_new_game"

-- e.g. either 9x9, 13x13, or 19x19
local session_id = alex_c_api.get_new_session_id()
local wu_game_size = 15
local state
local ctrl_state = wu_ctrl.new_state()
local local_multiplayer

local player_name_to_id = {}

-- TODO have a C API to get height/width of canvas, or maybe
-- set it?
local height = 480
local width = 480
wu_ui.init_ui(session_id, wu_game_size, width, height)

-- Do request state initially.
-- But on game over, whoever presses "new game" first is the one that should send state
-- so when you receive an event that says "new game", don't request state
-- but if you haven't yet received that message, then you should send your state
local request_state = true

local function get_player()
	if local_multiplayer then
		return state.player_turn
	else
		return wu_ctrl.get_player(ctrl_state)
	end
end

function new_game()
	state = wu.new_game(wu_game_size)
	alex_c_api.set_status_msg("Choose piece colour")
	if request_state then
		alex_c_api.send_message("all", "get_state:")
	else
		alex_c_api.send_message("all", "new_game:")
		send_state()
	end
	request_state = true
	draw_board()
end

PLAYER_CHOICE_POPUP_ID = "choose_player_colour"
PLAYER_CHOICE_BTNS = {
	"Black",
	"White",
}
PLAYER_CHOICE_BTNS_MAP = {
	[0] = wu.PLAYER1,
	[1] = wu.PLAYER2,
}
PLAYER_IDX_TO_BTN_IDX_MAP = utils.reverse_map(PLAYER_CHOICE_BTNS_MAP)

GAME_OVER_POPUP_ID = "game_over"

function draw_board() 
	wu_ui.draw_board(session_id, state.board, state.last_move_y, state.last_move_x)
end

function first_char_upper(str)
	return str:sub(1,1):upper() .. str:sub(2,#str)
end

function check_for_winner()
	if state.winner ~= nil then
		local winner = wu.player_idx_to_colour_name(state.winner)
		local msg = string.format("Game over! %s wins.", first_char_upper(winner))
		request_state = false
		show_buttons_popup.show_popup(GAME_OVER_POPUP_ID,
		                              "Game over",
		                              msg,
		                              {"New game"})
		alex_c_api.set_status_msg(msg)
	end
end

function handle_user_clicked(pos_y, pos_x)
	local pos = wu_ui.user_pos_to_piece_idx(pos_y, pos_x)
	local player = get_player()
	local rc = wu.player_move(state, player, pos.y, pos.x)
	if rc == wu.SUCCESS then
		if not local_multiplayer then
			alex_c_api.send_message("all", string.format("move:%d,%d,%d", player, pos.y, pos.x));
		end
		alex_c_api.set_status_err("")
		alex_c_api.save_state(session_id, wu.serialize_state(state))
	else
		alex_c_api.set_status_err(wu.err_code_to_str(rc))
	end
	draw_board()
	update_status_msg_turn(state, ctrl_state)
	check_for_winner()
end

function send_state()
	alex_c_api.send_message("all", "state:"..wu.serialize_state(state))
end

function handle_msg_received(src, msg)
	print("handle_msg_received (from src:" .. src .. "): " .. msg);

	if local_multiplayer then
		return
	end

	if two_player.handle_msg_received(src, msg) then
		return
	end

	local m = msg:gmatch("(%S+):(.*)")
	local header, payload
	header, payload = m()

	if header == "move" then
		local m = payload:gmatch"(%d+),(%d+),(%d+)"
		local player, row, col
		player, row, col = m()
		player = tonumber(player)
		row = tonumber(row)
		col = tonumber(col)
		print(string.format("Received player=%s, row=%s, col=%d", player, row, col))

		if player == wu_ctrl.get_player(ctrl_state) then
			-- TODO make UI visible message for this case?
			print(string.format("Received message for move from wrong player"))
			return
		end
		wu.player_move(state, player, row, col)
		alex_c_api.set_status_err("")
		draw_board()
		update_status_msg_turn(state, ctrl_state)
		check_for_winner()
	elseif header == "get_state" then
		send_state()
	elseif header == "state" then
		local new_state = wu.deserialize_state(payload)
		-- TODO check with user if they want to overwrite their state with
		-- this (possibly unsolicited!!) state from the other player
		state = new_state
		draw_board()
		alex_c_api.set_status_err("")
		update_status_msg_turn(state, ctrl_state)
	elseif header == "new_game" then
		request_state = true
	else
		print("Unexpected message header: \""..header.."\"")
	end
end

function handle_btn_clicked(btn_id)
	print("handle_btn_clicked: "..btn_id)
	if btn_id == wu_ui.BTN_ID_UNDO then
		load_state_move_offset(-1)
	elseif btn_id == wu_ui.BTN_ID_REDO then
		load_state_move_offset(1)
	else
		error(string.format("Unhandled button: \"%s\"", btn_id))
	end
end

local function get_player_name(player_arg)
	for name, player_idx in pairs(player_name_to_id) do
		if player_arg == player_idx then return name end
	end
	return "nil"
end

function update_status_msg_turn(state, ctrl_state)
	if state == nil then return end

	local display_name = wu.player_idx_to_colour_name(state.player_turn)
	if not local_multiplayer then
		display_name = string.format("%s (%s)", display_name, get_player_name(state.player_turn))
	end
	alex_c_api.set_status_msg(string.format("Waiting for %s to move", display_name))
end

function handle_popup_btn_clicked(popup_id, btn_idx)
	if two_player.handle_popup_btn_clicked(popup_id, btn_idx) then
		-- handled, no action here
	elseif popup_id == GAME_OVER_POPUP_ID then
		if btn_idx == 0 then
			new_game()
			alex_c_api.hide_popup()
		end
	else
		print(string.format("Unexpected popup_id \"%s\"", popup_id));
		alex_c_api.hide_popup()
	end
end

function two_player_init()
	local args = {
		supports_local_multiplayer = true,
		handle_multiplayer_type_choice = function (multiplayer_type)
			if multiplayer_type == two_player.MULTIPLAYER_TYPE_LOCAL then
				local_multiplayer = true
			elseif multiplayer_type == two_player.MULTIPLAYER_TYPE_NETWORK then
				local_multiplayer = false
			end
		end,
		title = "Choose piece colour",
		player_choices = PLAYER_CHOICE_BTNS,
		choice_id_to_player_id = function (btn_id)
			return PLAYER_CHOICE_BTNS_MAP[btn_id]
		end,
		player_name_to_id = player_name_to_id,
		player_id_to_nice_name = function (player_id)
			local player_colour = wu.player_idx_to_colour_name(player_id)
			return utils.make_first_char_uppercase(player_colour)
		end,
		get_msg = function ()
			local msg = "Black moves first."
			--local other_player = wu_ctrl.get_other_player(ctrl_state)
			if utils.table_len(player_name_to_id) == 0 then
				msg = msg .. "\nThe other player has not yet chosen."
			else
				--msg = msg .. string.format("The other player has chosen %s",
				--                           wu.player_idx_to_colour_name(other_player))
				for player_name, player_id in pairs(player_name_to_id) do
					local player_colour = wu.player_idx_to_colour_name(player_id)
					msg = msg .. string.format("\n%s is chosen by %s", utils.make_first_char_uppercase(player_colour), player_name)
				end
			end
			return msg
		end,
		handle_player_choice = function (player_name, player_id)
			local choice_str = wu.player_idx_to_colour_name(player_id)
			print(string.format("handle_player_choice{ player_name=\"%s\", choice=%q (%q) }", player_name, player_id, choice_str))
			if player_name == two_player.LOCAL_PLAYER then
				wu_ctrl.player_chosen(ctrl_state, player_id)
				update_status_msg_turn(state, ctrl_state)
			else
				wu_ctrl.other_player_chosen(ctrl_state, player_id)

			end
			print(string.format("we are %q, other player is %q",
			      wu_ctrl.get_player(ctrl_state), wu_ctrl.get_other_player(ctrl_state)))
		end,

		need_reselect = function ()
			local this_player  = wu_ctrl.get_player(ctrl_state)
			local other_player = wu_ctrl.get_other_player(ctrl_state)

			-- print(string.format("needs_reselect { this_player = %q, other_player = %q }", this_player, this_player == other_player))
			return this_player == nil or this_player == other_player
		end,

		get_local_player_choice = function ()
			return wu_ctrl.get_player(ctrl_state)
		end
	}
	two_player.init(args)
end

function handle_game_option_evt(option_id)
	if option_id == OPTION_ID_NEW_GAME then
		new_game()
	else
		error(string.format("Unhandled option_id %s", option_id))
	end
end


function get_state()
	return wu.serialize_state(state)
end

function load_state_helper(session_id_arg, serialized_state)
	session_id = session_id_arg
	state = wu.deserialize_state(serialized_state)
end


function load_state_move_offset(move_offset)
	local serialized_state = alex_c_api.get_saved_state_offset(session_id, move_offset)
	load_state_helper(session_id, serialized_state)
	draw_board()
	send_state()
end


function lua_main()
	while true do
		print_board()
		::read_input::
		local user_input = get_user_input()
		local rc = handle_user_string_input(user_input)
		if rc ~= wu.SUCCESS then
			print('Error: '.. wu.err_code_to_str(rc))
			goto read_input
		end
	end
end


function start_game(session_id_arg, serialized_state)
	local last_sess_id = alex_c_api.get_last_session_id()

	if serialized_state ~= nil then
		print("Loading state from URL param")
		load_state_helper(session_id_arg, serialized_state)
	elseif last_sess_id ~= nil then
		print("Loading autosaved state")
		serialized_state = alex_c_api.get_saved_state_offset(last_sess_id, 0)
		load_state_helper(last_sess_id, serialized_state)
	else
		print("Starting new game, no URL param or autosaved state found")
		new_game()
	end
	two_player_init()
	alex_c_api.send_message("all", "get_state:")

	alex_c_api.add_game_option(OPTION_ID_NEW_GAME, { type = alex_c_api.OPTION_TYPE_BTN, label = "New Game"})
end


local cards_draw = require("libs/cards/cards_draw")

local canvas_width  = 480
local canvas_height = 480

local card_width  =  40
local card_height =  70
local font_size   =  24
local padding     =   5

if false then
	card_width  =  70
	card_height = 120
	font_size   =  48
	padding     =   5
end

cards_draw.draw_facedown_card(padding, padding, card_width, card_height)

local deck2 = cards.new_deck()
cards.shuffle(deck2)


local dx = card_width + padding
local dy = card_height + padding

local y = padding
local x = padding + dx

for i, card in ipairs(deck2) do


	print("Drawing card " .. cards.card_to_string(card))
	cards_draw.draw_card(card, y, x, card_width, card_height, font_size)

	x = x + dx

	if x + card_width + padding >= canvas_width then
		x = padding
		y = y + dy
	end
end

cards = {}

cards.DIAMONDS = "diamonds"
cards.HEARTS   = "hearts"
cards.SPADES   = "spades"
cards.CLUBS    = "clubs"

cards.ACE   = 1
cards.JACK  = 11
cards.QUEEN = 12
cards.KING  = 13

cards.MIN_VAL = cards.ACE
cards.MAX_VAL = cards.KING

cards.NUM_SUITS = 4
cards.NUM_VALS  = 13

cards.suits = {
	cards.DIAMONDS,
	cards.HEARTS,
	cards.SPADES,
	cards.CLUBS,
}

cards.suit_to_idx = {
	[cards.DIAMONDS] = 0,
	[cards.HEARTS]   = 1,
	[cards.SPADES]   = 2,
	[cards.CLUBS]    = 3,
}

cards.idx_to_suit = {
}

for suit, suit_idx in pairs(cards.suit_to_idx) do
	cards.idx_to_suit[suit_idx] = suit
end

cards.UNREVEALED_CARD = 53

cards.vals = {
	cards.ACE,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	cards.JACK,
	cards.QUEEN,
	cards.KING,
}

function cards.card_to_int(card)
	if card == nil then error("card_to_int arg is nil", 2) end
	if card == cards.UNREVEALED_CARD then
		return card
	end
	return cards.suit_to_idx[card.suit] * cards.NUM_VALS + (card.val-1)
end

function cards.int_to_card(card_int)
	if card_int == cards.UNREVEALED_CARD then
		return card_int
	end
	if not(0 <= card_int and card_int < cards.NUM_SUITS * cards.NUM_VALS) then
		return nil
	end
	local card = {}
	card.suit = cards.idx_to_suit[math.floor(card_int / cards.NUM_VALS)]
	card.val  = (card_int % cards.NUM_VALS) + 1
	return card
end

function cards.copy_card(card)
	if card == nil then
		return nil
	end
	local card_int = cards.card_to_int(card)
	return cards.int_to_card(card_int)
end

function cards.copy_card_ary(card_ary_orig)
	local card_ary_copy = {}
	for _, card in ipairs(card_ary_orig) do
		table.insert(card_ary_copy, cards.copy_card(card))
	end
	return card_ary_copy
end

function cards.copy_card_ary_ary(card_ary_ary_orig)
	local ary_copy = {}
	for _, card_ary in ipairs(card_ary_ary_orig) do
		table.insert(ary_copy, cards.copy_card_ary(card_ary))
	end
	return ary_copy
end


function cards.val_to_string(val)
	if val == nil then
		return "nil"
	end
	local to_letter = {
		[cards.ACE]   = "A",
		[cards.JACK]  = "J",
		[cards.QUEEN] = "Q",
		[cards.KING]  = "K",
	}

	if 2 <= val and val <= 10 then
		return string.format("%d", val)
	else
		return to_letter[val]
	end
end

function cards.card_to_string(card)
	if card == nil then return 'nil' end
	local val_str = cards.val_to_str(card.val)
	local suit_str = cards.suit
	return string.format('[%s %s]', suit_str, val_str)
end

function cards.card_ary_to_string(card_ary)
	local s = '{'
	for i, card in ipairs(card_ary) do
		if i == 1 then s = s .. ' '
		else s = s .. ', ' end
		s = s .. cards.card_to_string(card)
	end
	s = s .. '}'
	return s
end

local function swap(array, index1, index2)
    array[index1], array[index2] = array[index2], array[index1]
end

local function shuffle(array)
    local counter = #array
    while counter > 1 do
        local index = math.random(counter)
        swap(array, index, counter)
        counter = counter - 1
    end
end

local function new_card(suit,val)
	return { suit = suit, val = val }
end

function cards.new_deck()
	local deck = {}
	for _, suit in ipairs(cards.suits) do
		for _, val in ipairs(cards.vals) do
			local card = new_card(suit, val)
			deck[#deck+1] = card
		end
	end
	return deck
end

function cards.shuffle(deck)
	return shuffle(deck)
end

function cards.card_to_string(card)
	if card == nil then return "nil"
	elseif card == cards.UNREVEALED_CARD then return "[unrevealed]" end
	return string.format("[%s %s]", card.suit, cards.val_to_string(card.val))
end

function cards.card_array_to_string(card_array)
	local str = "{"
	for i=1,#card_array do
		str = str .. cards.card_to_string(card_array[i]) .. ", "
	end
	str = str .. "}"
	return str
end

function cards.serialize_card(card)
	local byte = nil
	if card == nil then
		byte = 255
	else
		byte = cards.card_to_int(card)
	end
	local chars = {string.char(byte)}
	return table.concat(chars, "")
end

function cards.deserialize_card(bytes)
	local card_int = string.byte(table.remove(bytes,1))
	if card_int == 255 then
		return nil
	else
		return cards.int_to_card(card_int)
	end
end

function cards.serialize_card_array(card_array)
	if card_array == nil then
		error("arg is nil", 2)
		return
	end
	local bytes = {}
	bytes[#bytes+1] = string.char(#card_array)
	for i=1,#card_array do
		bytes[#bytes+1] = string.char(cards.card_to_int(card_array[i]))
	end
	local msg = table.concat(bytes, "")
	return msg
end

-- Also removes the elements from the table `bytes`
function cards.deserialize_card_array(bytes)
	local card_array = {}
	--local num_cards = string.byte(bytes:sub(1,1))
	local num_cards = string.byte(table.remove(bytes, 1))
	if #bytes < num_cards then
		error(string.format("expected %d bytes, only had %d", num_cards, #bytes))
		return
	end
	for i=1,num_cards do
		--card_array[#card_array+1] = cards.int_to_card(string.byte(bytes:sub(i,i)))
		local card_int = string.byte(table.remove(bytes,1))
		card_array[#card_array+1] = cards.int_to_card(card_int)
	end 
	return card_array
end

function cards.suit_is_red(suit)
	return suit == cards.DIAMONDS or suit == cards.HEARTS
end

function cards.cards_eq(card1, card2)
	return (card1.suit == card2.suit and
	        card1.val  == card2.val)
end


--[[
for i=0,51 do
	local card = cards.int_to_card(i)
	local i2 = cards.card_to_int(card)
	if i ~= i2 then
		error(string.format("%q ~= %q", i, i2))
	end
	--print(string.format("i=%d, card=%s, i2=%d", i, cards.card_to_string(card), i2))
end
]]

return cards
local cards = require("libs/cards/cards")
local draw_more = require("libs/draw/draw_more")
local draw_shapes = require("libs/draw/draw_shapes")
local alex_c_api = require("alex_c_api")

-- TODO make definitions of this in alex_c_api
local ALIGN_CENTRE = 0
local ALIGN_LEFT = 1

local DARK_OVERLAY_COLOUR_CARD_FACE = "#000000aa"
local DARK_OVERLAY_COLOUR_CARD_BACK = "#000000aa"

local font_size_small = 16
-- local font_size_small = 12

local cards_draw = {}

function cards_draw.draw_facedown_card(y, x, width, height, higlight, angle, brightness_percent)
	brightness_percent = nil -- overriding this because I am drawing the DARK_OVERLAY over the card
	draw_more.draw_graphic_ul("card_facedown", y, x, width, height, { angle_degrees = angle, brightness_percent = brightness_percent })

	if alex_c_api.get_user_colour_pref() == "dark" then
		local pts = draw_more.get_rotated_pts_ul(y, x, width, height, angle)
		alex_c_api.draw_rect(DARK_OVERLAY_COLOUR_CARD_BACK,
		                     pts.y, pts.x,
		                     pts.y + pts.height, pts.x + pts.width)
	end

	if higlight then
		local padding = math.floor(math.max(height*0.05, width*0.05))
		draw_more.draw_graphic_ul("card_highlight",
		                        y - padding, x - padding,
		                        width + 2*padding, height + 2*padding,
		                        { angle_degrees = angle })
	end

end

function cards_draw.draw_card(card, y, x, width, height, font_size, highlight, angle)
	if card == nil then
		error("card is nil");
	end


	local suits_to_graphic = {
		[cards.DIAMONDS] = "card_diamonds",
		[cards.HEARTS]   = "card_hearts",
		[cards.SPADES]   = "card_spades",
		[cards.CLUBS]    = "card_clubs",
	}

	local blank_card_colour = '#ffffff'
	local suit_colour_red   = "#ff0000"
	local suit_colour_black = "#000000"
	local card_outline           = '#000000'
	local card_outline_thickness = 2
	local brightness_percent_suit_icon = nil
	local brightness_percent_facedown_card = nil

	-- This looks fine on every browser except safari, which
	-- doesn't support it.
	-- So I will comment this out for now and just draw a transparent grey
	-- rectangle over all the cards
	-- Checking alex_c_api.is_feature_supported() here would be nice,
	-- but I wasn't sure how to check if these features are supported
	-- (or even if the user is using safari or not)
	if false and alex_c_api.get_user_colour_pref() == "dark" then
		blank_card_colour = '#444444'
		suit_colour_red   = "#AA0000"
		suit_colour_black = "#000000"
		card_outline      = '#000000'
		brightness_percent_suit_icon = 50
		brightness_percent_facedown_card = 35
	end

	if card == cards.UNREVEALED_CARD then
		cards_draw.draw_facedown_card(y, x, width, height, highlight, angle, brightness_percent_facedown_card)
		return
	end
	
	
	local suits_to_text_colour = {
		[cards.DIAMONDS] = suit_colour_red,
		[cards.HEARTS]   = suit_colour_red,
		[cards.SPADES]   = suit_colour_black,
		[cards.CLUBS]    = suit_colour_black,
	}

	local small_padding = math.floor(width*0.1)

	local suit_icon_big_width  = math.floor(width*0.45)
	local suit_icon_big_height = math.floor(height*0.45)

	local suit_icon_big_y
	local suit_icon_big_x
	local text_icon_big_y
	local text_icon_big_x

	local suit_icon_little_y
	local suit_icon_little_x
	local text_icon_little_y
	local text_icon_little_x

	local draw_big_suit_icon = false

	if angle ~= nil and angle ~= 0 and angle ~= 90 and angle ~= 180 and angle ~= 270 then
		error(string.format("draw_card for angle %s not supported", angle), 2)
	end

	if angle == 0 or angle == nil then
		suit_icon_big_y = y + width*0.1
		suit_icon_big_x = x + math.floor(width*(1-0.45)/2)
		text_icon_big_y = y + 0.9*height
		text_icon_big_x = x + 0.5*width

		suit_icon_little_y = y + small_padding
		suit_icon_little_x = x + math.floor(width*0.5)
		text_icon_little_y = y + math.floor(width*0.35)
		text_icon_little_x = x + math.floor(width*0.1)
	elseif angle == 90 then
		suit_icon_big_y = y + math.floor(width*(1-0.45)/2)
		suit_icon_big_x = x - height*0.1
		text_icon_big_y = y + 0.7*width
		text_icon_big_x = x - 0.8*height

		suit_icon_little_y = y + math.floor(width*0.5)
		suit_icon_little_x = x - small_padding
		text_icon_little_y = y + math.floor(width*0.35)
		text_icon_little_x = x - math.floor(width*0.35)
	elseif angle == 180 then
		suit_icon_big_y = y - width*0.1
		suit_icon_big_x = x - math.floor(width*(1 - 0.45)/2)
		text_icon_big_y = y - 0.6*height
		text_icon_big_x = x - 0.5*width

		suit_icon_little_y = y - small_padding
		suit_icon_little_x = x - math.floor(width*0.5)
		text_icon_little_y = y - math.floor(width*0.1)
		text_icon_little_x = x - math.floor(width*0.35)
	elseif angle == 270 then
		suit_icon_big_y = y - math.floor(width*(1-0.45)/2)
		suit_icon_big_x = x + height*0.1
		text_icon_big_y = y - 0.3*width
		text_icon_big_x = x + 0.8*height

		suit_icon_little_y = y - math.floor(width*0.5)
		suit_icon_little_x = x + small_padding
		text_icon_little_y = y - math.floor(width*0.1)
		text_icon_little_x = x + math.floor(width*0.1)
	end

	text_icon_big_y = math.floor(text_icon_big_y)
	text_icon_big_x = math.floor(text_icon_big_x)
	suit_icon_big_y = math.floor(suit_icon_big_y)
	suit_icon_big_x = math.floor(suit_icon_big_x)

	
	if angle ~= nil and angle ~= 0 then
		draw_more.draw_graphic_ul("card_blank", y, x, width, height, { angle_degrees = angle });
	else
		alex_c_api.draw_rect(blank_card_colour, y, x, y + height, x + width)
		draw_shapes.draw_rect_outline(card_outline, card_outline_thickness, y, x, y + height, x + width)
	end

	-- TODO clean this up, make sure it looks good for small cards (card sim, crib)
	-- maybe have the option to display either type of card
	-- maybe now is the time to refactor this to take in a table of size params,
	-- rather than a ton of integer arguments
	if not draw_big_suit_icon then
		-- TODO adjust the position for rotation here
		draw_more.draw_graphic_ul(suits_to_graphic[card.suit],
		                        suit_icon_little_y, suit_icon_little_x,
		                        math.floor(width/2) - small_padding,
		                        math.floor(1.2*width/2) - small_padding,
		                        { angle_degrees = angle , brightness_percent = brightness_percent_suit_icon})
		alex_c_api.draw_text(cards.val_to_string(card.val), suits_to_text_colour[card.suit],
		                     text_icon_little_y, text_icon_little_x,
		                     font_size_small, ALIGN_LEFT, angle)
	else
		draw_more.draw_graphic_ul(suits_to_graphic[card.suit],
		                        suit_icon_big_y, suit_icon_big_x,
		                        suit_icon_big_width, suit_icon_big_height,
		                        { angle_degrees = angle, brightness_percent = brightness_percent_suit_icon})
	end
	alex_c_api.draw_text(cards.val_to_string(card.val), suits_to_text_colour[card.suit],
	                     text_icon_big_y, text_icon_big_x, font_size, ALIGN_CENTRE, angle)

	if alex_c_api.get_user_colour_pref() == "dark" then
		alex_c_api.draw_rect(DARK_OVERLAY_COLOUR_CARD_FACE,
		                     y, x,
		                     y + height, x + width)
	end
	if highlight then
		local padding = math.floor(math.max(height*0.05, width*0.05))
		draw_more.draw_graphic_ul("card_highlight",
		                        y - padding, x - padding,
		                        width + 2*padding, height + 2*padding,
		                        { angle_degrees = angle })
	end
end

function cards_draw.draw_card_array(card_array, y_centre, x_centre, width, height, font_size, highlight, padding, offset_array)
	if #card_array > 0 and offset_ary ~= nil and #offset_array ~= #card_array then
		error(string.format("offset_ary len %d, card_array len %d", #offset_ary, #card_array))
	end

	for card_idx=1,#card_array do
		local y = math.floor(y_centre - height/2)
		if offset_array ~= nil then
			y = y + offset_array[card_idx]
		end
		local x = (x_centre - width/2) + math.floor(((card_idx-0.5 - #card_array/2))*(width + padding))
		cards_draw.draw_card(card_array[card_idx], y, x, width, height, font_size, highlight ~= nil and highlight[card_idx], 0)
	end
end

function cards_draw.draw_card_array_facedown(count, y_centre, x_centre, width, height, highlight, padding, offset_array)
	for card_idx=1,count do
		local y = math.floor(y_centre - height/2)
		if offset_array ~= nil then
			y = y + offset_array[card_idx]
		end
		local x = (x_centre - width/2) + math.floor(((card_idx-0.5 - count/2))*(width + padding))
		cards_draw.draw_facedown_card(y, x, width, height, highlight, 0)
	end
end

function cards_draw.card_array_coords_to_idx(count, y_centre, x_centre,
                                             width, height, padding,
                                             offset_array,
                                             coord_y, coord_x)
	local x_start = (x_centre - width/2) + math.floor(((0      -0.5 - count/2))*(width + padding))
	local x_end   = (x_centre - width/2) + math.floor(((count+1-0.5 - count/2))*(width + padding))
	if x_start <= coord_x and coord_x <= x_end then
		local idx = math.floor((coord_x - x_start) / (width + padding))
		if not(1 <= idx and idx <= count) then
			return nil
		end
		local y_start = math.floor(y_centre - height/2)
		local y_end   = math.floor(y_centre + height/2)
		if offset_ary ~= nil then
			y_start = y_start + offset_array[idx]
			y_end   = y_end   + offset_array[idx]
		end
		if y_start <= coord_y and coord_y <= y_end then
			local pos_within_card = (coord_x - x_start) % (width + padding)
			if pos_within_card <= width then
				return idx
			end
		end
	end

	return nil
end

return cards_draw
local cards_set = {}

local cards = require("libs/cards/cards")

function cards_set.card_list_to_set(card_list)
	local card_set = {
		suits = {},
		list = card_list,
	}
	for _, suit in ipairs(cards.suits) do
		card_set.suits[suit] = {}
	end

	for _, card in ipairs(card_list) do
		card_set.suits[card.suit][card.val] = true
	end

	return card_set
end
local combinations = {}

local utils = require("libs/utils")

-- Loops through every combination of possible combinations
-- of elements in the input, where order does not matter
--
-- It is like looping through binary:
--     0 0 0 1
--     0 0 1 0
--     0 0 1 1
--     0 1 0 0
--     0 1 0 1
--     0 1 1 0
--     0 1 1 1
--     ... etc
function combinations.get_combos(ary)
	
	local chosen = {}
	for i=1,#ary do
		chosen[i] = false
	end


	local to_return_combos = {}
	-- loop through all combinations of cards, like counting in binary:
	-- 0 0 0 0
	-- 0 0 0 1
	-- 0 0 1 0
	-- 0 0 1 1
	-- 0 1 0 0
	-- ...
	-- io.write(string.format("starting loop... %d %d\n", #ary, #chosen))
	while true do
		--[[
		local chosen_copy = {}
		for idx,val in ipairs(chosen) do
			chosen_copy[idx] = val
		end
		table.insert(to_return_combos, chosen_copy)
		]]
		local combo = {}
		for idx,val in ipairs(chosen) do
			if val then
				table.insert(combo, ary[idx])
			end
		end
		table.insert(to_return_combos, combo)

		local i = 1
		while i <= #ary and chosen[i] do
			chosen[i] = false
			i = i + 1
		end
		if i > #ary then
			goto end_loop
		else
			chosen[i] = true
		end
	end
	::end_loop::
	return to_return_combos
end

local function sum(ary)
	local val = 0
	for _, elem in ipairs(ary) do
		val = val + elem
	end
	return val
end

-- Given an array of values e.g. {a, b, c}
-- Returns every distinct sum and the pieces that make it up, e.g.:
-- {
--     { val = a,     parts = {a}       },
--     { val = a+b,   parts = {a, b}    },
--     { val = a+b+c, parts = {a, b, c} },
--     { val = a+c,   parts = {a, c}    },
--     -- Note that any duplicate sums (say if a == b) would only be included once
-- }
function combinations.get_distinct_sums(ary)
	local sums_map = {}
	local combos = combinations.get_combos(ary)
	for _, vals in ipairs(combos) do
		-- skip any combinations with zero in them, so that the "selected indexes" (`parts`) will
		-- not contain unused values
		if utils.any_eq(vals, 0) then
			goto next_val_combo
		end
		local sum_val = sum(vals)
		sums_map[sum_val] = vals
		::next_val_combo::
	end

	local distinct_sums = {}
	for sum_val, parts in pairs(sums_map) do
		table.insert(distinct_sums, { val = sum_val, parts = parts })
	end

	return distinct_sums
end

return combinations

local dice = {}

function dice.roll_dice(dice_max)
	return math.random(1,dice_max)
end

function dice.roll_multiple_dice(num_dice, dice_max)
	local ary = {}
	for i=1,num_dice do
		table.insert(ary, dice.roll_dice(dice_max))
	end
	return ary
end

return dice
local dice_draw = {}

local alex_c_api = require("alex_c_api")
local draw_more  = require("libs/draw/draw_more")

local DICE_IMG_MAP = {
	"dice1",
	"dice2",
	"dice3",
	"dice4",
	"dice5",
	"dice6",
}

function dice_draw.draw_one_die(die_val, y_pos, x_pos, y_size, x_size, idx, args)
	if args ~= nil and args.background_colour ~= nil then
		alex_c_api.draw_rect(args.background_colour,
		                     y_pos, x_pos,
		                     y_pos + y_size, x_pos + x_size)
	end
	local img_id = DICE_IMG_MAP[die_val]
	local graphic_params = nil
	if args ~= nil then
		graphic_params = {
			brightness_percent = args.brightness_percent,
			invert             = args.invert
		}
	end
	draw_more.draw_graphic_ul(img_id, y_pos, x_pos, x_size, y_size, graphic_params)
	if args.used_dice ~= nil and args.used_dice[idx] then
		if args.dice_used_overlay_colour == nil then
			error("args.dice_used_overlay_colour is nil, but args.used_dice is specified", 2)
		end
		alex_c_api.draw_rect(args.dice_used_overlay_colour, y_pos, x_pos, y_pos + y_size, x_pos + x_size)
	end
end

function dice_draw.draw_dice(dice_vals, y_pos, x_pos, y_size, x_size, args)
	for dice_idx, dice_val in ipairs(dice_vals) do
		x_pos2 = x_pos + (dice_idx-1)*x_size
		if args ~= nil and args.padding ~= nil then
			x_pos2 = x_pos2 + (dice_idx-1)*args.padding
		end
		dice_draw.draw_one_die(dice_val, y_pos, x_pos2, y_size, x_size, dice_idx, args)
	end
end

return dice_draw

local draw_celebration_anim = {}

local alex_c_api = require("alex_c_api")

local function get_random_fireworks_colour(is_fill)
	local fills = {
		"#fd7678",
		"#76fd78",
		"#7676fd",
		"#fd76fd",
		"#fdfd76",
		"#76fdfd",
		"#fdfdfd",
	}
	return fills[math.random(1,#fills)]
end

local function get_brightness_func(state, particle)
	local brightness = 255
	local time_threshold = state.params.anim_time*0.3
	if state.t >= time_threshold then
		brightness = math.floor(brightness*(state.params.anim_time - state.t)/(state.params.anim_time - time_threshold))
	end

	if brightness < 0 then return 0 end
	return brightness
end

local function firework_explosion(state, params)
	for i=1,params.particle_count do
		local angle = i*2*math.pi / params.particle_count
		local update_pos_func = function (state, particle, dt)
			local speed = (1 - state.t/params.anim_time + 0.2) * params.init_speed
			local y_vel = math.cos(angle + state.params.rotation) * speed
			local x_vel = math.sin(angle + state.params.rotation) * speed
			particle.y_vel_lost_due_to_gravity = particle.y_vel_lost_due_to_gravity + state.gravity * dt
			particle.vel_lost_due_to_drag = particle.vel_lost_due_to_drag + state.params.drag * dt
			y_vel = y_vel + particle.y_vel_lost_due_to_gravity
			y_vel = y_vel / particle.vel_lost_due_to_drag
			x_vel = x_vel / particle.vel_lost_due_to_drag
			local dy = y_vel * dt
			local dx = x_vel * dt
			particle.y = particle.y + dy
			particle.x = particle.x + dx

			if state.frame_idx % state.params.line_update_frame_interval == 0 and state.frame_idx ~= 0 then
				local line_info = {
					y1 = particle.prev_snapshot_pos.y,
					x1 = particle.prev_snapshot_pos.x,
					y2 = particle.y,
					x2 = particle.x,
					colour = state.params.colour_fill,
				}
				table.insert(particle.lines, line_info)
				while #particle.lines >= state.params.max_lines_per_particle do
					table.remove(particle.lines, 1)
				end
				particle.prev_snapshot_pos = { y = particle.y, x = particle.x }
			end
			
		end
		table.insert(state.particles, {
			update_pos_func = update_pos_func,
			y = params.start_y,
			x = params.start_x,
			get_brightness_func = get_brightness_func,
			radius = params.particle_radius,
			centre_radius = params.centre_radius,

			y_vel_lost_due_to_gravity = 0,
			vel_lost_due_to_drag = 0,
			angle = angle,


			lines = {},
			prev_snapshot_pos = { y = params.start_y, x = params.start_x },
		})
	end
end

local function get_line_colour(state, particle, idx, colour)
	--idx = state.params.max_lines_per_particle - idx + 1
	local brightness = particle.get_brightness_func(state, particle)
	local threshold_idx = state.params.line_brightness_threshold_idx
	if idx < threshold_idx then
		brightness = math.floor(brightness*(idx)/(threshold_idx))
	end
	return string.format("%s%02x", colour, brightness)
end

local function draw_firework_state(state)

	for _, particle in ipairs(state.particles) do
		for line_segment_idx, line_info in ipairs(particle.lines) do
			--print(string.format("line_info: %s %s %s %s", line_info.y1, line_info.x1, line_info.y2, line_info.x2))
			alex_c_api.draw_line(get_line_colour(state, particle, line_segment_idx, line_info.colour), state.params.line_width,
			                     line_info.y1, line_info.x1,
			                     line_info.y2, line_info.x2)
		end


		local start = {
			y = state.params.start_y,
			x = state.params.start_x,
		}
		if #particle.lines > 0 then
			start.y = particle.lines[#particle.lines].y1
			start.x = particle.lines[#particle.lines].x1
		end

		alex_c_api.draw_line(get_line_colour(state, particle, #particle.lines, state.params.colour_fill), state.params.line_width,
		                     start.y, start.x,
		                     particle.y, particle.x)


		--[[
		alex_c_api.draw_circle(state.params.colour_fill,
		                       state.params.colour_outline,
		                       particle.y, particle.x,
		                       state.params.particle_radius)
		alex_c_api.draw_circle(state.params.fill_centre,
		                       state.colour_outline,
		                       particle.y, particle.x,
		                       state.params.centre_radius)
		--]]
	end
end



function draw_celebration_anim.new_fireworks_state(params)
	local update_state_func = function (state, dt)
		if dt == 0 then return end
		--print("update_state_func: firework")

		if state.time_to_explosion <= 0 then
			if not state.detonated then
				firework_explosion(state, params)
				state.detonated = true
			end
			if state.time_remaining > 0 then
				state.t = state.t + dt
				state.frame_idx = state.frame_idx + 1
				state.time_remaining = state.time_remaining - dt

				for _, particle in ipairs(state.particles) do
					particle.update_pos_func(state, particle, dt)
				end
			else
				state.particles = {}
			end
		else
			state.time_to_explosion = state.time_to_explosion - dt
		end
	end
	local state = {
		params = params,
		detonated = false,
		time_to_explosion = params.time_to_explosion,
		gravity = params.gravity,
		lines = {},
		particles = {},
		update_state_func = update_state_func,
		draw = draw_firework_state,

		time_remaining = params.anim_time,
		colour_outline = params.colour_outline,
		t = 0,
		frame_idx = 0,
		on_finish = params.on_finish,
	}
	return state
end

function draw_celebration_anim.update_anim(state, dt)
	state.update_state_func(state, dt)
end

function draw_celebration_anim.new_state(params)
	local anim_state = {
		anims = {},
		on_finish = params.on_finish
	}
	return anim_state
end

function draw_celebration_anim.fireworks_display(anim_state, params)
	local max_anim_time = nil
	for i=1,20 do
		local size = math.random(3, 15)
		local anim_time = 1 + (3-1)*math.random()
		local firework_state = draw_celebration_anim.new_fireworks_state({
			--start_y = 240,
			--start_x = 240,
			start_y = math.random(20, 480-100),
			start_x = math.random(20, 480-100),
			gravity = 50,
			drag    = 0.9,
			init_speed = size,
			--time_to_explosion = math.random(0, 1),
			time_to_explosion = math.random(),
		
			--line_width = math.random(1,math.max(1,math.floor(size/50*5))),
			line_width = 2,
		
			particle_count = math.max(math.min(size,20),6),
			--particle_color = "#ffeeee",
			--particle_fill  = "#ffeeee",
			--colour_fill    = "#fd7678",
			colour_fill = get_random_fireworks_colour(),
			rotation = math.random()*2*math.pi,
			colour_outline = "#ffffff00",
			colour_fill_centre = "ffffff",
			fill_centre    = "#ffffff",
			--radius = 0.1 + math.random(0, 400),
			anim_time = anim_time,
			--anim_time = 0.5 + 1.0*math.random(),
		
			centre_radius   = 1,
			particle_radius = 5,
			max_lines_per_particle = 20,
			line_brightness_threshold_idx = 3,
			line_update_frame_interval = 5,

		})
		if max_anim_time == nil or max_anim_time < anim_time then
			max_anim_time = anim_time
		end
		table.insert(anim_state.anims, firework_state)
	end

	-- TODO I don't really like this ...
	-- the fireworks animation is actually animated separately per firework.
	-- I want a callback when they all finish.
	-- But I want a new callback for each fireworks animation.
	-- Perhaps it would make sense to add a single big "multiple fireworks" anim,
	-- which itself loops through each individual firework.
	if params ~= nil and params.on_finish ~= nil then
		anim_state.on_finish = params.on_finish
	end

	-- it's hard to see the light fireworks on a light screen, so add
	-- a black backdrop that fades away
	local colour_pref
	if params ~= nil then
		colour_pref = params.colour_pref
	end
	if colour_pref == nil then
		colour_pref = alex_c_api.get_user_colour_pref()
	end
	if not colour_pref or colour_pref == "light" then
		local backdrop_state = {
			anim_time = max_anim_time,
			time_remaining = max_anim_time,
			update_state_func = function (anim_state, dt)
				anim_state.time_remaining = anim_state.time_remaining - dt
				local threshold = anim_state.anim_time/2
				local init_brightness = 196
				anim_state.brightness = init_brightness
				if anim_state.time_remaining < threshold then
					anim_state.brightness = math.floor(init_brightness * (1 - (threshold - anim_state.time_remaining)/(anim_state.anim_time - threshold)))
				end
			end,
			draw = function (anim_state)
				local colour = string.format('#000000%02x', anim_state.brightness)
				alex_c_api.draw_rect(colour, 0, 0, 480, 480)
			end,
	
			brightness = 100,
		}
		table.insert(anim_state.anims, 1, backdrop_state)
	end
end

function draw_celebration_anim.draw(anim_state)
	for _, anim in ipairs(anim_state.anims) do
		anim.draw(anim)
	end
end

-- TODO change this to accept dt_ms
function draw_celebration_anim.update(anim_state, dt)
	--print(string.format("draw_celebration_anim.update called, %d anims", #anim_state.anims))

	if #anim_state.anims == 0 then
		return
	end

	for _, anim in ipairs(anim_state.anims) do
		anim.update_state_func(anim, dt)
	end

	local i = 1
	while i <= #anim_state.anims do
		--print("anim %d, time_remaining is: %s", i, anim_state.anims[i].time_remaining)
		if anim_state.anims[i].time_remaining <= 0 then
			print("anim finished", i)
			table.remove(anim_state.anims, i)
		else
			i = i + 1
		end
	end

	print(string.format("anim_state.anims remaining: %d", #anim_state.anims))
	if #anim_state.anims == 0 then
		print("anims finished")
		if anim_state.on_finish then
			print("calling anims finished")
			anim_state.on_finish()
		end

	end
end


return draw_celebration_anim
local draw_colours = {}

-- highlight is bright yellow, useful for a "can click here" move
-- alt highlight is blue (useful for highlighting a selected piece, where the
--                        yellow highlight is used to show possible destinations)
--
-- "..._remote" variants are for network multiplayer, to show what the
-- other player is doing.

draw_colours.HIGHLIGHT_OUTLINE            = '#ffff44'
draw_colours.HIGHLIGHT_FILL               = '#ffff9966'

draw_colours.ALT_HIGHLIGHT_OUTLINE        = '#00ffff'
draw_colours.ALT_HIGHLIGHT_FILL           = '#00ffff88'

draw_colours.HIGHLIGHT_OUTLINE_REMOTE     = '#88885588'
draw_colours.HIGHLIGHT_FILL_REMOTE        = '#ffffcc88'

draw_colours.ALT_HIGHLIGHT_OUTLINE_REMOTE = '#88cccc88'
draw_colours.ALT_HIGHLIGHT_FILL_REMOTE    = '#88cccc88'


return draw_colours
local draw_keyboard = {}

local alex_c_api = require("alex_c_api")

local KEYS = {
	"qwertyuiop",
	"asdfghjkl",
	"zxcvbnm",
}

local padding = 5

draw_keyboard.SPECIAL_KEY_ENTER = "Enter"
draw_keyboard.SPECIAL_KEY_BKSP  = "Backspace"

local SPECIAL_KEYS = {
	{ idx = draw_keyboard.SPECIAL_KEY_ENTER, text = "Enter" },
	{ idx = draw_keyboard.SPECIAL_KEY_BKSP,  text = "<" },
}

local function get_key_params(kb_params)
	local key_params = {
		y_start    = kb_params.y_start,
		x_start    = kb_params.x_start,
		y_end      = kb_params.y_end,
		x_end      = kb_params.x_end,
		padding    = padding,
		key_height = math.floor((kb_params.y_end - kb_params.y_start) / #KEYS) - padding,
		key_width  = math.floor((kb_params.x_end - kb_params.x_start) / #KEYS[1]) - padding,
		offsets    = { 0, 0.5, 1.5 },
	}
	key_params.text_size = math.floor(0.7*math.min(key_params.key_height, key_params.key_width))
	return key_params
end

local function get_key_pos(params, row_idx, col_idx, special_idx)

	if special_idx == draw_keyboard.SPECIAL_KEY_ENTER then
		local pos = {
			y_start = params.y_start + 2 * (params.key_height + params.padding),
			x_start = params.x_start + padding/2,
		}
		pos.y_end = pos.y_start + params.key_height
		pos.x_end = pos.x_start + 1.5 * params.key_width
		local text_padding = 1
		--pos.text_size = math.min(math.floor(((pos.x_end - pos.x_start) - 2*text_padding)/5),
		--                         math.floor( (pos.y_end - pos.y_start) - 2*text_padding))
		pos.text_size = 16
		pos.text_y = pos.y_start + params.key_height/2 + pos.text_size/2
		pos.text_x = pos.x_start + (pos.x_end - pos.x_start)/2
		return pos
	elseif special_idx == draw_keyboard.SPECIAL_KEY_BKSP then
		local pos = {
			y_start = params.y_start + 2 * (params.key_height + params.padding),
			x_start = params.y_end - 1.5 * params.key_width - 3/2*padding
		}
		pos.y_end = pos.y_start + params.key_height
		pos.x_end = pos.x_start + 1.5 * params.key_width
		pos.text_size = params.text_size
		pos.text_y = pos.y_start + params.key_height/2 + pos.text_size/2
		pos.text_x = pos.x_start + (pos.x_end - pos.x_start)/2
		return pos
	end

	local pos = {
		y_start = params.y_start + (row_idx-1) * (params.key_height + params.padding),
		x_start = params.x_start + (col_idx-1 + params.offsets[row_idx]) * (params.key_width  + params.padding),
	}
	pos.y_end = pos.y_start + params.key_height
	pos.x_end = pos.x_start + params.key_width

	pos.text_y = pos.y_start + (params.key_height/2) + params.text_size/2
	pos.text_x = pos.x_start + params.key_width/2
	return pos
end

function draw_keyboard.get_key_pressed(kb_params, y_pos, x_pos)
	local key_params = get_key_params(kb_params)
	-- TODO this isn't very efficient, but it's
	-- easier to implement in case I change this later.
	-- And there shouldn't be so many touches that
	-- looping through ~26 keys is significant
	for row_idx, row in ipairs(KEYS) do
		for col_idx=1,#row do
			local key = row:sub(col_idx,col_idx)
			local pos = get_key_pos(key_params, row_idx, col_idx)
			--print(string.format("%2d %2d %s", row_idx, col_idx, key))
			if pos.y_start <= y_pos and y_pos <= pos.y_end and
			   pos.x_start <= x_pos and x_pos <= pos.x_end then
				return key
			end
		end
	end

	for _, info in ipairs(SPECIAL_KEYS) do
		local pos = get_key_pos(key_params, nil, nil, info.idx)
		if pos.y_start <= y_pos and y_pos <= pos.y_end and
		   pos.x_start <= x_pos and x_pos <= pos.x_end then
			return info.idx
		end
	end
	return nil
end

function draw_keyboard.draw_keyboard(kb_params)
	local key_params = get_key_params(kb_params)


	for row_idx, row in ipairs(KEYS) do
		for col_idx=1,#row do
			local char = row:sub(col_idx,col_idx)
			local pos = get_key_pos(key_params, row_idx, col_idx)
			local bg_colour = kb_params.key_bg_colours[char]
			local fg_colour = kb_params.key_fg_colours[char]
			if bg_colour == nil then bg_colour = kb_params.key_bg_colour_default end
			if fg_colour == nil then fg_colour = kb_params.key_fg_colour_default end
			
			alex_c_api.draw_rect(bg_colour,
			                     pos.y_start, pos.x_start,
			                     pos.y_end,   pos.x_end)
			alex_c_api.draw_text(string.upper(char), fg_colour,
			                     pos.text_y, pos.text_x,
			                     key_params.text_size,
			                     alex_c_api.TEXT_ALIGN_CENTRE)
		end
	end


	for _, key_info in ipairs(SPECIAL_KEYS) do
		local pos = get_key_pos(key_params, nil, nil, key_info.idx)
			alex_c_api.draw_rect(kb_params.key_bg_colour_default,
			                     pos.y_start, pos.x_start,
			                     pos.y_end,   pos.x_end)
			alex_c_api.draw_text(key_info.text, '#888888',
			                     pos.text_y, pos.text_x,
			                     pos.text_size,
			                     alex_c_api.TEXT_ALIGN_CENTRE)

	end
end

return draw_keyboard
local draw_more = {}

local alex_c_api = require("alex_c_api")

-- Same as alex_c_api.draw_graphic, but the position is
-- from the top left instead of the centre.
--
-- Originally alex_c_api.draw_graphic(...) worked this way, but I changed it
-- when adding support for rotation of angles besides 0, 90, 180, 270.
-- So this API is provided to help convert the older games.
function draw_more.draw_graphic_ul(img_id,
                                   y, x, width, height, params)
	local y_rot_offset = height/2
	local x_rot_offset = width/2
	if params ~= nil and params.angle_degrees ~= nil and params.angle_degrees ~= 0 then
		y_rot_offset = height/2*math.cos(params.angle_degrees/180*math.pi) + width/2*math.sin(params.angle_degrees/180*math.pi)
		x_rot_offset = width/2*math.cos(params.angle_degrees/180*math.pi) - height/2*math.sin(params.angle_degrees/180*math.pi)
	end
	return alex_c_api.draw_graphic(img_id,
	                               math.floor(y + y_rot_offset),
	                               math.floor(x + x_rot_offset),
	                               width,
	                               height,
	                               params)
end

-- Converts between the old draw_graphic_ul (draws with y,x in upper left of graphic) points
-- to true y and x position after rotating.
-- Only works for multiples of 90 degrees. Kind of a hack.
--
-- The reason for this is that draw_graphic_ul handles rotation about the top left,
-- and draw_rect has no concept of rotation. So if you want to draw a rectangle over
-- a graphic, this function handles the conversion.
function draw_more.get_rotated_pts_ul(y, x, width, height, angle_degrees)
	if angle_degrees == nil then
		angle_degrees = 0
	end
	local y2
	local x2
	if angle_degrees == 0 then
		y2 = y
		x2 = x
	elseif angle_degrees == 90 then
		y2 = y
		x2 = x - height
	elseif angle_degrees == 180 then
		y2 = y - height
		x2 = x - width
	elseif angle_degrees == 270 then
		y2 = y - width
		x2 = x
	else
		error(string.format("get_rotated_pts_ul only supports angles multiple of 90, received %s", angle_degrees))
	end
	
	local width2
	local height2
	if angle_degrees == 90 or angle_degrees == 270 then
		width2  = height
		height2 = width
	elseif angle_degrees == 0 or angle_degrees == 180 then
		width2  = width
		height2 = height
	else
		error(string.format("get_rotated_pts_ul only supports angles multiple of 90, received %s", angle_degrees))
	end

	return {
		y = y2,
		x = x2,
		height = height2,
		width  = width2,
	}
	
end


function draw_more.draw_dashed_line(colour, thickness, duty_cycle, step, y1, x1, y2, x2)
	-- NOTE: this is likely terribly inefficient compared to one of the native HTML "draw dashed line"
	--       methods. It calls the "draw line" function separately for each segment, doing some math.
	--       The only benefit is that a new C API to draw dashed lines isn't needed.
	--       In an ideal world, this could check if an optimized C API exists, and if not, fallback to this
	--       Lua implementation.
	--
	local dy = y2 - y1
	local dx = x2 - x1

	-- TODO: this also doesn't work for vertical lines. I think there is some nifty trick
	-- like swapping dy and dx or something
	-- using trigonometry seems like a waste
	if dx == 0 then
		error("vertical dashed lines not supported yet", 2)
	end

	local line_slope = dy/dx
	local line_len = math.sqrt(dy*dy + dx*dx)

	if step == nil then
		step = 10
	end

	if duty_cycle == nil then
		duty_cycle = 0.5
	end

	local piece_y = y1
	local piece_x = x1
	for i=0,line_len,step do
		local piece_dy = dx*line_slope/line_len*step
		local piece_dx = dx/line_len*step

		local piece_y2 = math.floor(piece_y + piece_dy*duty_cycle)
		local piece_x2 = math.floor(piece_x + piece_dx*duty_cycle)
		alex_c_api.draw_line(colour, thickness,
		                     piece_y, piece_x,
		                     piece_y2, piece_x2)
		piece_y = math.floor(piece_y + piece_dy)
		piece_x = math.floor(piece_x + piece_dx)
	end
end

return draw_more

local draw_shapes = {}
local alex_c_api = require("alex_c_api")

function draw_shapes.draw_rect_outline(colour, line_width, y1, x1, y2, x2)
	alex_c_api.draw_line(colour, line_width, y1, x1, y1, x2)
	alex_c_api.draw_line(colour, line_width, y1, x1, y2, x1)
	alex_c_api.draw_line(colour, line_width, y2, x2, y1, x2)
	alex_c_api.draw_line(colour, line_width, y2, x2, y2, x1)
end

function draw_shapes.draw_triangle_lr(line_colour, line_width, bg_colour, pointing_left, y1, x1, y2, x2)

	local pt1, pt2, pt3
	if pointing_left then
		pt1 = { y = math.floor((y2 + y1)/2), x = x1 }
		pt2 = { y = y1, x = x2 }
		pt3 = { y = y2, x = x2 }
	else
		pt1 = { y = math.floor((y2 + y1)/2), x = x2 }
		pt2 = { y = y1, x = x1 }
		pt3 = { y = y2, x = x1 }
	end

	if bg_colour ~= nil then
		-- TODO this file was written before I added a "fill_triangle" API.
		-- obviously it should use that instead
		alex_c_api.draw_rect(bg_colour, y1, x1, y2, x2)
	end

	if line_colour ~= nil then
		alex_c_api.draw_line(line_colour, line_width, pt1.y, pt1.x, pt2.y, pt2.x)
		alex_c_api.draw_line(line_colour, line_width, pt2.y, pt2.x, pt3.y, pt3.x)
		alex_c_api.draw_line(line_colour, line_width, pt3.y, pt3.x, pt1.y, pt1.x)
	end
end

function draw_shapes.draw_triangle_outline(line_colour, line_width,
                                           y1, x1,
                                           y2, x2,
                                           y3, x3)
	alex_c_api.draw_line(line_colour, line_width, y1, x1, y2, x2)
	alex_c_api.draw_line(line_colour, line_width, y2, x2, y3, x3)
	alex_c_api.draw_line(line_colour, line_width, y3, x3, y1, x1)
end

return draw_shapes
local letter_tiles = {}

-- TODO:
--   * tear out a bunch of the way moving tiles works (maybe save it in a branch first)
--      * need to distinguish between "floating in row" and "floating in grid"
--   * change it so that when you pick up a tile from the row or grid, it sets the row or grid's value to 0
--   * held tile has metadata of where it came from
--
-- Then things should be a lot cleaner. It should only take an hour or so.
-- Then:
--   * implement "submit" button:
--       * check if placed tiles are in a line, with no gaps
--       * check if placed tiles form a valid word... that's it!
--   * maybe implement a "reset" button
--   * show a "tap to reveal next player's tiles" for local multiplayer
--   * serialize and save state in state browser, only when words are successfully placed.

local alex_c_api = require("alex_c_api")

local draw_shapes = require("libs/draw/draw_shapes")

letter_tiles.GROUP_TYPE_ROW  = 1
letter_tiles.GROUP_TYPE_GRID = 2

letter_tiles.LETTER_EMPTY = 0

function letter_tiles.draw_piece(letter, y, x, params, more_params)
	if letter == letter_tiles.LETTER_EMPTY then return end

	local y_start = y - params.size/2
	local x_start = x - params.size/2
	local y_end   = y + params.size/2
	local x_end   = x + params.size/2
	alex_c_api.draw_rect(params.background_colour,
	                     y_start, x_start,
	                     y_end,   x_end)

	draw_shapes.draw_rect_outline(params.outline_colour, params.line_width,
	                              y_start, x_start,
	                              y_end,   x_end)

	alex_c_api.draw_text(letter, params.text_colour,
	                     y + params.main_text_size/2, x,
	                     params.main_text_size,
	                     alex_c_api.TEXT_ALIGN_CENTRE)

	if params.show_score then
		local score_txt = string.format("%2d", params.get_letter_points(letter))
		alex_c_api.draw_text(score_txt, params.text_colour,
		                     y + params.size/2 - params.padding_small, x + params.size/2 - params.padding_small,
		                     params.score_text_size,
		                     alex_c_api.TEXT_ALIGN_RIGHT)
	end

	if more_params and more_params.is_tentative then
		draw_shapes.draw_rect_outline(params.highlight_colour, params.highlight_width,
	                                  y_start, x_start,
	                                  y_end,   x_end)
	end
end

local function get_tile_row_piece_pos(letter_row, i)
	local params = letter_row.params.tile_params
	y = letter_row.pos.y
	x = letter_row.pos.x + math.floor((i-0.5 - #letter_row.letters/2)*(params.size + letter_row.padding))

	return {
		-- centre position (used by draw_tile API)
		y = y,
		x = x,

		-- bound positions (used to check if touch/click is for this particular tile) 
		y_start = y - params.size/2,
		y_end   = y + params.size/2,

		x_start = x - params.size/2,
		x_end   = x + params.size/2,
	}
end

local function snap_pos_eq(snap_pos1, snap_pos2)
	if snap_pos1.group_type ~= snap_pos2.group_type then
		return false
	end

	if snap_pos1.group_type == letter_tiles.GROUP_TYPE_ROW then
		return (snap_pos1.row_idx == snap_pos2.row_idx and
		        snap_pos1.tile_idx == snap_pos2.tile_idx)
	elseif snap_pos1.group_type == letter_tiles.GROUP_TYPE_GRID then
		return (snap_pos1.grid_idx == snap_pos2.grid_idx and
		        snap_pos1.y_idx    == snap_pos2.y_idx and
		        snap_pos1.x_idx    == snap_pos2.x_idx)
	else
		error(string.format("unhandled group type %s", snap_pos1.group_type), 2)
	end

end



local function get_placed_tile_idx(tiles_state, src)
	if tiles_state == nil or tiles_state.placed_tiles == nil then error("placed tiles is nil", 2) end
	for idx, placed_tile_info in ipairs(tiles_state.placed_tiles) do
		if snap_pos_eq(placed_tile_info.pos, src) then
			return idx
		end
	end
end


local function get_letter_at_pos(tiles_state, pos)
	if pos == nil then return nil end
	local placed_tile_idx = get_placed_tile_idx(tiles_state, pos)
	if placed_tile_idx ~= nil then
		return tiles_state.placed_tiles[placed_tile_idx].letter
	elseif pos.group_type == letter_tiles.GROUP_TYPE_ROW then
		return tiles_state.letter_rows[pos.row_idx].letters[pos.tile_idx]
	elseif pos.group_type == letter_tiles.GROUP_TYPE_GRID then
		return tiles_state.grids[pos.grid_idx].tiles[pos.y_idx][pos.x_idx]
	else
		error(string.format("Unrecognized group_type %s", pos.group_type), 2)
	end
end

local function draw_offset(tiles_state, pos)
	if tiles_state.held_letter == nil or
	   (tiles_state.cursor_offset_y == 0 and
	    tiles_state.cursor_offset_y == 0) then
		return
	end

	alex_c_api.draw_line(tiles_state.offset_line_colour, 
	                     tiles_state.offset_line_width, 
	                     pos.y - tiles_state.cursor_offset_y,
	                     pos.x - tiles_state.cursor_offset_x,
	                     pos.y,
	                     pos.x)
	alex_c_api.draw_circle(tiles_state.offset_line_colour_fill, tiles_state.offset_line_colour,
	                       pos.y - tiles_state.cursor_offset_y,
	                       pos.x - tiles_state.cursor_offset_x,
	                       20)
end

function letter_tiles.draw_letter_rows(tiles_state)

	for row_idx, letter_row in ipairs(tiles_state.letter_rows) do
		local params = letter_row.params.tile_params
		for tile_idx, letter in ipairs(letter_row.letters) do
			if letter == letter_tiles.LETTER_EMPTY then
				goto next_letter
			end

			local pos = get_tile_row_piece_pos(letter_row, tile_idx)
			letter_tiles.draw_piece(letter, pos.y, pos.x, params)
			::next_letter::
		end

		if tiles_state.held_letter_snap_pos ~= nil and
		   tiles_state.held_letter_snap_pos.group_type == letter_tiles.GROUP_TYPE_ROW and
		   tiles_state.held_letter_snap_pos.row_idx == row_idx then
			local letter = tiles_state.held_letter
			local pos = tiles_state.held_letter_pos
			print(string.format("drawing held row letter %s at %s %s", letter, pos.y, pos.x))
			letter_tiles.draw_piece(letter, pos.y, pos.x, params)
		end
	end

	if tiles_state.held_letter ~= nil and
	   tiles_state.held_letter_snap_pos.group_type == letter_tiles.GROUP_TYPE_ROW then
		local letter_row = tiles_state.letter_rows[tiles_state.held_letter_snap_pos.row_idx]
		local letter = letter_row.letters[tiles_state.held_letter_snap_pos.tile_idx]
		local params = letter_row.params.tile_params
		local pos = tiles_state.held_letter_pos
		letter_tiles.draw_piece(letter, pos.y, pos.x, params)
		draw_offset(tiles_state, pos)
	end

end

function letter_tiles.get_filled_grid(tiles_state, grid_idx)
	local grid_info = tiles_state.grids[grid_idx]
	local filled_tiles = {}
	for y_idx, row in ipairs(grid_info.tiles) do
		local filled_row = {}
		for x_idx, letter in ipairs(row) do
			local cell = {
				is_tentative = false,
				letter       = letter_tiles.LETTER_EMPTY,
			}
			cell.letter = letter
			table.insert(filled_row, cell)
		end
		table.insert(filled_tiles, filled_row)
	end

	for _, placed_tile in ipairs(tiles_state.placed_tiles) do
		filled_tiles[placed_tile.pos.y_idx][placed_tile.pos.x_idx].letter = placed_tile.letter
		filled_tiles[placed_tile.pos.y_idx][placed_tile.pos.x_idx].is_tentative = true
	end

	return filled_tiles
end

function letter_tiles.draw_grids(tiles_state)
	for grid_idx, grid_info in ipairs(tiles_state.grids) do
		local params = grid_info.tile_params
		local padding = params.padding
		local y_size = letter_tiles.get_grid_y_size(#grid_info.tiles, params)
		local x_size = letter_tiles.get_grid_x_size(#grid_info.tiles[1], params)

		local grid_y_start = letter_tiles.get_grid_cell_pos(grid_info, 1, 1).y_start - padding
		local grid_x_start = letter_tiles.get_grid_cell_pos(grid_info, 1, 1).x_start - padding
		alex_c_api.draw_rect(grid_info.bg_colour,
		                     grid_y_start,          grid_x_start,
		                     grid_y_start + y_size, grid_x_start + x_size)
		for y_idx=1,#grid_info.tiles+1 do
			--local cell_spacing = params.size + params.padding
			--local y_pos = grid_info.y_pos + (y_idx-1) * cell_spacing
			local y_pos 
			if y_idx < #grid_info.tiles+1 then
				y_pos = letter_tiles.get_grid_cell_pos(grid_info, y_idx, 1).y_start - padding/2
			else
				y_pos = letter_tiles.get_grid_cell_pos(grid_info, #grid_info.tiles, 1).y_end
			end
			alex_c_api.draw_line(grid_info.line_colour,
			                     1,
				                 y_pos, grid_info.x_pos - padding,
				                 y_pos, grid_info.x_pos + x_size - padding)
		end
		for x_idx=1,#grid_info.tiles[1]+1 do
			--local cell_spacing = params.size + params.padding
			--local x_pos = grid_info.x_pos + (x_idx-1) * cell_spacing
			--local x_pos = letter_tiles.get_grid_cell_pos(grid_info, 1, x_idx).x_start - padding
			local x_pos 
			if x_idx < #grid_info.tiles[1]+1 then
				x_pos = letter_tiles.get_grid_cell_pos(grid_info, 1, x_idx).x_start - padding/2
			else
				x_pos = letter_tiles.get_grid_cell_pos(grid_info, 1, #grid_info.tiles).x_end
			end
			alex_c_api.draw_line(grid_info.line_colour,
			                     1,
				                 grid_info.y_pos - padding, x_pos,
				                 grid_info.y_pos + y_size - padding,  x_pos)
		end

		for y_idx, row in ipairs(letter_tiles.get_filled_grid(tiles_state, grid_idx)) do
			for x_idx, cell in ipairs(row) do
				if cell.letter ~= letter_tiles.LETTER_EMPTY then
					local pos = letter_tiles.get_grid_cell_pos(grid_info, y_idx, x_idx)
					letter_tiles.draw_piece(cell.letter, pos.y, pos.x, params, cell )
				end
			end
		end

		if tiles_state.held_letter ~= nil and
		   tiles_state.held_letter_snap_pos.group_type == letter_tiles.GROUP_TYPE_GRID and
		   tiles_state.held_letter_snap_pos.grid_idx   == grid_idx then
			local pos_idx = tiles_state.held_letter_snap_pos
			local pos = letter_tiles.get_grid_cell_pos(grid_info, pos_idx.y_idx, pos_idx.x_idx)
			letter_tiles.draw_piece(tiles_state.held_letter, pos.y, pos.x, params)
			draw_offset(tiles_state, pos)
		end
	end
end

function letter_tiles.draw(tiles_state)
	letter_tiles.draw_grids(tiles_state)
	letter_tiles.draw_letter_rows(tiles_state)
end

function letter_tiles.get_grid_y_size(y_count, tile_params)
	return y_count * (tile_params.size + tile_params.padding) -- + tile_params.padding
end

function letter_tiles.get_grid_x_size(x_count, tile_params)
	return x_count * (tile_params.size + tile_params.padding) -- + tile_params.padding
end

local function grid_pos_to_indexes(grid_info, pos)
	local params = grid_info.tile_params
	local y_idx = 1 + math.floor((pos.y - grid_info.y_pos)/(params.size + params.padding))
	local x_idx = 1 + math.floor((pos.x - grid_info.x_pos)/(params.size + params.padding))

	return { y = y_idx, x = x_idx }
end

function letter_tiles.get_grid_cell_pos(grid_info, y_idx, x_idx)
	local params = grid_info.tile_params
	local y_start = grid_info.y_pos + 0*params.padding + (y_idx-1)*(params.size + params.padding)
	local x_start = grid_info.x_pos + 0*params.padding + (x_idx-1)*(params.size + params.padding)

	return {
		y_start = y_start,
		x_start = x_start,

		y_end   = y_start + params.size,
		x_end   = x_start + params.size,

		--y = math.floor(y_start + params.padding/2 + params.size/2),
		--x = math.floor(x_start + params.padding/2 + params.size/2),
		y = math.floor(y_start + params.size/2),
		x = math.floor(x_start + params.size/2),
	}
end

function letter_tiles.new_state(params)
	local tiles_state = {
		letter_rows = {},
		grids       = {},

		-- Tiles that have been placed on the board, but not yet committed.
		placed_tiles = {},

		held_letter     = nil,
		held_letter_pos = nil,
		held_letter_origin = nil,

		cursor_offset_y = 0,
		cursor_offset_x = 0,

		touch_cursor_offset_y = params.touch_cursor_offset_y,
		touch_cursor_offset_x = params.touch_cursor_offset_x,
		offset_line_colour    = '#ff0000',
		offset_line_colour_fill = '#ff000088',
		offset_line_width     = 1,
	}

	return tiles_state
end

function letter_tiles.add_letter_row(tiles_state, letters, pos, params)
	local idx = #tiles_state.letter_rows + 1
	table.insert(tiles_state.letter_rows, {
		padding = 5,
		letters = nil,
		pos     = pos,
		params  = {
			tile_params = params,
		},
	})
	letter_tiles.set_row(tiles_state, idx, letters)
end


function letter_tiles.add_grid(tiles_state, params)
	if params.tile_params == nil then error("params.tile_params is nil", 2) end
	local grid_state = {
		tiles  = {},

		bg_colour   = params.bg_colour,
		line_colour = params.line_colour,
		tile_params = params.tile_params,
		y_pos = params.y_pos,
		x_pos = params.x_pos,

		-- TODO replace y_pos/x_pos above with y_start/x_start?
		y_start = params.y_pos,
		x_start = params.x_pos,
		y_end   = params.y_pos + letter_tiles.get_grid_y_size(params.y_count, params.tile_params),
		x_end   = params.x_pos + letter_tiles.get_grid_x_size(params.y_count, params.tile_params),
	}

	for y=1,params.y_count do
		local row = {}
		for x=1,params.x_count do
			table.insert(row, letter_tiles.LETTER_EMPTY)
		end
		table.insert(grid_state.tiles, row)
	end

	table.insert(tiles_state.grids, grid_state)
end

function letter_tiles.set_grid(tiles_state, grid_idx, grid_arg)
	local grid_info = tiles_state.grids[grid_idx]
	for y=1,#grid_info.tiles do
		for x=1,#grid_info.tiles[1] do
			grid_info.tiles[y][x] = grid_arg[y][x]
		end
	end
end

function letter_tiles.set_row(tiles_state, row_idx, letters)
	local output = "{"
	for _, letter in ipairs(letters) do
		if letter_idx ~= 1 then
			output = output .. ", "
		end
		output = output .. letter
	end
	output = output .. "}"
	print(string.format("letters in row are now: %s", output))

	local letters_copy = {}
	for _, letter in ipairs(letters) do
		table.insert(letters_copy, letter)
	end
		
	tiles_state.letter_rows[row_idx].letters = letters_copy
end

local function within_bounds(pos, bounds)
	return (bounds.y_start <= pos.y and pos.y <= bounds.y_end and
	        bounds.x_start <= pos.x and pos.x <= bounds.x_end)
end

local function get_tile_at_pos(tiles_state, pos, only_row_idx)
	for row_idx, row in ipairs(tiles_state.letter_rows) do
		if only_row_idx ~= nil and row_idx ~= only_row_idx then
			goto next_row_idx
		end
		for tile_idx, letter in ipairs(row.letters) do
			local tile_pos = get_tile_row_piece_pos(row, tile_idx)
			if within_bounds(pos, tile_pos) then
				return { group_type = letter_tiles.GROUP_TYPE_ROW, row_idx = row_idx, tile_idx = tile_idx, letter = letter }
			end
		end
		::next_row_idx::
	end

	for grid_idx, grid_info in ipairs(tiles_state.grids) do
		if within_bounds(pos, grid_info) then
			local indexes = grid_pos_to_indexes(grid_info, pos)
			--local letter = grid_info.tiles[indexes.y][indexes.x]
			--print(string.format("Found tile in grid! %d %d", indexes.y, indexes.x))
			return {
			    group_type = letter_tiles.GROUP_TYPE_GRID,
				grid_idx  = grid_idx,
				y_idx     = indexes.y,
				x_idx     = indexes.x,
				letter    = letter,
			} 
		end
	end

	return nil
end

local function clear_tile(tiles_state, src)
	local placed_tile_idx = get_placed_tile_idx(tiles_state, src)
	if placed_tile_idx ~= nil then
		print(string.format("removing placed tile %d", placed_tile_idx))
		table.remove(tiles_state.placed_tiles, placed_tile_idx)
	elseif src.group_type == letter_tiles.GROUP_TYPE_ROW then
		tiles_state.letter_rows[src.row_idx].letters[src.tile_idx] = letter_tiles.LETTER_EMPTY
	elseif src.group_type == letter_tiles.GROUP_TYPE_GRID then
		tiles_state.grids[src.grid_idx].tiles[src.y_idx][src.x_idx] = letter_tiles.LETTER_EMPTY
	else
		error(string.format("unknown group type %d", src.group_type))
	end
end

function letter_tiles.place_tile(tiles_state, letter, tile_drop_pos)
	if letter == nil then error("letter is nil") end
	if tile_drop_pos.group_type == letter_tiles.GROUP_TYPE_ROW then 
		local row = tiles_state.letter_rows[tile_drop_pos.row_idx]
		row.letters[tile_drop_pos.tile_idx] = letter
		print(string.format("Placed held tile in row %d, tile idx %d", tile_drop_pos.row_idx, tile_drop_pos.tile_idx))
	elseif tile_drop_pos.group_type == letter_tiles.GROUP_TYPE_GRID then 
		table.insert(tiles_state.placed_tiles, {
			letter = letter,
			pos    = tile_drop_pos,
		})
		print(string.format("Placed held tile in grid %d placed tiles, %d %d", tile_drop_pos.grid_idx, tile_drop_pos.y_idx, tile_drop_pos.x_idx))
	end

	tiles_state.held_letter          = nil
	tiles_state.held_letter_origin   = nil
	tiles_state.held_letter_pos      = nil
	tiles_state.held_letter_snap_pos = nil
end

local function snap_pos_to_str(pos_selected)
	if pos_selected.group_type == letter_tiles.GROUP_TYPE_ROW then
		return string.format("{row %d, tile %d}", pos_selected.row_idx, pos_selected.tile_idx)
	elseif pos_selected.group_type == letter_tiles.GROUP_TYPE_GRID then
		return string.format("{grid %d, y:%d, x:%d}", pos_selected.grid_idx, pos_selected.y_idx, pos_selected.x_idx)
	else
		error(string.format("unhandled group type %s", pos_selected.group_type), 2)
	end
end

local function update_offset(tiles_state, params)
	-- TODO make the real handle_mouse_evt pass params too
	if params and params.is_touch then
		tiles_state.cursor_offset_y = tiles_state.touch_cursor_offset_y
		tiles_state.cursor_offset_x = tiles_state.touch_cursor_offset_x
	else
		tiles_state.cursor_offset_y = 0
		tiles_state.cursor_offset_x = 0
	end
end

local function add_offset(tiles_state, pos)
	return {
		y = pos.y + tiles_state.cursor_offset_y,
	    x = pos.x + tiles_state.cursor_offset_x,
	}
end

function letter_tiles.handle_mouse_evt(tiles_state, evt_id, pos_y, pos_x, params)
	update_offset(tiles_state, params)
	local pos = { y = pos_y, x = pos_x }
	--pos = add_offset(tiles_state, pos)
	if evt_id == alex_c_api.MOUSE_EVT_DOWN then
		local pos_selected = get_tile_at_pos(tiles_state, pos)
		local letter = get_letter_at_pos(tiles_state, pos_selected)
		if pos_selected ~= nil and letter ~= nil and letter ~= letter_tiles.LETTER_EMPTY then
			pos_selected.letter = letter
			print(string.format("User clicked on %s", snap_pos_to_str(pos_selected)))
			local letter = get_letter_at_pos(tiles_state, pos_selected)
			local offset_pos = add_offset(tiles_state, pos)
			local offset_pos_selected = get_tile_at_pos(tiles_state, offset_pos)
			if offset_pos_selected == nil then
				offset_pos_selected = pos_selected
			end
			offset_pos_selected.letter = letter -- TODO clean this up, shouldn't need to do this? Or at least make it harder to forget to do
			tiles_state.held_letter_origin = pos_selected
			tiles_state.held_letter_snap_pos = offset_pos_selected
			tiles_state.held_letter_pos = offset_pos
			tiles_state.held_letter = letter

			clear_tile(tiles_state, pos_selected)
		end
	elseif evt_id == alex_c_api.MOUSE_EVT_UP then
		pos = add_offset(tiles_state, pos)
		local tile_drop_pos = get_tile_at_pos(tiles_state, pos)
		if tiles_state.held_letter ~= nil and tiles_state.held_letter ~= letter_tiles.LETTER_EMPTY then

			local dst = tile_drop_pos
			-- check if destination is valid and empty.
			-- if it's not, then put the tile back at its origin.
			if dst == nil or get_letter_at_pos(tiles_state, dst) ~= letter_tiles.LETTER_EMPTY then
				dst = tiles_state.held_letter_origin
			end

			letter_tiles.place_tile(tiles_state, tiles_state.held_letter, dst)
			tiles_state.held_letter_origin = nil
		end
	end
end

local function copy_list(list)
	local new_list = {}
	for _, elem in ipairs(list) do
		table.insert(new_list, elem)
	end
	return new_list
end

local function letter_list_to_str(list)
	local str = "{"
	for i, letter in ipairs(list) do
		if i == 1 then str = str .. ", " end
		str = str .. letter
	end
	return str .. "}"
end

local function get_offset_list(length)
	local offset_list = {}
	for i=1,length do
		table.insert(offset_list, i)
		table.insert(offset_list, -i)
	end
	return offset_list
end

local function find_closest_empty_space_in_row(tiles_state, pos)
	local row = tiles_state.letter_rows[pos.row_idx]
	--for tile_idx, tile_val in ipairs(row.letters) do
	for _, offset in ipairs(get_offset_list(#row.letters)) do
		print(string.format("trying offset %s", offset))
		local tile_idx = pos.tile_idx + offset
		local tile_val = row.letters[tile_idx]
		if tile_val == nil then
			print("tile is nil, next offset...")
			goto next_offset
		end
		print(string.format("tile is %s", tile_val))
		if tile_val == letter_tiles.LETTER_EMPTY then
			return { group_type = letter_tiles.GROUP_TYPE_ROW, row_idx = pos.row_idx, tile_idx = tile_idx }
		end

		::next_offset::
	end

	-- TODO remove this
	error("could not find empty space")
end

local function rearrange_tiles(tiles_state, src_tile_pos, dst_tile_pos)
	if dst_tile_pos.group_type ~= letter_tiles.GROUP_TYPE_ROW then
		error(string.format("rearrange_tiles only supports dst group type ROW, received %s", dst_tile_pos.group_type), 2)
	end

	print(string.format("rearrange_tiles( src %s, dst %s)",
	                    snap_pos_to_str(src_tile_pos),
	                    snap_pos_to_str(dst_tile_pos)))
	if src_tile_pos.group_type ~= letter_tiles.GROUP_TYPE_ROW or src_tile_pos.row_idx ~= dst_tile_pos.row_idx then
		src_tile_pos = find_closest_empty_space_in_row(tiles_state, dst_tile_pos)
		if src_tile_pos == nil then
			error(string.format("Could not find empty space in row %s", dst_tile_pos.row_idx))
		end
	end

	if src_tile_pos.tile_idx == dst_tile_pos.tile_idx then
		return
	end

	local letters = tiles_state.letter_rows[src_tile_pos.row_idx].letters
	--local new_letters = copy_list(letters)
	local new_letters = {}

	local move_src_idx = src_tile_pos.tile_idx
	local move_dst_idx = dst_tile_pos.tile_idx

	local src_idx = 1
	local dst_idx = 1
	while dst_idx <= #letters do
		if dst_idx == move_dst_idx then
			local letter = letters[move_src_idx]
			table.insert(new_letters, letter)
			goto next_dst_idx
		end

		if src_idx == move_src_idx then
			src_idx = src_idx + 1
		end

		
		table.insert(new_letters, letters[src_idx])
		src_idx = src_idx + 1
		::next_dst_idx::
		dst_idx = dst_idx + 1
	end

	assert(#new_letters == #letters)
	
	tiles_state.letter_rows[src_tile_pos.row_idx].letters = new_letters

end

function letter_tiles.handle_mousemove(tiles_state, pos_y, pos_x)
	local pos = { y = pos_y, x = pos_x }
	pos = add_offset(tiles_state, pos)
	if tiles_state.held_letter ~= nil then
		tiles_state.held_letter_pos = pos
		-- see what tile player is hovering their held tile over
		local dst_tile_pos = get_tile_at_pos(tiles_state, pos, tiles_state.held_letter_pos.row_idx)

		if dst_tile_pos then 
			if dst_tile_pos.group_type == letter_tiles.GROUP_TYPE_ROW and
			   get_letter_at_pos(tiles_state, dst_tile_pos) ~= letter_tiles.LETTER_EMPTY then 
				rearrange_tiles(tiles_state, tiles_state.held_letter_snap_pos, dst_tile_pos)
			end
			local letter = tiles_state.held_letter_snap_pos.letter
			tiles_state.held_letter_snap_pos = dst_tile_pos
			tiles_state.held_letter_snap_pos.letter = letter
		end
	end
end


function letter_tiles.get_placed_tiles(tiles_state)
	local placed_tiles_out = {}
	for _, placed_tile in ipairs(tiles_state.placed_tiles) do
		local pt = {
			letter = placed_tile.letter,
			y = placed_tile.pos.y_idx,
			x = placed_tile.pos.x_idx,
		}
		table.insert(placed_tiles_out, pt)
	end
	return placed_tiles_out
end

function letter_tiles.clear_placed_tiles(tiles_state)
	tiles_state.placed_tiles = {}
end

return letter_tiles
--[[
-- This is a simple helper class for games that require exactly two players,
-- optionally supporting local multiplayer, or network multiplayer
-- where it is desirable to allow a player to quit, rejoin later, and even
-- select a different player (perhaps even the player that is already joined).
-- This seems good for strategy games, where there is no hidden information.
-- Though I'm now adding the ability to indicate which player selected their
-- player number first, so that for games with random information (e.g. dice
-- roll), one player can be responsible for rolling the dice.
--
-- e.g. if you are playing go/wu/checkers/chess against someone, but they
-- want to switch devices, or you want to switch devices, they could leave,
-- join on a different device, and then select black or white.
--
-- Things to add in the future:
--     * a spectate option
--]]

local two_player = {}

local alex_c_api = require("alex_c_api")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

-- This message is sent by a player who chooses if they want to be e.g. black or white.
local MSG_HEADER_AM_PLAYER = 'am_player'
local MSG_HEADER_PLAYER_JOINED = 'two_player_player_joined'


two_player.THIS_PLAYER = "You"
two_player.MULTIPLAYER_TYPE_LOCAL   = "local"
two_player.MULTIPLAYER_TYPE_NETWORK = "network"

two_player.PLAYER_CHOICE_POPUP_ID = "two_player_choice_popup"
two_player.MULTIPLAYER_TYPE_POPUP_ID = "two_player_multiplayer_type_popup"

local multiplayer_types_btns = {
	"Local multiplayer (two players on this device)",
	"Network multiplayer (players on different devices)",
}
local multiplayer_type_btn_local   = 0
local multiplayer_type_btn_network = 1

-- "src" argument passed to args.handle_player_choice(src, player_choice) indicating that
-- it is the local player (player using this device to play on), rather than a player
-- over the network
two_player.LOCAL_PLAYER = "_two_player_local_player"

--[[
	args = {
		-- if true, will show a separate popup asking if the user wants to play local
		   multiplayer or play against someone on the network.
		-- if false, will jump straight to waiting for network players
		supports_local_multiplayer = true|false,

		-- multiplayer_type is either:
		--     two_player.MULTIPLAYER_TYPE_LOCAL
		--     two_player.MULTIPLAYER_TYPE_NETWORK
		handle_multiplayer_type_choice = function (multiplayer_type)
		end,
		title   = "Choose piece colour",
		player_choices = { "Black", "White" }
		player_name_to_id,  -- Reference to map of player name/ID to player ID

		-- function returning nice name (e.g. "White" or "Black")
		player_id_to_nice_name = function (player_id)
		end,

		get_msg = function ()
		              local msg = "Black moves first.\n"
		              if state.other_player == nil then
		                  msg = msg .. "The other player has not yet chosen."
		              else
		                  -- "state" here is not visible by this library, it can be whatever
		                  -- the game wants
		                  msg = msg .. "The other player has chosen player_idx_to_colour_name(state.other_player)"
		              end
		              return msg
		end,

		-- src is either:
		--    * two_player.LOCAL_PLAYER if the player choice is from the local player (the one playing on this device), or
		--    * the other player's IP/name if it's from a network player
		-- player_choice: is an integer representing the (1 based) index of args.player_choices
		handle_player_choice = function (src, player_choice)
			-- e.g. update state.other_player or state.this_player,
		end,

		-- returns nil if the local player has not chosen yet,
		-- otherwise sends the index of their choice.
		-- This is used when a new player joins, to tell them the local player's choice.
		get_local_player_choice = function ()
		end,
	 }
--]]

-- TODO maybe create a class for this instead
local g_args  = nil
local g_state = {
	-- TODO currently this tracks the player who selects their piece choice (white/black)
	-- first. But I think it might be better to choose the "host" based on who joined
	-- first. But currently I don't think there is any message sent to this library
	-- when a player joins without selecting a piece? I'm not sure.
	players_join_order = {},
	multiplayer_type_selected = nil,
}

local function need_player_reselect(remote_player)
	local local_player  = g_args.get_local_player_choice()
	--local remote_player = g_args.get_remote_player_choice()

	
	return local_player == nil or local_player == remote_player
end

local function show_player_choice_popup()
	show_buttons_popup.show_popup(two_player.PLAYER_CHOICE_POPUP_ID,
	                              g_args.title,
	                              g_args.get_msg(),
	                              g_args.player_choices)
end

local function show_multiplayer_type_popup()
	show_buttons_popup.show_popup(two_player.MULTIPLAYER_TYPE_POPUP_ID,
	                              "Multiplayer type",
	                              "",
	                              --"Choose to have two players on this device, or to play against someone over the network",
	                              --"Choose either:\n" ..
	                              --"* local multiplayer (two players using the same device), or\n" ..
	                              --"* network multiplayer (one player on this device, another on a separate device)",
	                              multiplayer_types_btns)
	                      
end

function two_player.init(args)
	if args.title == nil then
		error("args.title is nil", 2)
	end
	if args.player_choices == nil then
		error("args.player_choices is nil", 2)
	end
	if args.handle_multiplayer_type_choice == nil then
		error("args.handle_multiplayer_type_choice is nil", 2)
	end
	if args.player_choices == nil then
		error("args.player_choices is nil", 2)
	end
	if args.player_name_to_id == nil then
		error("args.player_name_to_id is nil", 2)
	end
	if args.player_id_to_nice_name == nil then
		error("args.player_id_to_nice_name is nil", 2)
	end
	if args.get_msg == nil then
		error("args.get_msg is nil", 2)
	end

	g_args  = args
	if g_args.supports_local_multiplayer then
		show_multiplayer_type_popup()
	else
		show_player_choice_popup()
	end
	alex_c_api.send_message("all", string.format("%s:", MSG_HEADER_PLAYER_JOINED))
end

local function broadcast_this_player_choice(player_choice)
	alex_c_api.send_message("all", string.format("%s:%d", MSG_HEADER_AM_PLAYER, player_choice))
end

local function add_player(state, src)
	for _, player_name in ipairs(state.players_join_order) do
		if player_name == src then
			return
		end
	end

	table.insert(state.players_join_order, src)
end

local function remove_player(state, src)
	local player_idx = nil
	for idx, val in ipairs(state.players_join_order) do
		if val == src then
			player_idx = idx
			break
		end
	end

	if player_idx ~= nil then
		table.remove(state.players_join_order, player_idx)
	else
		-- This can happen if:
		-- remote player joins
		-- current player joins
		-- remote player leaves -- current player gets the notification that the
		--  remote player left, but there's no entry in this table to remove.
		print(string.format("Could not find player %s in players_join_order", src))
	end
end

function two_player.am_first_player()
	local players_join_order = g_state.players_join_order 
	return #players_join_order > 0 and players_join_order[1] == two_player.THIS_PLAYER
end

function two_player.get_player_count()
	return #g_state.players_join_order
end

-- returns true if the message was handled, false otherwise
function two_player.handle_msg_received(src, msg)
	if g_state.multiplayer_type_selected == two_player.MULTIPLAYER_TYPE_LOCAL then
		return true
	end

	-- print("handle_msg_received (from src:" .. src .. "): " .. msg);
	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == MSG_HEADER_AM_PLAYER then
		if g_args == nil then
			error("two_player.init not called yet, but received msg")
		end
		local other_player = tonumber(payload)
		g_args.player_name_to_id[src] = other_player
		add_player(g_state, src)
		--g_args.handle_player_choice(src, other_player)
		if need_player_reselect(other_player) then
			if g_state.multiplayer_type_selected == two_player.MULTIPLAYER_TYPE_NETWORK then
				show_player_choice_popup()
			end
		else
			alex_c_api.hide_popup()
		end
		-- Make sure that `hide_popup` isn't called after calling this, since
		-- the client may show their own popup that this library shouldn't hide.
		g_args.handle_player_choice(src, other_player)
		alex_c_api.set_status_msg(string.format("Player %s chose to be %s", src, g_args.player_id_to_nice_name(other_player)))
		return true
	elseif header == MSG_HEADER_PLAYER_JOINED then
		-- When new players join, if the local player has already chosen, then tell them.
		-- This way their popup will show the existing choice.
		local this_player_choice = g_args.get_local_player_choice()
		if this_player_choice ~= nil then
			broadcast_this_player_choice(this_player_choice)
		end
		alex_c_api.set_status_msg(string.format("Player %s joined", src))
		return true
	elseif header == "player_left" and src == "ctrl" then
		print("player left")
		local player_name = payload
		local player_id = g_args.player_name_to_id[player_name]
		alex_c_api.set_status_msg(string.format("Player %s (%s) left", player_name, g_args.player_id_to_nice_name(player_id)))
		g_args.player_name_to_id[player_name] = nil
		remove_player(g_state, player_name)
		-- TODO I don't see how this was ever true,
		-- and why show a popup when another player leaves?
		-- You can just make your move, and maybe they'll rejoin
		--[[
		if need_player_reselect() then
			if g_state.multiplayer_type_selected == two_player.MULTIPLAYER_TYPE_NETWORK then
				print("showing popup")
				show_player_choice_popup()
			end
		end
		--]]
		-- this is a system level message that is handled by more than just us, do not return false,
		-- allow the client to handle this too if necessary
		return false
	else
		--print(string.format("two_player: unhandled msg from src=\"%s\", header=\"%s\"", src, header))
		return false
	end
end

function two_player.handle_popup_btn_clicked(popup_id, btn_idx)
	if popup_id == two_player.PLAYER_CHOICE_POPUP_ID then
		local player_idx = g_args.choice_id_to_player_id(btn_idx)
		if player_idx == nil then
			error(string.format("btn_idx=%s, player_idx=%s", btn_idx, player_idx))
		end
		g_args.player_name_to_id[two_player.THIS_PLAYER] = player_idx
		add_player(g_state, two_player.THIS_PLAYER)
		broadcast_this_player_choice(player_idx)
		alex_c_api.hide_popup()
		g_args.handle_player_choice(two_player.LOCAL_PLAYER, player_idx)
		return true
	elseif popup_id == two_player.MULTIPLAYER_TYPE_POPUP_ID then
		if btn_idx == multiplayer_type_btn_local then
			alex_c_api.hide_popup()
			g_state.multiplayer_type_selected = two_player.MULTIPLAYER_TYPE_LOCAL
			g_args.handle_multiplayer_type_choice(two_player.MULTIPLAYER_TYPE_LOCAL)
		elseif btn_idx == multiplayer_type_btn_network then
			alex_c_api.hide_popup()
			g_state.multiplayer_type_selected = two_player.MULTIPLAYER_TYPE_NETWORK
			g_args.handle_multiplayer_type_choice(two_player.MULTIPLAYER_TYPE_NETWORK)
			show_player_choice_popup()
		else
			error(string.format("Unhandled multiplayer type btn=%q", btn_idx))
		end
		return true
	else
		return false
	end
end


return two_player
--[[
-- This library allows for 0 or more players to join a game hosted by a player.
--
-- It is best suited for games where the players don't need to pick a role (e.g.
-- black or white pieces in a game like chess), they will simply be e.g. "Player 2"
--
--]]

local wait_for_players = {}

local alex_c_api = require("alex_c_api")
local show_buttons_popup = require("libs/ui/show_buttons_popup")

local POPUP_ID_WAITING_FOR_PLAYERS = "waiting_for_players"
-- Only the host can start the game
local POPUP_WAITING_FOR_PLAYERS_HOST_BTNS = {
	"Start game",
}


local players    = nil
local player     = nil
local player_name_to_idx = {}
local is_client  = nil
local start_game_host_func  = nil
local start_game_client_func = nil

function wait_for_players.init(players_arg, player_arg,
                               start_game_host_arg, start_game_client_arg)
                               
	players   = players_arg
	player    = player_arg
	is_client = false
	start_game_host_func = start_game_host_arg
	start_game_client_func = start_game_client_arg 

	alex_c_api.set_status_msg("Waiting for players to join as host")
	wait_for_players.show_waiting_for_players_popup()
	alex_c_api.send_message("all", string.format("joined:"))
end

local function get_vacant_player_spot(players)
	local idx = 1
	while true do
		if players[idx] == nil then
			return idx
		end
		idx = idx + 1
	end
end


function wait_for_players.is_host_tentative()
	return not is_client
end

function wait_for_players.players_tentative()
	print("returning players count ", #players)
	return players
end

function wait_for_players.show_waiting_for_players_popup()
	local body_txt = string.format("Players joined: %d", #players)
	print("Player is %q", player)
	for player_id, player_ip in pairs(players) do
		local more_info = ""
		if player_id == player then
			if is_client then
				more_info = "(you) "
			else
				more_info = "(you, host) "
			end
		end
		print(string.format("Player %d: %s%s", player_id, more_info, player_ip))
		body_txt = body_txt .. string.format("\nPlayer %d: %s%s", player_id, more_info, player_ip)
	end

	local btns = {}
	if is_client then
		body_txt = body_txt .. "\nWaiting for host to start the game"
	else
		btns = POPUP_WAITING_FOR_PLAYERS_HOST_BTNS
	end
	show_buttons_popup.show_popup(POPUP_ID_WAITING_FOR_PLAYERS,
	                      "Waiting for players",
	                      body_txt,
	                      btns)
end

function wait_for_players.handle_popup_btn_clicked(popup_id, btn_idx)
	if popup_id == POPUP_ID_WAITING_FOR_PLAYERS then
		if btn_idx == 0 then
			alex_c_api.send_message("all", "start_game:")
			start_game_host_func(players, player, player_name_to_idx)
			alex_c_api.hide_popup()
			return true
		end
	end
	return false
end

local function become_client_player(player_idx, player_name)
	alex_c_api.set_status_msg(string.format("You are player %d (client), %s", player_idx, player_name))
	is_client = true
	player = player_idx
	players = { [player_idx] = "You" }
	-- I don't remember why I left this comment... it was originally on the 31's game main
	-- TODO call some game31s API to return client state
end


function wait_for_players.handle_msg_received(src, msg)
	local m = msg:gmatch("([^:]+):(.*)")
	local header, payload
	header, payload = m()

	if header == "player" then
		local m = payload:gmatch("(%d+),(.*)")
		local new_player_idx, new_player_name = m()
		become_client_player(tonumber(new_player_idx), new_player_name)
		wait_for_players.show_waiting_for_players_popup()
	elseif header == "clear_players" then
		if is_client then
			print("Clearing players")
			player = nil
			players = {}
		end
	elseif header == "add_player" then
		local m = payload:gmatch("(%d+),(.*)")
		local new_player_idx, new_player_name = m()
		new_player_idx = tonumber(new_player_idx)
		alex_c_api.set_status_msg(string.format("Player %d joined from %s", new_player_idx, new_player_name))
		players[new_player_idx] = new_player_name
		player_name_to_idx[new_player_name] = new_player_idx
		wait_for_players.show_waiting_for_players_popup()
	elseif header == "player_left" then
		if src ~= "ctrl" then
			error("Received 'player_left' message from another player")
			return
		end
		local player_left_name = payload
		local player_left_idx = player_name_to_idx[player_left_name]
		local player_left_msg = string.format("Player %s \"%s\" left", player_left_idx, player_left_name)
		alex_c_api.set_status_msg(player_left_msg)
		if player_left_idx == nil then
			print(string.format("Player leaving \"%s\" is not in players map", player_left_name))
			return
		end
		table.remove(players, player_left_idx)
		player_name_to_idx[player_left_name] = nil

		alex_c_api.send_message("all", "clear_players:")
		-- Must update all players with their number, since
		-- they've changed (if player 2 leaves, player 3 will now be player 2)
		for player_idx,_ in ipairs(players) do
			local player_name = players[player_idx]
			alex_c_api.send_message(player_name, string.format("player:%d,%s", player_idx, player_name))
		end
		for player_idx,_ in ipairs(players) do
			alex_c_api.send_message("all", string.format("add_player:%d,%s", player_idx, players[player_idx]))
		end
		wait_for_players.show_waiting_for_players_popup()
	elseif header == "joined" then
		if not is_client then
			players_joined = get_vacant_player_spot(players)
			local new_player_idx = players_joined
			-- TODO will need to let new players choose their player idx
			players[new_player_idx] = src
			player_name_to_idx[src] = new_player_idx

			-- TODO don't show this if the game has started?
			wait_for_players.show_waiting_for_players_popup()

			alex_c_api.send_message(src, string.format("player:%d,%s", new_player_idx, src))
			for player_id, player_name in pairs(players) do
				if player_id == new_player_idx then
					goto next_player
				end
				if player_name == "You" then
					player_name = "Host"
				end
				alex_c_api.send_message(src, string.format("add_player:%d,%s", player_id, player_name))
				::next_player::
			end
			-- Should loop through existing players and tell only this new one
			-- who else has already joined
			alex_c_api.send_message("all", string.format("add_player:%d,%s", new_player_idx, src))
			alex_c_api.set_status_msg(string.format("Player %d joined from %s", new_player_idx, src))

			-- TODO originally, in 31's, I called this here.
			-- Need to re-examine all this if a game is ongoing...
			-- send_state_updates_if_host()
		end
	elseif header == "start_game" then
		if is_client then
			alex_c_api.hide_popup()
			start_game_client_func(players, player, player_name_to_idx)
		end
	else
		return false
	end

	return true
end

return wait_for_players
local bit_pack = {}

local function bit_mask(pos)
	return (1<<pos) - 1
end

local function to_bin_str(val, places)
	if val == nil then return 'nil' end
	local bin_str = ''
	if places == nil then
		places = 8
	end
	for i=places-1,0,-1 do
		if ( val & (1<<i) ) > 0 then
			bin_str = bin_str .. '1'
		elseif places ~= nil or #bin_str > 0 then
			bin_str = bin_str .. '0'
		end
	end

	if #bin_str == 0 then
		return '0'
	else
		return bin_str
	end
end

function bit_pack.pack(vals_list, bit_count)
	local packed_bytes = {}
	local bit_buff = 0
	local bits_written = 0
	for _, val in ipairs(vals_list) do
		bit_buff = (bit_buff << bit_count) | (val & bit_mask(bit_count))
		bits_written = bits_written + bit_count

		if bits_written >= 8 then
			local byte_to_write = bit_buff >> (bits_written - 8)
			bits_written = bits_written - 8
			bit_buff = bit_buff & bit_mask(bits_written)
			table.insert(packed_bytes, byte_to_write)
		end
	end

	if bits_written > 0 then
		table.insert(packed_bytes, bit_buff << (8 - bits_written))
	else
		bits_written = 8
	end

	table.insert(packed_bytes, bits_written)

	return packed_bytes
end

function bit_pack.unpack(packed_bytes, bit_count)
	local vals = {}
	local bits_in_last_byte = packed_bytes[ #packed_bytes ]
	local bits_in_buff = 0
	local bit_buff = 0

	for idx, byte in ipairs(packed_bytes) do
		local bits_to_read
		local offset
		if idx == #packed_bytes - 1 then
			bits_to_read = bits_in_last_byte
			offset = 8 - bits_in_last_byte
		elseif idx < #packed_bytes - 1 then
			bits_to_read = 8
			offset = 0
		elseif idx == #packed_bytes then
			goto next_idx
		else
			error(string.format("Unhandled idx %d, len %d", idx, #packed_bytes))
		end

		bits_to_read = bits_to_read + bits_in_buff
		bit_buff = (bit_buff << 8) | byte
		while bits_to_read >= bit_count do
			local val = bit_buff >> (bits_to_read - bit_count + offset)
			bits_to_read = bits_to_read - bit_count
			bit_buff = bit_buff & (bit_mask(bits_to_read) << offset)
			table.insert(vals, val)
		end

		bits_in_buff = bits_to_read
		::next_idx::
	end

	return vals
end

local function lists_eq(list1, list2)
	if #list1 ~= list2 then return false end
	for i, val1 in ipairs(list1) do
		if list1[i] ~= list2[i] then
			return false
		end
	end

	return true
end


--[[
local packed = bit_pack.pack({ 0, 1, 2, 3, 4, 5, 6, 7 }, 3)
local expected_output = { tonumber("000".."001" .. "01", 2), 
                          tonumber("0" .. "011".."100" .. "1", 2), 
                          tonumber("01" .. "110" .. "111", 2),
                          8 }
print(string.format('eq: %s',  lists_eq(expected_output, packed)))

print('')
for i=7,0,-1 do
	io.write(i)
end
io.write('\n')
print('---------')
for i, val in ipairs(packed) do
	print(val)
	assert(val < 256)
	print(to_bin_str(val, 8), to_bin_str(expected_output[i], 8), val == expected_output[i])
end

print('---expected:')
for _, val in ipairs(expected_output) do
	print(to_bin_str(val, 8))
end

-- 000 001 01
-- 0 011 110 1
-- 01 110 001
-- 00 000000
--]]

return bit_pack
local serialize = {}

function serialize.bytestr_to_byteary(bytestr)
	if bytestr == nil then
		error("arg is nil", 2)
	end
	local byteary = {}
	for i=1,#bytestr do
		byteary[i] = bytestr:sub(i,i)
	end
	return byteary
end

function serialize.serialize_byte(val)
	if val == nil then
		val = 255
	end
	-- return string.char(val)
	local output
	local state, err = pcall(function() output = string.char(val) end )
	if not state then
		error(string.format("bad argument to serialize_byte: %s", val), 2)
	end
	return output
end

function serialize.deserialize_byte(bytes)
	if bytes == nil then
		error("arg is nil", 2)
	elseif #bytes == 0 then
		error("arg is length 0", 2)
	end
	if type(bytes) ~= "table" then
		error(string.format("arg is %s, expected table", type(bytes)), 2)
	end
	local val = string.byte(table.remove(bytes, 1))
	if val == 255 then return nil end
	return val
end




function serialize.serialize_16bit(val)
	local output = ""
	local orig_val = val
	if val == nil then
		val = 0x7fff
	else
		val = math.floor(val)
	end
	val = val + 0x7fff
	if not(0 <= val and val <= 0xffff) then
		error(string.format("Need 16 bit val, recvd %s", orig_val))
		return nil
	end
	output = output .. string.char(math.floor((val/256))&0xff)
	output = output .. string.char(math.floor(val%256))
	return output
end

function serialize.deserialize_16bit(bytes)
	if #bytes < 2 then
		error(string.format("Expected at least 2 bytes, recvd %d", #bytes))
	end
	local msb = string.byte(table.remove(bytes,1))
	local lsb = string.byte(table.remove(bytes,1))
	local val = ((msb << 8) | lsb) - 0x7fff
	--print(string.format("deserialize_16bit %02x %02x returning %s", msb, lsb, val))
	if val == 0x7fff then
		return nil
	else
		return val
	end
end

function serialize.serialize_s32(val)
	if val == nil then
		error("nil arg", 2)
	end
	local bytes = {}
	local byte_count = 4
	local orig_val = val
	val = val + 0x7fffffff
	if not(0 <= val and val <= 0xffffffff) then
		error(string.format("val %s is out of range for s32", orig_val))
	end

	for i=1,byte_count do
		bytes[byte_count-i+1] = string.char(val & 0xFF)
		val = val >> 8
	end
	return table.concat(bytes, "")
end

local s32_nil = 0x7ffffffe
function serialize.serialize_s32_nilable(val)
	if val == nil then
		val = s32_nil
	end
	return serialize.serialize_s32(val)
end

function serialize.deserialize_s32_nilable(bytes)
	local val = serialize.deserialize_s32(bytes)
	if val == s32_nil then
		return nil
	else
		return val
	end
end

function serialize.deserialize_s32(bytes)
	local val = 0
	local byte_count = 4
	if #bytes < byte_count then
		error(string.format("Expected at least %d bytes, recvd %d", byte_count, #bytes))
		return
	end
	for i=1,byte_count do
		local bit_pos = 8 * (byte_count-i)
		val = val | (string.byte(table.remove(bytes,1))<<bit_pos)
	end
	val = val - 0x7fffffff
	return val
end

function serialize.serialize_u64(val)
	if val == nil then
		error("nil arg", 2)
	end
	local bytes = {}
	local byte_count = 8
	local orig_val = val

	for i=1,byte_count do
		bytes[byte_count-i+1] = string.char(val & 0xFF)
		val = val >> 8
	end
	return table.concat(bytes, "")
end

function serialize.deserialize_u64(bytes)
	local val = 0
	local byte_count = 8
	if #bytes < byte_count then
		error(string.format("Expected at least %d bytes, recvd %d", byte_count, #bytes))
		return
	end
	for i=1,byte_count do
		local bit_pos = 8 * (byte_count-i)
		val = val | (string.byte(table.remove(bytes,1))<<bit_pos)
	end
	return val
end

function serialize.serialize_bool(val)
	if val then return string.char(1)
	else return string.char(0) end
end

function serialize.deserialize_bool(bytes)
	if bytes == nil then
		error(string.format("arg is nil"), 2)
	elseif #bytes == 0 then
		error(string.format("arg is empty"), 2)
	end
	local byte = string.byte(table.remove(bytes,1))
	if byte == 0 then return false
	elseif byte == 1 then return true
	else error(string.format("invalid byte for bool %s", byte), 2) end
end

function serialize.serialize_string(s)
	if s == nil then
		return serialize.serialize_16bit(0x7fff)
	end
	return serialize.serialize_16bit(#s) .. s
end

function serialize.deserialize_string(bytes)
	--print("deserialize_string called with byte count = " .. #bytes)
	local str_len = serialize.deserialize_16bit(bytes)
	-- TODO which is expected?
	if str_len == 0x7fff or str_len == nil then
		return nil
	end
	--print(string.format("str_len = %s", str_len))
	if #bytes < str_len then
		error(string.format("serialize_lib.deserialize_string only has %d bytes remaining, expected %d", #bytes, str_len), 2)
	end
	local chars = {}
	for i=1,str_len do
		table.insert(chars, table.remove(bytes, 1))
	end
	--print("deserialize_string finished with byte count = " .. #bytes)
	local s = table.concat(chars, "")
	--print(string.format("returning str = \"%s\"", s))
	return s
end

function serialize.serialize_bytes(bytes)
	local chars = {}
	for i, val in ipairs(bytes) do
		if val < 0 or val > 255 then
			error(string.format("serialize_bytes: Found val %d at idx %d, must be between 0 and 255", val, i), 2)
		end
		table.insert(chars, string.char(val))
	end
	return table.concat(chars, "")
end

function serialize.deserialize_bytes(bytes_chars)
	print(string.format("arg is %s",bytes_chars))
	if bytes_chars == nil then error("nil arg", 2) end
	local vals = {}
	for i=1,#bytes_chars do
		table.insert(vals, string.byte(bytes_chars[1]))
		table.remove(bytes_chars, 1)
	end
	return vals
end

return serialize
local storage_helpers = {}

local utils = require("libs/utils")

local alex_c_api = require("alex_c_api")

function storage_helpers.store_bool(key, val)
	if type(val) ~= 'boolean' then
		error(string.format("Expected arg val to be type boolean, was %s", type(val)),2)
	end

	data = { utils.boolean_to_number(val) }

	alex_c_api.store_data(key, data)
end

function storage_helpers.read_bool(key, default_val)
	local data = alex_c_api.read_stored_data(key)

	if data == nil then
		return default_val
	end

	if #data ~= 1 then
		error(string.format("Expected a single byte when reading stored value %s, received %d bytes", key, #data))
	end

	local val = string.byte(data:sub(1,1))
	print(string.format("val = %s", val))

	return utils.number_to_boolean(val)
end

return storage_helpers
local shuffle = {}

local function swap(array, index1, index2)
    array[index1], array[index2] = array[index2], array[index1]
end

function shuffle.shuffle(array)
    local counter = #array
    while counter > 1 do
        local index = math.random(counter)
        swap(array, index, counter)
        counter = counter - 1
    end
end

return shuffle
local touch_to_mouse_evts = {}

local alex_c_api = require("alex_c_api")

function touch_to_mouse_evts.init(funcs)
	local state = {
		active_touch_id  = nil,
		handle_mouse_evt = funcs.handle_mouse_evt,
		handle_mousemove = funcs.handle_mousemove,
	}
	alex_c_api.enable_evt("touch")
	return state
end

function touch_to_mouse_evts.handle_touch_evt(state, evt_id, changed_touches)
	local params = {
		is_touch = true,
	}
	for _, touch in ipairs(changed_touches) do
		local y = math.floor(touch.y)
		local x = math.floor(touch.x)
		if state.active_touch == touch.id then
			if evt_id == 'touchmove' then
				state.handle_mousemove(y, x)
			elseif evt_id == 'touchend' then
				state.handle_mouse_evt(alex_c_api.MOUSE_EVT_UP, y, x, params)
				state.active_touch = nil
			elseif evt_id == 'touchcancel' then
				state.handle_mouse_evt(alex_c_api.MOUSE_EVT_DOWN, y, x, params)
				state.active_touch = nil
			end
		end

		if evt_id == 'touchstart' then
			if state.active_touch == nil then
				state.active_touch = touch.id
				state.handle_mouse_evt(alex_c_api.MOUSE_EVT_DOWN, y, x, params)
			end
		end
	end

end

return touch_to_mouse_evts
local buttons = {}

local alex_c_api = require("alex_c_api")
local draw_shapes = require("libs/draw/draw_shapes")

buttons.BTN_SHAPE_RECT     = "rect" -- sending nil instead of this works too
buttons.BTN_SHAPE_TRIANGLE = "triangle"

function buttons.new_state()
	local state = {
		buttons = {},
		btn_id_map = {},
	}
	return state
end

function buttons.new_button(state, btn_params)
	if state == nil then error("state is nil", 2) end
	if btn_params.id == nil then
		error("btn_params.id is nil", 2)
	end
	if btn_params.text == nil then
		error("btn_params.text is nil", 2)
	end
	local enabled = true
	if btn_params.enabled ~= nil then
		enabled = btn_params.enabled
	end
	local btn_info = {
		id             = btn_params.id,
		text           = btn_params.text,
		bg_colour      = btn_params.bg_colour,
		fg_colour      = btn_params.fg_colour,
		outline_colour = btn_params.outline_colour,
		outline_width  = btn_params.outline_width,
		btn_shape      = btn_params.btn_shape,
		shape_param    = btn_params.shape_param,
		text_size      = btn_params.text_size,
		padding        = btn_params.padding,
		y_start        = btn_params.y_start,
		x_start        = btn_params.x_start,
		--y_end     = btn_params.y_start + btn_params.y_size,
		--x_end     = btn_params.x_start + btn_params.x_size,
		y_end          = btn_params.y_end,
		x_end          = btn_params.x_end,
		enabled        = enabled,
		visible        = true,
		callback       = btn_params.callback,
	}
	table.insert(state.buttons, btn_info)
	state.btn_id_map[btn_params.id] = btn_info
end

function buttons.on_user_click(state, y_pos, x_pos)
	for _, btn_info in ipairs(state.buttons) do
		if btn_info.enabled and btn_info.visible and
		   btn_info.y_start <= y_pos and y_pos <= btn_info.y_end and
		   btn_info.x_start <= x_pos and x_pos <= btn_info.x_end then
			--print(string.format("Pressed button \"%s\"", btn_info.text))
			if btn_info.callback then
				btn_info.callback(btn_info.id)
			end
			return btn_info.id
		end
	end
end

function buttons.set_enabled(state, btn_id, is_enabled)
	state.btn_id_map[btn_id].enabled = is_enabled
end

function buttons.set_visible(state, btn_id, is_visible)
	state.btn_id_map[btn_id].visible = is_visible
end

function buttons.set_text(state, btn_id, text)
	state.btn_id_map[btn_id].text = text
end

function buttons.draw(state)
	for _, btn_info in ipairs(state.buttons) do
		if not btn_info.visible then
			goto next_button
		end
		local btn_width = btn_info.x_end - btn_info.x_start
		local text_align = 0

		local outline_colour = btn_info.outline_colour
		local bg_colour      = btn_info.bg_colour
		local fg_colour      = btn_info.fg_colour

		if not btn_info.enabled then
			outline_colour = '#cccccc88'
			bg_colour      = '#eeeeee88'
			fg_colour      = '#aaaaaa88'
		end

		if btn_info.btn_shape == buttons.BTN_SHAPE_TRIANGLE then
			draw_shapes.draw_triangle_lr(outline_colour, btn_info.outline_width, bg_colour,
			                             btn_info.shape_param,
			                             btn_info.y_start, btn_info.x_start,
			                             btn_info.y_end,   btn_info.x_end)
			if btn_info.shape_param then
				text_align = 1
			else
				text_align = -1
			end
		else
			alex_c_api.draw_rect(bg_colour,
			                     btn_info.y_start, btn_info.x_start,
			                     btn_info.y_end,   btn_info.x_end)
			draw_shapes.draw_rect_outline(outline_colour, btn_info.outline_width,
			                              btn_info.y_start, btn_info.x_start,
			                              btn_info.y_end,   btn_info.x_end)
		end

		local text_y_start = math.floor((btn_info.y_start + btn_info.y_end + btn_info.text_size)/2)
		alex_c_api.draw_text(btn_info.text, fg_colour,
		                     text_y_start, math.floor(btn_info.x_start + btn_width/2),
		                     btn_info.text_size, text_align)
		::next_button::
	end
end

return buttons
local show_buttons_popup = {}

local alex_c_api = require("alex_c_api")

-- This shows a popup with a single message and 0 to many buttons.
--
-- This is originally how the show_popup API worked, so I'm adding
-- this API for compatibility, rather than changing all the old
-- games to use the new API.
function show_buttons_popup.show_popup(popup_id, title, msg, btn_ary)
	local info = {
		title = title,
		items = {},
	}

	table.insert(info.items, {
		item_type = alex_c_api.POPUP_ITEM_TYPE_MSG,
		msg       = msg,
	})

	for btn_id, btn_text in ipairs(btn_ary) do
		table.insert(info.items, {
			item_type = alex_c_api.POPUP_ITEM_TYPE_BTN,
			text      = btn_ary[btn_id],
			id        = (btn_id - 1),
		})
	end

	alex_c_api.show_popup(popup_id, info)
end

return show_buttons_popup
local soft_numpad = {}

local buttons = require("libs/ui/buttons")

function soft_numpad.btn_id(num)
	return string.format("numpad_%d", num)
end

local BUTTON_ID_CLEAR = "numpad_clear"
local BUTTON_ID_BKSP  = "numpad_bksp"

local BUTTON_ID_TO_NUM = {
}
for i=0,9 do
	BUTTON_ID_TO_NUM[soft_numpad.btn_id(i)] = i
end

local function button_pressed(state, btn_id)
	if btn_id == BUTTON_ID_CLEAR then
		state.input_presses = {}
	elseif btn_id == BUTTON_ID_BKSP then
		table.remove(state.input_presses)
	elseif BUTTON_ID_TO_NUM[btn_id] then
		local num = BUTTON_ID_TO_NUM[btn_id]
		table.insert(state.input_presses, num)
	else
		return
	end

	local output_str = ''
	for i, val in ipairs(state.input_presses) do
		if i ~= 1 then output_str = output_str .. ', ' end
		output_str = output_str .. val
	end
	print("input_presses is now: " .. output_str)
end

function soft_numpad.init(numpad_params)
	local state = {
		buttons       = nil,
		input_presses = {},
	}
	state.buttons = buttons.new_state()

	-- [clr] [bksp]
	--    7 8 9
	--    4 5 6
	--    1 2 3
	--      0  

	local num_buttons_y = 5
	local num_buttons_x = 3

	local padding = 5
	if numpad_params.padding ~= nil then
		padding = numpad_params.padding
	end

	local numpad_width = numpad_params.x_end - numpad_params.x_start

	local button_size_y = math.floor((numpad_params.y_end - numpad_params.y_start)/num_buttons_y)
	local button_size_x = math.floor(numpad_width/num_buttons_x)
	local meta_button_size_x = math.floor(numpad_width/2)

	local meta_buttons = {
		{
			id   = BUTTON_ID_CLEAR,
			text = "clear",
		},

		{
			id   = BUTTON_ID_BKSP,
			text = "bksp",
		},
	}
	for meta_btn_idx, btn_info in ipairs(meta_buttons) do
		local x_start = numpad_params.x_start + (meta_btn_idx-1) * meta_button_size_x + padding
		buttons.new_button(state.buttons, {
			id   = btn_info.id,
			text = btn_info.text,
			bg_colour = numpad_params.btn_bg_colour,
			fg_colour = numpad_params.btn_fg_colour,
			text_size = button_size_y - 4*padding,
			outline_colour = numpad_params.btn_outline_colour,
			outline_width  = numpad_params.btn_outline_width,
			padding   = padding,
			y_start = numpad_params.y_start + padding,
			x_start = x_start,
			y_end   = numpad_params.y_start + button_size_y - padding,
			x_end   = x_start + meta_button_size_x - padding,
			callback = function (btn_id) button_pressed(state, btn_id) end,
		})
	end


	local nums = {
		[7] = { y = 1, x = 1 },
		[8] = { y = 1, x = 2 },
		[9] = { y = 1, x = 3 },

		[4] = { y = 2, x = 1 },
		[5] = { y = 2, x = 2 },
		[6] = { y = 2, x = 3 },

		[1] = { y = 3, x = 1 },
		[2] = { y = 3, x = 2 },
		[3] = { y = 3, x = 3 },

		[0] = { y = 4, x = 2 },
	}

	for num, pos in pairs(nums) do
		local y_start = numpad_params.y_start + (pos.y-1+1)*button_size_y + padding
		local x_start = numpad_params.x_start + (pos.x-1)*button_size_x + padding
		local btn_params = {
			id        = soft_numpad.btn_id(num),
			text      = string.format("%d", num),
			bg_colour = numpad_params.btn_bg_colour,
			fg_colour = numpad_params.btn_fg_colour,
			text_size = math.floor(button_size_y/2),
			padding   = padding,
			y_start   = y_start,
			x_start   = x_start,
			y_end     = y_start + button_size_y - padding,
			x_end     = x_start + button_size_x - padding,
			callback  = function (btn_id) button_pressed(state, btn_id) end,
		}
		buttons.new_button(state.buttons, btn_params)
	end

	return state
end

function soft_numpad.draw(state)
	buttons.draw(state.buttons)
end

function soft_numpad.on_user_click(state, y_pos, x_pos)
	buttons.on_user_click(state.buttons, y_pos, x_pos)
end

function soft_numpad.get_val(state)
	local val_str = ''
	for _, num in ipairs(state.input_presses) do
		val_str = val_str .. num
	end
	return val_str
end

function soft_numpad.set_val(state, val)
	local val_str
	if val ~= 0 then
		val_str = tostring(val)
	else
		val_str = ''
	end
	state.input_presses = {}
	for i=1,#val_str do
		table.insert(state.input_presses, val_str:sub(i,i))
	end
end

return soft_numpad
local touchpad = {}

function touchpad.new_state(touchpad_pos, touchpad_radius)
	return {
		pos    = touchpad_pos,
		radius = touchpad_radius,
		active_touch = nil,

		player_vec = { y = 0, x = 0 },
	}
end

local function touch_in_dirpad(state, touch)
	local dy = (touch.y - state.pos.y)
	local dx = (touch.x - state.pos.x)

	return (math.abs(dy) <= state.radius and
	        math.abs(dx) <= state.radius)
end

function touchpad.handle_touch_evts(state, evt_id, touches)
	local touch_changed = false
	for _, touch in ipairs(touches) do
		if evt_id == 'touchstart' and state.active_touch == nil and touch_in_dirpad(state, touch) then
			state.active_touch = touch.id
			touch_changed = true
		elseif (evt_id == 'touchend' or evt_id == 'touchcancel') and state.active_touch == touch.id then
			state.active_touch = nil
			state.player_vec = { y = 0, x = 0 }
			touch_changed = true
		end

		if state.active_touch == touch.id then
			local dy = (touch.y - state.pos.y)
			local dx = (touch.x - state.pos.x)
			local mag   = math.sqrt(dy*dy + dx*dx) / state.radius
			mag = math.min(mag, 1)
			local angle = math.atan(dy,dx)
			state.player_vec = {
				y = mag*math.sin(angle),
				x = mag*math.cos(angle),
			}
			touch_changed = true
		end
	end

	if touch_changed then
		return state.player_vec
	else
		return nil
	end
end

return touchpad
local utils = {}

function utils.ary_to_str(ary)
	if ary == nil then return "nil" end
	local s = "["
	local first = true
	-- Somehow I didn't realize that ipairs will stop after encountering a nil value,
	-- and pairs will just skip over it.
	--for _, val in ipairs(ary) do
	for i=1,#ary do
		local val = ary[i]
		if not first then
			s = s .. ", "
		end
		first = false
		s = s .. string.format("%s", val)
	end
	s = s .. "]"
	return s
end

function utils.binstr_to_hr_str(binstr)
	if binstr == nil then
		error("arg is nil", 2)
	end
	local s = ""
	for i=1,#binstr do
		local byte = string.byte(binstr:sub(i,i))
		s = s .. string.format("%02x ", byte)
	end
	return s
end

function utils.hr_binstr_to_byte_ary(hr_binstr)
	local byte_ary = {}
	while #hr_binstr > 0 do
		local byte_val_str = hr_binstr:sub(1,3)
		local byte_val = tonumber(byte_val_str, 16)
		table.insert(byte_ary, byte_val)
		if #hr_binstr >= 4 then
			hr_binstr = hr_binstr:sub(4, #hr_binstr)
		else
			break
		end
	end
	return byte_ary
end

function utils.hr_binstr_to_binstr(hr_binstr)
	local byte_ary = utils.hr_binstr_to_byte_ary(hr_binstr)
	local binstr = ''
	for _, val in ipairs(byte_ary) do
		binstr = binstr .. string.char(val)
	end
	return binstr
end

function utils.binary_to_hr_str(binary)
	local s = ""
	for i=1,#binary do
		local byte = string.byte(binary[i])
		s = s .. string.format("%02x ", byte)
	end
	return s
end

-- If iter_dir is positive, returns something like an inclusive python range(start,end,iter)
-- If iter_dir is negative, returns range(end, start, iter)
-- The idea being that this can be used and the order can be reserved simply by making iter_dir 1 or -1
function utils.iter_range(start_idx, end_idx, iter_dir)
	local tbl = {}
	if iter_dir < 0 then
		if start_idx < end_idx then
			local tmp = end_idx
			end_idx = start_idx
			start_idx = tmp
		end
	end
	for i=start_idx, end_idx, iter_dir do
		table.insert(tbl, i)
	end
	return tbl
end

--
-- Given:
--     val_ary       = { 10, 20, 30, 40 }
--     vals_selected = { 40, 20}
-- Will return the indexes in val_ary of vals_selected, e.g.:
--     return { 4, 2 }
function utils.get_val_indexes(val_ary, vals_selected)
	if val_ary == nil or vals_selected == nil then
		error(string.format("get_val_indexes nil args: val_ary = %s, vals_selected = %s", val_ary, vals_selected), 2)
	end
	local val_idxes = {}

	local vals_used = {}
	for i=1,#val_ary do
		vals_used[i] = false
	end

	for _, val_selected in ipairs(vals_selected) do
		for i, val in ipairs(val_ary) do
			if val == val_selected and not vals_used[i] then
				table.insert(val_idxes, i)
				vals_used[i] = true
				goto next_val_selected
			end
		end
		error(string.format("Could not find unused val %s in ary %s", val_selected, utils.ary_to_str(val_ary)), 2)
		::next_val_selected::
	end

	return val_idxes
end

function utils.any_eq(vals, val_arg)
	for _, val in ipairs(vals) do
		if val == val_arg then return true end
	end
	return false
end

function utils.ary_copy(ary)
	local new_ary = {}
	for _, val in ipairs(ary) do
		table.insert(new_ary, val)
	end
	return new_ary
end

function utils.ary_of(val, len)
	local new_ary = {}
	for i=1,len do
		table.insert(new_ary, val)
	end
	return new_ary
end

function utils.reverse_map(map)
	local reversed_map = {}
	for key, value in pairs(map) do
		if reversed_map[value] ~= nil then
			error(string.format("utils.reverse_map: found duplicate values \"%s\" in map", value))
		end
		reversed_map[value] = key
	end
	return reversed_map
end

function utils.table_len(tbl)
	if tbl == nil then
		error("utils.table_len arg is nil", 2)
	end
	local count = 0
	for _, _ in pairs(tbl) do
		count = count + 1
	end
	return count
end

function utils.make_first_char_uppercase(str)
	if str == nil then return nil end
	return (str:gsub("^%l", string.upper))
end

function utils.gmatch_to_list(pattern, str)
	local vals = {}
	for token in str:gmatch(pattern) do
		table.insert(vals, token)
	end

	return vals
end

function utils.slice_list(list, start_idx, end_idx)
	return {table.unpack(list, start_idx, end_idx)}
end

function utils.number_to_boolean(num)
	if type(num) ~= 'number' then
		error(string.format("Argument is type %s, expected number", num, type(num)), 2)
	end

	return num ~= 0
end

function utils.boolean_to_number(val)
	if type(val) ~= 'boolean' then
		error(string.format('Argument %s is type %s, expected boolean', type(val)), 2)
	end

	if val == nil then
		error(string.format('Argument is nil'), 2)
	end

	if val then return 1
	else return 0 end
end

return utils
local words_lib = {}

local alex_dict  = require("alex_c_api.dict")

words_lib.FUN_WORD_FREQ = 3e-6

local ALPHABET = {}
for i=0,25 do
	table.insert(ALPHABET, string.char(string.byte('a') + i))
end


local function get_sql_word_pattern(len)
	local sql_word_pattern = ''
	for _=1,len do
		sql_word_pattern = sql_word_pattern .. '_'
	end
	return sql_word_pattern
end

function words_lib.is_ready()
	return alex_dict.is_ready()
end

function words_lib.get_random_word(language, freq, len)
	-- TODO avoid SQL injection on all of these queries
	--[[
	local rows = alex_dict.get_words(string.format("SELECT word FROM words WHERE freq > %e AND word LIKE '%s' ORDER BY RANDOM() LIMIT 1",
	                                         freq, get_sql_word_pattern(len)), language)
	local word = rows[1][1]
	--]]

	local word = alex_dict.get_random_word({min_length = len, max_length = len, min_freq = freq})
	return word
end

function words_lib.get_possib_word_count(language, freq, len)
	--local rows = alex_dict.get_words(string.format("SELECT COUNT(1) FROM words WHERE freq > %e AND word LIKE '%s'",
	--                                        freq, get_sql_word_pattern(len)), language)
	--return tonumber(rows[1][1])

	-- TODO
	return -1
end

function words_lib.is_valid_word(language, word)
	word = string.lower(word)
	--[[
	local rows = alex_dict.get_words(string.format("SELECT COUNT(1) FROM words WHERE word = '%s'", word), language)
	local count_str = rows[1][1]
	local count = tonumber(count_str)
	return count > 0
	--]]

	return alex_dict.is_valid_word(word)
end

function words_lib.get_words_made_from_letters(language, letters_arg, min_length, min_freq)
	print("get_words_made_from_letters")
	local letters = {}
	for _, letter_arg in ipairs(letters_arg) do
		table.insert(letters, string.lower(letter_arg))
	end
	local letters_count = {}
	for _, letter in ipairs(letters) do
		if letters_count[letter] == nil then
			letters_count[letter] = 0
		end
		letters_count[letter] = letters_count[letter] + 1
	end
	local query = "SELECT word FROM words WHERE\n"
	query = query .. string.format(" LENGTH(word) <= %d \n", #letters)
	query = query .. string.format(" AND LENGTH(word) >= %d \n", min_length)
	query = query .. string.format(" AND freq >= %e \n", min_freq)
	for _, letter in pairs(ALPHABET) do
		local count = 1
		if letters_count[letter] ~= nil then
			count = letters_count[letter] + 1
		end
		print("letter: %s, count: %d", letter, count-1)
		query = query .. " AND word NOT LIKE '%"
		for _=1,count do
			query = query .. letter .. "%"
		end
		query = query .. "' \n"
	end
	query = query .. "ORDER BY LENGTH(word) DESC, freq DESC \n"
	query = query .. "LIMIT 20 \n"

	print(query)
	local rows = alex_dict.get_words(query, language)
	local words = {}
	print(string.format("found %d words fromt these letters", #words))
	for row_idx, row in ipairs(rows) do
		table.insert(words, row[1])
		print(string.format("%3d: %s", row_idx, row[1]))
	end
	return words
end

function words_lib.get_word_freq(language, word)
	local query = string.format("SELECT freq from words WHERE word = %q", word)
	local rows = alex_dict.get_words(query, language)
	if #rows == 0 then return nil end
	return tonumber(rows[1][1])
end

function words_lib.init(language)
	return alex_dict.init(language)
end



return words_lib
